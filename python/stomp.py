# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

import _stomp
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _stomp.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, size_t n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _stomp.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, size_t n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _stomp.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, PySwigIterator x) -> ptrdiff_t"""
        return _stomp.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, PySwigIterator x) -> bool"""
        return _stomp.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _stomp.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _stomp.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _stomp.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, ptrdiff_t n) -> PySwigIterator"""
        return _stomp.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, PySwigIterator x) -> bool"""
        return _stomp.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, PySwigIterator x) -> bool"""
        return _stomp.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, ptrdiff_t n) -> PySwigIterator"""
        return _stomp.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, ptrdiff_t n) -> PySwigIterator"""
        return _stomp.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, ptrdiff_t n) -> PySwigIterator"""
        return _stomp.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, ptrdiff_t n) -> PySwigIterator
        __sub__(self, PySwigIterator x) -> ptrdiff_t
        """
        return _stomp.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _stomp.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class GenericIterator:
    def __init__(self, begin_iter_method, deref_method, incr_method):
        self.it = begin_iter_method()
        self.incr   = incr_method
        self.deref  = deref_method

    def __iter__(self):
        return self

    def next(self):
        obj = self.deref( self.it )
        if obj is not None:
            self.incr( self.it )
            return obj
        else:
            raise StopIteration


def DoubleLT(*args):
  """DoubleLT(double a, double b) -> bool"""
  return _stomp.DoubleLT(*args)

def DoubleLE(*args):
  """DoubleLE(double a, double b) -> bool"""
  return _stomp.DoubleLE(*args)

def DoubleGT(*args):
  """DoubleGT(double a, double b) -> bool"""
  return _stomp.DoubleGT(*args)

def DoubleGE(*args):
  """DoubleGE(double a, double b) -> bool"""
  return _stomp.DoubleGE(*args)

def DoubleEQ(*args):
  """DoubleEQ(double a, double b) -> bool"""
  return _stomp.DoubleEQ(*args)

def MostSignificantBit(*args):
  """MostSignificantBit(uint32_t input_int) -> uint8_t"""
  return _stomp.MostSignificantBit(*args)
class AngularBin(_object):
    """Proxy of C++ AngularBin class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularBin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularBin, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_AngularBin
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> AngularBin
        __init__(self, double theta_min, double theta_max) -> AngularBin
        __init__(self, double theta_min, double theta_max, int16_t n_regions) -> AngularBin
        """
        this = _stomp.new_AngularBin(*args)
        try: self.this.append(this)
        except: self.this = this
    def ClearRegions(*args):
        """ClearRegions(self)"""
        return _stomp.AngularBin_ClearRegions(*args)

    def InitializeRegions(*args):
        """InitializeRegions(self, int16_t n_regions)"""
        return _stomp.AngularBin_InitializeRegions(*args)

    def SetResolution(*args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.AngularBin_SetResolution(*args)

    def CalculateResolution(*args):
        """
        CalculateResolution(self, double lammin=-70.0, double lammax=70.0, uint32_t max_resolution=MaxPixelResolution)
        CalculateResolution(self, double lammin=-70.0, double lammax=70.0)
        CalculateResolution(self, double lammin=-70.0)
        CalculateResolution(self)
        """
        return _stomp.AngularBin_CalculateResolution(*args)

    def SetThetaMin(*args):
        """SetThetaMin(self, double theta_min)"""
        return _stomp.AngularBin_SetThetaMin(*args)

    def SetThetaMax(*args):
        """SetThetaMax(self, double theta_max)"""
        return _stomp.AngularBin_SetThetaMax(*args)

    def SetTheta(*args):
        """SetTheta(self, double theta)"""
        return _stomp.AngularBin_SetTheta(*args)

    def WithinBounds(*args):
        """WithinBounds(self, double theta) -> bool"""
        return _stomp.AngularBin_WithinBounds(*args)

    def WithinSin2Bounds(*args):
        """WithinSin2Bounds(self, double sin2theta) -> bool"""
        return _stomp.AngularBin_WithinSin2Bounds(*args)

    def WithinCosBounds(*args):
        """WithinCosBounds(self, double costheta) -> bool"""
        return _stomp.AngularBin_WithinCosBounds(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.AngularBin_Area(*args)

    def PoissonNoise(*args):
        """PoissonNoise(self, double objects_per_square_degree, double survey_area) -> double"""
        return _stomp.AngularBin_PoissonNoise(*args)

    def AddToPixelWtheta(*args):
        """
        AddToPixelWtheta(self, double dwtheta, double dweight, int16_t region_a=-1, 
            int16_t region_b=-1)
        AddToPixelWtheta(self, double dwtheta, double dweight, int16_t region_a=-1)
        AddToPixelWtheta(self, double dwtheta, double dweight)
        """
        return _stomp.AngularBin_AddToPixelWtheta(*args)

    def AddToWeight(*args):
        """
        AddToWeight(self, double weight, int16_t region=-1)
        AddToWeight(self, double weight)
        """
        return _stomp.AngularBin_AddToWeight(*args)

    def AddToCounter(*args):
        """
        AddToCounter(self, uint32_t step=1, int16_t region=-1)
        AddToCounter(self, uint32_t step=1)
        AddToCounter(self)
        """
        return _stomp.AngularBin_AddToCounter(*args)

    def MoveWeightToGalGal(*args):
        """MoveWeightToGalGal(self)"""
        return _stomp.AngularBin_MoveWeightToGalGal(*args)

    def MoveWeightToGalRand(*args):
        """
        MoveWeightToGalRand(self, bool move_to_rand_gal=False)
        MoveWeightToGalRand(self)
        """
        return _stomp.AngularBin_MoveWeightToGalRand(*args)

    def MoveWeightToRandGal(*args):
        """
        MoveWeightToRandGal(self, bool move_to_gal_rand=False)
        MoveWeightToRandGal(self)
        """
        return _stomp.AngularBin_MoveWeightToRandGal(*args)

    def MoveWeightToRandRand(*args):
        """MoveWeightToRandRand(self)"""
        return _stomp.AngularBin_MoveWeightToRandRand(*args)

    def RescaleGalGal(*args):
        """RescaleGalGal(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleGalGal(*args)

    def RescaleGalRand(*args):
        """RescaleGalRand(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleGalRand(*args)

    def RescaleRandGal(*args):
        """RescaleRandGal(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleRandGal(*args)

    def RescaleRandRand(*args):
        """RescaleRandRand(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleRandRand(*args)

    def Reset(*args):
        """Reset(self)"""
        return _stomp.AngularBin_Reset(*args)

    def ResetPixelWtheta(*args):
        """ResetPixelWtheta(self)"""
        return _stomp.AngularBin_ResetPixelWtheta(*args)

    def ResetWeight(*args):
        """ResetWeight(self)"""
        return _stomp.AngularBin_ResetWeight(*args)

    def ResetCounter(*args):
        """ResetCounter(self)"""
        return _stomp.AngularBin_ResetCounter(*args)

    def ResetGalGal(*args):
        """ResetGalGal(self)"""
        return _stomp.AngularBin_ResetGalGal(*args)

    def ResetGalRand(*args):
        """ResetGalRand(self)"""
        return _stomp.AngularBin_ResetGalRand(*args)

    def ResetRandGal(*args):
        """ResetRandGal(self)"""
        return _stomp.AngularBin_ResetRandGal(*args)

    def ResetRandRand(*args):
        """ResetRandRand(self)"""
        return _stomp.AngularBin_ResetRandRand(*args)

    def Resolution(*args):
        """Resolution(self) -> uint32_t"""
        return _stomp.AngularBin_Resolution(*args)

    def NRegion(*args):
        """NRegion(self) -> int16_t"""
        return _stomp.AngularBin_NRegion(*args)

    def Theta(*args):
        """Theta(self) -> double"""
        return _stomp.AngularBin_Theta(*args)

    def ThetaMin(*args):
        """ThetaMin(self) -> double"""
        return _stomp.AngularBin_ThetaMin(*args)

    def ThetaMax(*args):
        """ThetaMax(self) -> double"""
        return _stomp.AngularBin_ThetaMax(*args)

    def Sin2ThetaMin(*args):
        """Sin2ThetaMin(self) -> double"""
        return _stomp.AngularBin_Sin2ThetaMin(*args)

    def Sin2ThetaMax(*args):
        """Sin2ThetaMax(self) -> double"""
        return _stomp.AngularBin_Sin2ThetaMax(*args)

    def CosThetaMin(*args):
        """CosThetaMin(self) -> double"""
        return _stomp.AngularBin_CosThetaMin(*args)

    def CosThetaMax(*args):
        """CosThetaMax(self) -> double"""
        return _stomp.AngularBin_CosThetaMax(*args)

    def Wtheta(*args):
        """
        Wtheta(self, int16_t region=-1) -> double
        Wtheta(self) -> double
        """
        return _stomp.AngularBin_Wtheta(*args)

    def WthetaError(*args):
        """
        WthetaError(self, int16_t region=-1) -> double
        WthetaError(self) -> double
        """
        return _stomp.AngularBin_WthetaError(*args)

    def WeightedCrossCorrelation(*args):
        """
        WeightedCrossCorrelation(self, int16_t region=-1) -> double
        WeightedCrossCorrelation(self) -> double
        """
        return _stomp.AngularBin_WeightedCrossCorrelation(*args)

    def PixelWtheta(*args):
        """
        PixelWtheta(self, int16_t region=-1) -> double
        PixelWtheta(self) -> double
        """
        return _stomp.AngularBin_PixelWtheta(*args)

    def PixelWeight(*args):
        """
        PixelWeight(self, int16_t region=-1) -> double
        PixelWeight(self) -> double
        """
        return _stomp.AngularBin_PixelWeight(*args)

    def Weight(*args):
        """
        Weight(self, int16_t region=-1) -> double
        Weight(self) -> double
        """
        return _stomp.AngularBin_Weight(*args)

    def Counter(*args):
        """
        Counter(self, int16_t region=-1) -> uint32_t
        Counter(self) -> uint32_t
        """
        return _stomp.AngularBin_Counter(*args)

    def GalGal(*args):
        """
        GalGal(self, int16_t region=-1) -> double
        GalGal(self) -> double
        """
        return _stomp.AngularBin_GalGal(*args)

    def GalRand(*args):
        """
        GalRand(self, int16_t region=-1) -> double
        GalRand(self) -> double
        """
        return _stomp.AngularBin_GalRand(*args)

    def RandGal(*args):
        """
        RandGal(self, int16_t region=-1) -> double
        RandGal(self) -> double
        """
        return _stomp.AngularBin_RandGal(*args)

    def RandRand(*args):
        """
        RandRand(self, int16_t region=-1) -> double
        RandRand(self) -> double
        """
        return _stomp.AngularBin_RandRand(*args)

    def MeanWtheta(*args):
        """MeanWtheta(self) -> double"""
        return _stomp.AngularBin_MeanWtheta(*args)

    def MeanWthetaError(*args):
        """MeanWthetaError(self) -> double"""
        return _stomp.AngularBin_MeanWthetaError(*args)

    def MeanWeightedCrossCorrelation(*args):
        """MeanWeightedCrossCorrelation(self) -> double"""
        return _stomp.AngularBin_MeanWeightedCrossCorrelation(*args)

    def MeanWeightedCrossCorrelationError(*args):
        """MeanWeightedCrossCorrelationError(self) -> double"""
        return _stomp.AngularBin_MeanWeightedCrossCorrelationError(*args)

    def MeanWeight(*args):
        """MeanWeight(self) -> double"""
        return _stomp.AngularBin_MeanWeight(*args)

    def MeanCounter(*args):
        """MeanCounter(self) -> double"""
        return _stomp.AngularBin_MeanCounter(*args)

    def MeanGalGal(*args):
        """MeanGalGal(self) -> double"""
        return _stomp.AngularBin_MeanGalGal(*args)

    def MeanGalRand(*args):
        """MeanGalRand(self) -> double"""
        return _stomp.AngularBin_MeanGalRand(*args)

    def MeanRandGal(*args):
        """MeanRandGal(self) -> double"""
        return _stomp.AngularBin_MeanRandGal(*args)

    def MeanRandRand(*args):
        """MeanRandRand(self) -> double"""
        return _stomp.AngularBin_MeanRandRand(*args)

    def ThetaOrder(*args):
        """ThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_ThetaOrder(*args)

    if _newclass:ThetaOrder = staticmethod(ThetaOrder)
    __swig_getmethods__["ThetaOrder"] = lambda x: ThetaOrder
    def SinThetaOrder(*args):
        """SinThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_SinThetaOrder(*args)

    if _newclass:SinThetaOrder = staticmethod(SinThetaOrder)
    __swig_getmethods__["SinThetaOrder"] = lambda x: SinThetaOrder
    def ReverseResolutionOrder(*args):
        """ReverseResolutionOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_ReverseResolutionOrder(*args)

    if _newclass:ReverseResolutionOrder = staticmethod(ReverseResolutionOrder)
    __swig_getmethods__["ReverseResolutionOrder"] = lambda x: ReverseResolutionOrder
AngularBin_swigregister = _stomp.AngularBin_swigregister
AngularBin_swigregister(AngularBin)
cvar = _stomp.cvar
Pi = cvar.Pi
DegToRad = cvar.DegToRad
RadToDeg = cvar.RadToDeg
StradToDeg = cvar.StradToDeg
EtaOffSet = cvar.EtaOffSet
SurveyCenterRA = cvar.SurveyCenterRA
SurveyCenterDEC = cvar.SurveyCenterDEC
Node = cvar.Node
EtaPole = cvar.EtaPole
Nx0 = cvar.Nx0
Ny0 = cvar.Ny0
HPixLevel = cvar.HPixLevel
MaxPixelLevel = cvar.MaxPixelLevel
HPixResolution = cvar.HPixResolution
MaxPixelResolution = cvar.MaxPixelResolution
ResolutionLevels = cvar.ResolutionLevels
HPixArea = cvar.HPixArea
MaxPixnum = cvar.MaxPixnum
MaxSuperpixnum = cvar.MaxSuperpixnum

def AngularBin_ThetaOrder(*args):
  """AngularBin_ThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_ThetaOrder(*args)

def AngularBin_SinThetaOrder(*args):
  """AngularBin_SinThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_SinThetaOrder(*args)

def AngularBin_ReverseResolutionOrder(*args):
  """AngularBin_ReverseResolutionOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_ReverseResolutionOrder(*args)

class RadialBin(AngularBin):
    """Proxy of C++ RadialBin class"""
    __swig_setmethods__ = {}
    for _s in [AngularBin]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialBin, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularBin]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialBin, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_RadialBin
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> RadialBin
        __init__(self, double r_min, double r_max, double redshift) -> RadialBin
        __init__(self, double r_min, double r_max, double redshift, int16_t n_regions) -> RadialBin
        """
        this = _stomp.new_RadialBin(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetRadiusMin(*args):
        """SetRadiusMin(self, double r_min)"""
        return _stomp.RadialBin_SetRadiusMin(*args)

    def SetRadiusMax(*args):
        """SetRadiusMax(self, double r_max)"""
        return _stomp.RadialBin_SetRadiusMax(*args)

    def SetRadius(*args):
        """SetRadius(self, double r)"""
        return _stomp.RadialBin_SetRadius(*args)

    def SetRedshift(*args):
        """SetRedshift(self, double z)"""
        return _stomp.RadialBin_SetRedshift(*args)

    def WithinRadialBounds(*args):
        """WithinRadialBounds(self, double r) -> bool"""
        return _stomp.RadialBin_WithinRadialBounds(*args)

    def Radius(*args):
        """Radius(self) -> double"""
        return _stomp.RadialBin_Radius(*args)

    def RadiusMin(*args):
        """RadiusMin(self) -> double"""
        return _stomp.RadialBin_RadiusMin(*args)

    def RadiusMax(*args):
        """RadiusMax(self) -> double"""
        return _stomp.RadialBin_RadiusMax(*args)

    def Redshift(*args):
        """Redshift(self) -> double"""
        return _stomp.RadialBin_Redshift(*args)

    def RadialOrder(*args):
        """RadialOrder(RadialBin r_a, RadialBin r_b) -> bool"""
        return _stomp.RadialBin_RadialOrder(*args)

    if _newclass:RadialOrder = staticmethod(RadialOrder)
    __swig_getmethods__["RadialOrder"] = lambda x: RadialOrder
    def ReverseResolutionOrder(*args):
        """ReverseResolutionOrder(RadialBin r_a, RadialBin r_b) -> bool"""
        return _stomp.RadialBin_ReverseResolutionOrder(*args)

    if _newclass:ReverseResolutionOrder = staticmethod(ReverseResolutionOrder)
    __swig_getmethods__["ReverseResolutionOrder"] = lambda x: ReverseResolutionOrder
RadialBin_swigregister = _stomp.RadialBin_swigregister
RadialBin_swigregister(RadialBin)

def RadialBin_RadialOrder(*args):
  """RadialBin_RadialOrder(RadialBin r_a, RadialBin r_b) -> bool"""
  return _stomp.RadialBin_RadialOrder(*args)

def RadialBin_ReverseResolutionOrder(*args):
  """RadialBin_ReverseResolutionOrder(RadialBin r_a, RadialBin r_b) -> bool"""
  return _stomp.RadialBin_ReverseResolutionOrder(*args)

class AngularCorrelation(_object):
    """Proxy of C++ AngularCorrelation class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularCorrelation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularCorrelation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double theta_min, double theta_max, double bins_per_decade, 
            bool assign_resolutions=True) -> AngularCorrelation
        __init__(self, double theta_min, double theta_max, double bins_per_decade) -> AngularCorrelation
        __init__(self, uint32_t n_bins, double theta_min, double theta_max, 
            bool assign_resolutions=True) -> AngularCorrelation
        __init__(self, uint32_t n_bins, double theta_min, double theta_max) -> AngularCorrelation
        """
        this = _stomp.new_AngularCorrelation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AngularCorrelation
    __del__ = lambda self : None;
    def AssignBinResolutions(*args):
        """
        AssignBinResolutions(self, double lammin=-70.0, double lammax=70.0, uint32_t max_resolution=MaxPixelResolution)
        AssignBinResolutions(self, double lammin=-70.0, double lammax=70.0)
        AssignBinResolutions(self, double lammin=-70.0)
        AssignBinResolutions(self)
        """
        return _stomp.AngularCorrelation_AssignBinResolutions(*args)

    def SetMaxResolution(*args):
        """
        SetMaxResolution(self, uint32_t resolution, bool manual_break=True)
        SetMaxResolution(self, uint32_t resolution)
        """
        return _stomp.AngularCorrelation_SetMaxResolution(*args)

    def SetMinResolution(*args):
        """SetMinResolution(self, uint32_t resolution)"""
        return _stomp.AngularCorrelation_SetMinResolution(*args)

    def AutoMaxResolution(*args):
        """AutoMaxResolution(self, uint32_t n_obj, double area)"""
        return _stomp.AngularCorrelation_AutoMaxResolution(*args)

    def InitializeRegions(*args):
        """InitializeRegions(self, int16_t n_regions)"""
        return _stomp.AngularCorrelation_InitializeRegions(*args)

    def ClearRegions(*args):
        """ClearRegions(self)"""
        return _stomp.AngularCorrelation_ClearRegions(*args)

    def NRegion(*args):
        """NRegion(self) -> int16_t"""
        return _stomp.AngularCorrelation_NRegion(*args)

    def FindAutoCorrelation(*args):
        """
        FindAutoCorrelation(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1)
        FindAutoCorrelation(self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindAutoCorrelation(*args)

    def FindCrossCorrelation(*args):
        """
        FindCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1)
        FindCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindCrossCorrelation(*args)

    def FindAutoCorrelationWithRegions(*args):
        """
        FindAutoCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1, 
            uint16_t n_regions=0)
        FindAutoCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1)
        FindAutoCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindAutoCorrelationWithRegions(*args)

    def FindCrossCorrelationWithRegions(*args):
        """
        FindCrossCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1, uint16_t n_regions=0)
        FindCrossCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1)
        FindCrossCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindCrossCorrelationWithRegions(*args)

    def FindPixelAutoCorrelation(*args):
        """
        FindPixelAutoCorrelation(self, Map stomp_map, WAngularVector galaxy)
        FindPixelAutoCorrelation(self, ScalarMap stomp_map)
        """
        return _stomp.AngularCorrelation_FindPixelAutoCorrelation(*args)

    def FindPixelCrossCorrelation(*args):
        """
        FindPixelCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        FindPixelCrossCorrelation(self, ScalarMap stomp_map_a, ScalarMap stomp_map_b)
        """
        return _stomp.AngularCorrelation_FindPixelCrossCorrelation(*args)

    def FindPairAutoCorrelation(*args):
        """
        FindPairAutoCorrelation(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1)
        FindPairAutoCorrelation(self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindPairAutoCorrelation(*args)

    def FindPairCrossCorrelation(*args):
        """
        FindPairCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1)
        FindPairCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindPairCrossCorrelation(*args)

    def Write(*args):
        """Write(self, string output_file_name) -> bool"""
        return _stomp.AngularCorrelation_Write(*args)

    def UseOnlyPixels(*args):
        """UseOnlyPixels(self)"""
        return _stomp.AngularCorrelation_UseOnlyPixels(*args)

    def UseOnlyPairs(*args):
        """UseOnlyPairs(self)"""
        return _stomp.AngularCorrelation_UseOnlyPairs(*args)

    def ThetaMin(*args):
        """
        ThetaMin(self, uint32_t resolution=1) -> double
        ThetaMin(self) -> double
        """
        return _stomp.AngularCorrelation_ThetaMin(*args)

    def ThetaMax(*args):
        """
        ThetaMax(self, uint32_t resolution=1) -> double
        ThetaMax(self) -> double
        """
        return _stomp.AngularCorrelation_ThetaMax(*args)

    def Sin2ThetaMin(*args):
        """
        Sin2ThetaMin(self, uint32_t resolution=1) -> double
        Sin2ThetaMin(self) -> double
        """
        return _stomp.AngularCorrelation_Sin2ThetaMin(*args)

    def Sin2ThetaMax(*args):
        """
        Sin2ThetaMax(self, uint32_t resolution=1) -> double
        Sin2ThetaMax(self) -> double
        """
        return _stomp.AngularCorrelation_Sin2ThetaMax(*args)

    def Begin(*args):
        """
        Begin(self, uint32_t resolution=1) -> ThetaIterator
        Begin(self) -> ThetaIterator
        """
        return _stomp.AngularCorrelation_Begin(*args)

    def End(*args):
        """
        End(self, uint32_t resolution=1) -> ThetaIterator
        End(self) -> ThetaIterator
        """
        return _stomp.AngularCorrelation_End(*args)

    def Find(*args):
        """Find(self, ThetaIterator begin, ThetaIterator end, double sin2theta) -> ThetaIterator"""
        return _stomp.AngularCorrelation_Find(*args)

    def BinIterator(*args):
        """
        BinIterator(self, uint8_t bin_idx=0) -> ThetaIterator
        BinIterator(self) -> ThetaIterator
        """
        return _stomp.AngularCorrelation_BinIterator(*args)

    def NBins(*args):
        """NBins(self) -> uint32_t"""
        return _stomp.AngularCorrelation_NBins(*args)

    def MinResolution(*args):
        """MinResolution(self) -> uint32_t"""
        return _stomp.AngularCorrelation_MinResolution(*args)

    def MaxResolution(*args):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.AngularCorrelation_MaxResolution(*args)

    def Covariance(*args):
        """Covariance(self, uint8_t bin_idx_a, uint8_t bin_idx_b) -> double"""
        return _stomp.AngularCorrelation_Covariance(*args)

    def WriteCovariance(*args):
        """WriteCovariance(self, string output_file_name) -> bool"""
        return _stomp.AngularCorrelation_WriteCovariance(*args)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(*args):
        """_begin_Bins(self) -> std::vector<(Stomp::AngularBin,std::allocator<(Stomp::AngularBin)>)>::const_iterator"""
        return _stomp.AngularCorrelation__begin_Bins(*args)

    def _deref_Bins(*args):
        """_deref_Bins(self, std::vector<(Stomp::AngularBin,std::allocator<(Stomp::AngularBin)>)>::const_iterator iter) -> AngularBin"""
        return _stomp.AngularCorrelation__deref_Bins(*args)

AngularCorrelation_swigregister = _stomp.AngularCorrelation_swigregister
AngularCorrelation_swigregister(AngularCorrelation)

class Pixel(_object):
    """Proxy of C++ Pixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Pixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight=0.0) -> Pixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> Pixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight=0.0) -> Pixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> Pixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight=0.0) -> Pixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> Pixel
        """
        this = _stomp.new_Pixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Pixel
    __del__ = lambda self : None;
    def __lt__(*args):
        """__lt__(self, Pixel pix) -> bool"""
        return _stomp.Pixel___lt__(*args)

    def __eq__(*args):
        """__eq__(self, Pixel pix) -> bool"""
        return _stomp.Pixel___eq__(*args)

    def __ne__(*args):
        """__ne__(self, Pixel pix) -> bool"""
        return _stomp.Pixel___ne__(*args)

    def SetPixnumFromAng(*args):
        """SetPixnumFromAng(self, AngularCoordinate ang)"""
        return _stomp.Pixel_SetPixnumFromAng(*args)

    def SetResolution(*args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.Pixel_SetResolution(*args)

    def SetLevel(*args):
        """SetLevel(self, uint8_t level)"""
        return _stomp.Pixel_SetLevel(*args)

    def SetPixnumFromXY(*args):
        """SetPixnumFromXY(self, uint32_t x, uint32_t y)"""
        return _stomp.Pixel_SetPixnumFromXY(*args)

    def SetWeight(*args):
        """SetWeight(self, double weight)"""
        return _stomp.Pixel_SetWeight(*args)

    def Level(*args):
        """Level(self) -> uint8_t"""
        return _stomp.Pixel_Level(*args)

    def Resolution(*args):
        """Resolution(self) -> uint32_t"""
        return _stomp.Pixel_Resolution(*args)

    def PixelX(*args):
        """PixelX(self) -> uint32_t"""
        return _stomp.Pixel_PixelX(*args)

    def PixelY(*args):
        """PixelY(self) -> uint32_t"""
        return _stomp.Pixel_PixelY(*args)

    def Weight(*args):
        """Weight(self) -> double"""
        return _stomp.Pixel_Weight(*args)

    def ReverseWeight(*args):
        """ReverseWeight(self)"""
        return _stomp.Pixel_ReverseWeight(*args)

    def InvertWeight(*args):
        """InvertWeight(self)"""
        return _stomp.Pixel_InvertWeight(*args)

    def SetToSuperPix(*args):
        """SetToSuperPix(self, uint32_t lo_resolution) -> bool"""
        return _stomp.Pixel_SetToSuperPix(*args)

    def SetToLevel(*args):
        """SetToLevel(self, uint8_t lo_level) -> bool"""
        return _stomp.Pixel_SetToLevel(*args)

    def SubPix(*args):
        """
        SubPix(self, uint32_t hi_resolution, PixelVector pix)
        SubPix(self, uint32_t hi_resolution, uint32_t x_min, uint32_t x_max, 
            uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_SubPix(*args)

    def FirstCohort(*args):
        """FirstCohort(self) -> bool"""
        return _stomp.Pixel_FirstCohort(*args)

    def Area(*args):
        """
        Area() -> double
        Area(uint32_t resolution) -> double
        """
        return _stomp.Pixel_Area(*args)

    if _newclass:Area = staticmethod(Area)
    __swig_getmethods__["Area"] = lambda x: Area
    def Superpixnum(*args):
        """Superpixnum(self) -> uint32_t"""
        return _stomp.Pixel_Superpixnum(*args)

    def HPixnum(*args):
        """HPixnum(self) -> uint32_t"""
        return _stomp.Pixel_HPixnum(*args)

    def Pixnum(*args):
        """Pixnum(self) -> uint32_t"""
        return _stomp.Pixel_Pixnum(*args)

    def Contains(*args):
        """
        Contains(self, uint32_t pixel_resolution, uint32_t pixel_x, uint32_t pixel_y) -> bool
        Contains(self, Pixel pix) -> bool
        Contains(self, AngularCoordinate ang) -> bool
        """
        return _stomp.Pixel_Contains(*args)

    def WithinBounds(*args):
        """
        WithinBounds(self, double lon_min, double lon_max, double lat_min, double lat_max, 
            Sphere sphere) -> bool
        """
        return _stomp.Pixel_WithinBounds(*args)

    def IntersectsBounds(*args):
        """
        IntersectsBounds(self, double lon_min, double lon_max, double lat_min, double lat_max, 
            Sphere sphere) -> bool
        """
        return _stomp.Pixel_IntersectsBounds(*args)

    def WithinRadius(*args):
        """
        WithinRadius(self, double theta_max, PixelVector pix, bool check_full_pixel=False)
        WithinRadius(self, double theta_max, PixelVector pix)
        """
        return _stomp.Pixel_WithinRadius(*args)

    def WithinAnnulus(*args):
        """
        WithinAnnulus(double theta_min, double theta_max, PixelVector pix, 
            bool check_full_pixel=False)
        WithinAnnulus(double theta_min, double theta_max, PixelVector pix)
        WithinAnnulus(AngularBin theta, PixelVector pix, bool check_full_pixel=False)
        WithinAnnulus(AngularBin theta, PixelVector pix)
        WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
            PixelVector pix, bool check_full_pixel=False)
        WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
            PixelVector pix)
        """
        return _stomp.Pixel_WithinAnnulus(*args)

    if _newclass:WithinAnnulus = staticmethod(WithinAnnulus)
    __swig_getmethods__["WithinAnnulus"] = lambda x: WithinAnnulus
    def BoundingRadius(*args):
        """
        BoundingRadius(self, double theta_max, PixelVector pix)
        BoundingRadius(self, AngularCoordinate ang, double theta_max, PixelVector pix)
        """
        return _stomp.Pixel_BoundingRadius(*args)

    def XYBounds(*args):
        """
        XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max, bool add_buffer=False)
        XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max)
        XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max, bool add_buffer=False)
        XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max)
        XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, uint32_t y_max, 
            bool add_buffer=False)
        XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, uint32_t y_max)
        XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
            IndexVector x_max, uint32_t y_min, uint32_t y_max, 
            bool add_buffer=False)
        XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
            IndexVector x_max, uint32_t y_min, uint32_t y_max)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max, bool add_buffer=False)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max, bool add_buffer=False)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_XYBounds(*args)

    if _newclass:XYBounds = staticmethod(XYBounds)
    __swig_getmethods__["XYBounds"] = lambda x: XYBounds
    def EtaStep(*args):
        """EtaStep(self, double theta) -> uint8_t"""
        return _stomp.Pixel_EtaStep(*args)

    def NearEdgeDistance(*args):
        """NearEdgeDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_NearEdgeDistance(*args)

    def FarEdgeDistance(*args):
        """FarEdgeDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_FarEdgeDistance(*args)

    def NearCornerDistance(*args):
        """NearCornerDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_NearCornerDistance(*args)

    def FarCornerDistance(*args):
        """FarCornerDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_FarCornerDistance(*args)

    def EdgeDistances(*args):
        """EdgeDistances(self, AngularCoordinate ang, double near_edge_distance, double far_edge_distance) -> bool"""
        return _stomp.Pixel_EdgeDistances(*args)

    def IsWithinRadius(*args):
        """
        IsWithinRadius(self, AngularCoordinate ang, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinRadius(self, AngularCoordinate ang, double theta_max) -> bool
        IsWithinRadius(self, Pixel pix, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinRadius(self, Pixel pix, double theta_max) -> bool
        """
        return _stomp.Pixel_IsWithinRadius(*args)

    def IsWithinAnnulus(*args):
        """
        IsWithinAnnulus(self, AngularCoordinate ang, double theta_min, double theta_max, 
            bool check_full_pixel=False) -> bool
        IsWithinAnnulus(self, AngularCoordinate ang, double theta_min, double theta_max) -> bool
        IsWithinAnnulus(self, Pixel pix, double theta_min, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(self, Pixel pix, double theta_min, double theta_max) -> bool
        IsWithinAnnulus(self, AngularCoordinate ang, AngularBin theta, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(self, AngularCoordinate ang, AngularBin theta) -> bool
        IsWithinAnnulus(self, Pixel pix, AngularBin theta, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(self, Pixel pix, AngularBin theta) -> bool
        """
        return _stomp.Pixel_IsWithinAnnulus(*args)

    def IntersectsAnnulus(*args):
        """
        IntersectsAnnulus(self, AngularCoordinate ang, double theta_min, double theta_max) -> int8_t
        IntersectsAnnulus(self, Pixel pix, double theta_min, double theta_max) -> int8_t
        IntersectsAnnulus(self, AngularCoordinate ang, AngularBin theta) -> int8_t
        IntersectsAnnulus(self, Pixel pix, AngularBin theta) -> int8_t
        """
        return _stomp.Pixel_IntersectsAnnulus(*args)

    def Stripe(*args):
        """
        Stripe(self, uint32_t resolution=HPixResolution) -> uint32_t
        Stripe(self) -> uint32_t
        """
        return _stomp.Pixel_Stripe(*args)

    def RA(*args):
        """RA(self) -> double"""
        return _stomp.Pixel_RA(*args)

    def DEC(*args):
        """DEC(self) -> double"""
        return _stomp.Pixel_DEC(*args)

    def GalLon(*args):
        """GalLon(self) -> double"""
        return _stomp.Pixel_GalLon(*args)

    def GalLat(*args):
        """GalLat(self) -> double"""
        return _stomp.Pixel_GalLat(*args)

    def Ang(*args):
        """
        Ang(self, AngularCoordinate ang)
        Ang(self) -> AngularCoordinate
        """
        return _stomp.Pixel_Ang(*args)

    def Lambda(*args):
        """Lambda(self) -> double"""
        return _stomp.Pixel_Lambda(*args)

    def Eta(*args):
        """Eta(self) -> double"""
        return _stomp.Pixel_Eta(*args)

    def UnitSphereX(*args):
        """UnitSphereX(self) -> double"""
        return _stomp.Pixel_UnitSphereX(*args)

    def UnitSphereY(*args):
        """UnitSphereY(self) -> double"""
        return _stomp.Pixel_UnitSphereY(*args)

    def UnitSphereZ(*args):
        """UnitSphereZ(self) -> double"""
        return _stomp.Pixel_UnitSphereZ(*args)

    def LambdaMin(*args):
        """LambdaMin(self) -> double"""
        return _stomp.Pixel_LambdaMin(*args)

    def LambdaMax(*args):
        """LambdaMax(self) -> double"""
        return _stomp.Pixel_LambdaMax(*args)

    def EtaMin(*args):
        """EtaMin(self) -> double"""
        return _stomp.Pixel_EtaMin(*args)

    def EtaMax(*args):
        """EtaMax(self) -> double"""
        return _stomp.Pixel_EtaMax(*args)

    def EtaMaxContinuous(*args):
        """EtaMaxContinuous(self) -> double"""
        return _stomp.Pixel_EtaMaxContinuous(*args)

    def SurveyContinuous(*args):
        """SurveyContinuous(self) -> bool"""
        return _stomp.Pixel_SurveyContinuous(*args)

    def DECMin(*args):
        """DECMin(self) -> double"""
        return _stomp.Pixel_DECMin(*args)

    def DECMax(*args):
        """DECMax(self) -> double"""
        return _stomp.Pixel_DECMax(*args)

    def RAMin(*args):
        """RAMin(self) -> double"""
        return _stomp.Pixel_RAMin(*args)

    def RAMax(*args):
        """RAMax(self) -> double"""
        return _stomp.Pixel_RAMax(*args)

    def RAMaxContinuous(*args):
        """RAMaxContinuous(self) -> double"""
        return _stomp.Pixel_RAMaxContinuous(*args)

    def EquatorialContinuous(*args):
        """EquatorialContinuous(self) -> bool"""
        return _stomp.Pixel_EquatorialContinuous(*args)

    def GalLatMin(*args):
        """GalLatMin(self) -> double"""
        return _stomp.Pixel_GalLatMin(*args)

    def GalLatMax(*args):
        """GalLatMax(self) -> double"""
        return _stomp.Pixel_GalLatMax(*args)

    def GalLonMin(*args):
        """GalLonMin(self) -> double"""
        return _stomp.Pixel_GalLonMin(*args)

    def GalLonMax(*args):
        """GalLonMax(self) -> double"""
        return _stomp.Pixel_GalLonMax(*args)

    def GalLonMaxContinuous(*args):
        """GalLonMaxContinuous(self) -> double"""
        return _stomp.Pixel_GalLonMaxContinuous(*args)

    def GalacticContinuous(*args):
        """GalacticContinuous(self) -> bool"""
        return _stomp.Pixel_GalacticContinuous(*args)

    def ContinuousBounds(*args):
        """ContinuousBounds(self, Sphere sphere) -> bool"""
        return _stomp.Pixel_ContinuousBounds(*args)

    def UnitSphereX_UL(*args):
        """UnitSphereX_UL(self) -> double"""
        return _stomp.Pixel_UnitSphereX_UL(*args)

    def UnitSphereY_UL(*args):
        """UnitSphereY_UL(self) -> double"""
        return _stomp.Pixel_UnitSphereY_UL(*args)

    def UnitSphereZ_UL(*args):
        """UnitSphereZ_UL(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_UL(*args)

    def UnitSphereX_UR(*args):
        """UnitSphereX_UR(self) -> double"""
        return _stomp.Pixel_UnitSphereX_UR(*args)

    def UnitSphereY_UR(*args):
        """UnitSphereY_UR(self) -> double"""
        return _stomp.Pixel_UnitSphereY_UR(*args)

    def UnitSphereZ_UR(*args):
        """UnitSphereZ_UR(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_UR(*args)

    def UnitSphereX_LL(*args):
        """UnitSphereX_LL(self) -> double"""
        return _stomp.Pixel_UnitSphereX_LL(*args)

    def UnitSphereY_LL(*args):
        """UnitSphereY_LL(self) -> double"""
        return _stomp.Pixel_UnitSphereY_LL(*args)

    def UnitSphereZ_LL(*args):
        """UnitSphereZ_LL(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_LL(*args)

    def UnitSphereX_LR(*args):
        """UnitSphereX_LR(self) -> double"""
        return _stomp.Pixel_UnitSphereX_LR(*args)

    def UnitSphereY_LR(*args):
        """UnitSphereY_LR(self) -> double"""
        return _stomp.Pixel_UnitSphereY_LR(*args)

    def UnitSphereZ_LR(*args):
        """UnitSphereZ_LR(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_LR(*args)

    def Iterate(*args):
        """
        Iterate(self, bool wrap_pixel=True)
        Iterate(self)
        """
        return _stomp.Pixel_Iterate(*args)

    def PixelX0(*args):
        """PixelX0(self) -> uint32_t"""
        return _stomp.Pixel_PixelX0(*args)

    def PixelY0(*args):
        """PixelY0(self) -> uint32_t"""
        return _stomp.Pixel_PixelY0(*args)

    def PixelX1(*args):
        """PixelX1(self) -> uint32_t"""
        return _stomp.Pixel_PixelX1(*args)

    def PixelY1(*args):
        """PixelY1(self) -> uint32_t"""
        return _stomp.Pixel_PixelY1(*args)

    def GenerateRandomPoints(*args):
        """
        GenerateRandomPoints(self, AngularVector ang, uint32_t n_point=1)
        GenerateRandomPoints(self, AngularVector ang)
        """
        return _stomp.Pixel_GenerateRandomPoints(*args)

    def ResolutionToLevel(*args):
        """ResolutionToLevel(uint32_t resolution) -> uint8_t"""
        return _stomp.Pixel_ResolutionToLevel(*args)

    if _newclass:ResolutionToLevel = staticmethod(ResolutionToLevel)
    __swig_getmethods__["ResolutionToLevel"] = lambda x: ResolutionToLevel
    def LevelToResolution(*args):
        """LevelToResolution(uint8_t level) -> uint32_t"""
        return _stomp.Pixel_LevelToResolution(*args)

    if _newclass:LevelToResolution = staticmethod(LevelToResolution)
    __swig_getmethods__["LevelToResolution"] = lambda x: LevelToResolution
    def Ang2Pix(*args):
        """Ang2Pix(uint32_t resolution, AngularCoordinate ang, uint32_t pixnum)"""
        return _stomp.Pixel_Ang2Pix(*args)

    if _newclass:Ang2Pix = staticmethod(Ang2Pix)
    __swig_getmethods__["Ang2Pix"] = lambda x: Ang2Pix
    def Pix2Ang(*args):
        """Pix2Ang(uint32_t resolution, uint32_t pixnum, AngularCoordinate ang)"""
        return _stomp.Pixel_Pix2Ang(*args)

    if _newclass:Pix2Ang = staticmethod(Pix2Ang)
    __swig_getmethods__["Pix2Ang"] = lambda x: Pix2Ang
    def Pix2HPix(*args):
        """
        Pix2HPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t output_hpixnum, 
            uint32_t output_superpixnum)
        """
        return _stomp.Pixel_Pix2HPix(*args)

    if _newclass:Pix2HPix = staticmethod(Pix2HPix)
    __swig_getmethods__["Pix2HPix"] = lambda x: Pix2HPix
    def HPix2Pix(*args):
        """
        HPix2Pix(uint32_t input_resolution, uint32_t input_hpixnum, 
            uint32_t input_superpixnum, uint32_t output_pixnum)
        """
        return _stomp.Pixel_HPix2Pix(*args)

    if _newclass:HPix2Pix = staticmethod(HPix2Pix)
    __swig_getmethods__["HPix2Pix"] = lambda x: HPix2Pix
    def SuperPix(*args):
        """
        SuperPix(uint32_t lo_resolution) -> uint32_t
        SuperPix(uint32_t hi_resolution, uint32_t hi_pixnum, uint32_t lo_resolution, 
            uint32_t lo_pixnum)
        """
        return _stomp.Pixel_SuperPix(*args)

    if _newclass:SuperPix = staticmethod(SuperPix)
    __swig_getmethods__["SuperPix"] = lambda x: SuperPix
    def SubPixels(*args):
        """
        SubPixels(uint32_t lo_resolution, uint32_t hi_pixnum, uint32_t hi_resolution, 
            uint32_t x_min, uint32_t x_max, 
            uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_SubPixels(*args)

    if _newclass:SubPixels = staticmethod(SubPixels)
    __swig_getmethods__["SubPixels"] = lambda x: SubPixels
    def NextSubPix(*args):
        """
        NextSubPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t sub_pixnum1, 
            uint32_t sub_pixnum2, uint32_t sub_pixnum3, 
            uint32_t sub_pixnum4)
        """
        return _stomp.Pixel_NextSubPix(*args)

    if _newclass:NextSubPix = staticmethod(NextSubPix)
    __swig_getmethods__["NextSubPix"] = lambda x: NextSubPix
    def AreaIndex(*args):
        """
        AreaIndex(uint32_t resolution, double lammin, double lammax, 
            double etamin, double etamax, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_AreaIndex(*args)

    if _newclass:AreaIndex = staticmethod(AreaIndex)
    __swig_getmethods__["AreaIndex"] = lambda x: AreaIndex
    def PixelBound(*args):
        """
        PixelBound(uint32_t resolution, uint32_t pixnum, double lammin, 
            double lammax, double etamin, double etamax)
        """
        return _stomp.Pixel_PixelBound(*args)

    if _newclass:PixelBound = staticmethod(PixelBound)
    __swig_getmethods__["PixelBound"] = lambda x: PixelBound
    def CohortPix(*args):
        """
        CohortPix(Pixel pix_a, Pixel pix_b, Pixel pix_c)
        CohortPix(uint32_t resolution, uint32_t hpixnum, uint32_t pixnum1, 
            uint32_t pixnum2, uint32_t pixnum3)
        """
        return _stomp.Pixel_CohortPix(*args)

    if _newclass:CohortPix = staticmethod(CohortPix)
    __swig_getmethods__["CohortPix"] = lambda x: CohortPix
    def PixelArea(*args):
        """PixelArea(uint32_t resolution) -> double"""
        return _stomp.Pixel_PixelArea(*args)

    if _newclass:PixelArea = staticmethod(PixelArea)
    __swig_getmethods__["PixelArea"] = lambda x: PixelArea
    def Pix2EtaStep(*args):
        """Pix2EtaStep(uint32_t resolution, uint32_t pixnum, double theta) -> uint8_t"""
        return _stomp.Pixel_Pix2EtaStep(*args)

    if _newclass:Pix2EtaStep = staticmethod(Pix2EtaStep)
    __swig_getmethods__["Pix2EtaStep"] = lambda x: Pix2EtaStep
    def Ang2HPix(*args):
        """
        Ang2HPix(uint32_t resolution, AngularCoordinate ang, uint32_t hpixnum, 
            uint32_t superpixnum)
        """
        return _stomp.Pixel_Ang2HPix(*args)

    if _newclass:Ang2HPix = staticmethod(Ang2HPix)
    __swig_getmethods__["Ang2HPix"] = lambda x: Ang2HPix
    def HPix2Ang(*args):
        """
        HPix2Ang(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            AngularCoordinate ang)
        """
        return _stomp.Pixel_HPix2Ang(*args)

    if _newclass:HPix2Ang = staticmethod(HPix2Ang)
    __swig_getmethods__["HPix2Ang"] = lambda x: HPix2Ang
    def XY2HPix(*args):
        """
        XY2HPix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t hpixnum, 
            uint32_t superpixnum)
        """
        return _stomp.Pixel_XY2HPix(*args)

    if _newclass:XY2HPix = staticmethod(XY2HPix)
    __swig_getmethods__["XY2HPix"] = lambda x: XY2HPix
    def HPix2XY(*args):
        """
        HPix2XY(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            uint32_t x, uint32_t y)
        """
        return _stomp.Pixel_HPix2XY(*args)

    if _newclass:HPix2XY = staticmethod(HPix2XY)
    __swig_getmethods__["HPix2XY"] = lambda x: HPix2XY
    def SuperHPix(*args):
        """
        SuperHPix(uint32_t hi_resolution, uint32_t hi_hpixnum, uint32_t lo_resolution, 
            uint32_t lo_hpixnum)
        """
        return _stomp.Pixel_SuperHPix(*args)

    if _newclass:SuperHPix = staticmethod(SuperHPix)
    __swig_getmethods__["SuperHPix"] = lambda x: SuperHPix
    def NextSubHPix(*args):
        """
        NextSubHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
            uint32_t hpixnum2, uint32_t hpixnum3, 
            uint32_t hpixnum4)
        """
        return _stomp.Pixel_NextSubHPix(*args)

    if _newclass:NextSubHPix = staticmethod(NextSubHPix)
    __swig_getmethods__["NextSubHPix"] = lambda x: NextSubHPix
    def SubHPix(*args):
        """
        SubHPix(uint32_t lo_resolution, uint32_t hi_hpixnum, uint32_t hi_superpixnum, 
            uint32_t hi_resolution, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, 
            uint32_t y_max)
        """
        return _stomp.Pixel_SubHPix(*args)

    if _newclass:SubHPix = staticmethod(SubHPix)
    __swig_getmethods__["SubHPix"] = lambda x: SubHPix
    def HPixelBound(*args):
        """
        HPixelBound(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            double lammin, double lammax, double etamin, 
            double etamax)
        """
        return _stomp.Pixel_HPixelBound(*args)

    if _newclass:HPixelBound = staticmethod(HPixelBound)
    __swig_getmethods__["HPixelBound"] = lambda x: HPixelBound
    def CohortHPix(*args):
        """
        CohortHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
            uint32_t hpixnum2, uint32_t hpixnum3)
        """
        return _stomp.Pixel_CohortHPix(*args)

    if _newclass:CohortHPix = staticmethod(CohortHPix)
    __swig_getmethods__["CohortHPix"] = lambda x: CohortHPix
    def HPixelArea(*args):
        """HPixelArea(uint32_t resolution) -> double"""
        return _stomp.Pixel_HPixelArea(*args)

    if _newclass:HPixelArea = staticmethod(HPixelArea)
    __swig_getmethods__["HPixelArea"] = lambda x: HPixelArea
    def HPix2EtaStep(*args):
        """
        HPix2EtaStep(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            double theta) -> uint8_t
        """
        return _stomp.Pixel_HPix2EtaStep(*args)

    if _newclass:HPix2EtaStep = staticmethod(HPix2EtaStep)
    __swig_getmethods__["HPix2EtaStep"] = lambda x: HPix2EtaStep
    def XY2Pix(*args):
        """XY2Pix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t pixnum)"""
        return _stomp.Pixel_XY2Pix(*args)

    if _newclass:XY2Pix = staticmethod(XY2Pix)
    __swig_getmethods__["XY2Pix"] = lambda x: XY2Pix
    def Pix2XY(*args):
        """Pix2XY(uint32_t resolution, uint32_t pixnum, uint32_t x, uint32_t y)"""
        return _stomp.Pixel_Pix2XY(*args)

    if _newclass:Pix2XY = staticmethod(Pix2XY)
    __swig_getmethods__["Pix2XY"] = lambda x: Pix2XY
    def LocalOrder(*args):
        """LocalOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_LocalOrder(*args)

    if _newclass:LocalOrder = staticmethod(LocalOrder)
    __swig_getmethods__["LocalOrder"] = lambda x: LocalOrder
    def SuperPixelBasedOrder(*args):
        """SuperPixelBasedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_SuperPixelBasedOrder(*args)

    if _newclass:SuperPixelBasedOrder = staticmethod(SuperPixelBasedOrder)
    __swig_getmethods__["SuperPixelBasedOrder"] = lambda x: SuperPixelBasedOrder
    def SuperPixelOrder(*args):
        """SuperPixelOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_SuperPixelOrder(*args)

    if _newclass:SuperPixelOrder = staticmethod(SuperPixelOrder)
    __swig_getmethods__["SuperPixelOrder"] = lambda x: SuperPixelOrder
    def WeightedOrder(*args):
        """WeightedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightedOrder(*args)

    if _newclass:WeightedOrder = staticmethod(WeightedOrder)
    __swig_getmethods__["WeightedOrder"] = lambda x: WeightedOrder
    def WeightMatch(*args):
        """WeightMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightMatch(*args)

    if _newclass:WeightMatch = staticmethod(WeightMatch)
    __swig_getmethods__["WeightMatch"] = lambda x: WeightMatch
    def WeightedPixelMatch(*args):
        """WeightedPixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightedPixelMatch(*args)

    if _newclass:WeightedPixelMatch = staticmethod(WeightedPixelMatch)
    __swig_getmethods__["WeightedPixelMatch"] = lambda x: WeightedPixelMatch
    def PixelMatch(*args):
        """PixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_PixelMatch(*args)

    if _newclass:PixelMatch = staticmethod(PixelMatch)
    __swig_getmethods__["PixelMatch"] = lambda x: PixelMatch
    def ResolveSuperPixel(*args):
        """
        ResolveSuperPixel(PixelVector pix, bool ignore_weight=False)
        ResolveSuperPixel(PixelVector pix)
        """
        return _stomp.Pixel_ResolveSuperPixel(*args)

    if _newclass:ResolveSuperPixel = staticmethod(ResolveSuperPixel)
    __swig_getmethods__["ResolveSuperPixel"] = lambda x: ResolveSuperPixel
    def ResolvePixel(*args):
        """
        ResolvePixel(PixelVector pix, bool ignore_weight=False)
        ResolvePixel(PixelVector pix)
        """
        return _stomp.Pixel_ResolvePixel(*args)

    if _newclass:ResolvePixel = staticmethod(ResolvePixel)
    __swig_getmethods__["ResolvePixel"] = lambda x: ResolvePixel
    def FindUniquePixels(*args):
        """FindUniquePixels(PixelVector input_pix, PixelVector unique_pix)"""
        return _stomp.Pixel_FindUniquePixels(*args)

    if _newclass:FindUniquePixels = staticmethod(FindUniquePixels)
    __swig_getmethods__["FindUniquePixels"] = lambda x: FindUniquePixels
Pixel_swigregister = _stomp.Pixel_swigregister
Pixel_swigregister(Pixel)

def Pixel_Area(*args):
  """
    Area() -> double
    Pixel_Area(uint32_t resolution) -> double
    """
  return _stomp.Pixel_Area(*args)

def Pixel_WithinAnnulus(*args):
  """
    WithinAnnulus(double theta_min, double theta_max, PixelVector pix, 
        bool check_full_pixel=False)
    WithinAnnulus(double theta_min, double theta_max, PixelVector pix)
    WithinAnnulus(AngularBin theta, PixelVector pix, bool check_full_pixel=False)
    WithinAnnulus(AngularBin theta, PixelVector pix)
    WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
        PixelVector pix, bool check_full_pixel=False)
    Pixel_WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
        PixelVector pix)
    """
  return _stomp.Pixel_WithinAnnulus(*args)

def Pixel_XYBounds(*args):
  """
    XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max, bool add_buffer=False)
    XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max)
    XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max, bool add_buffer=False)
    XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max)
    XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, uint32_t y_max, 
        bool add_buffer=False)
    XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, uint32_t y_max)
    XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
        IndexVector x_max, uint32_t y_min, uint32_t y_max, 
        bool add_buffer=False)
    XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
        IndexVector x_max, uint32_t y_min, uint32_t y_max)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max, bool add_buffer=False)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max, bool add_buffer=False)
    Pixel_XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max)
    """
  return _stomp.Pixel_XYBounds(*args)

def Pixel_ResolutionToLevel(*args):
  """Pixel_ResolutionToLevel(uint32_t resolution) -> uint8_t"""
  return _stomp.Pixel_ResolutionToLevel(*args)

def Pixel_LevelToResolution(*args):
  """Pixel_LevelToResolution(uint8_t level) -> uint32_t"""
  return _stomp.Pixel_LevelToResolution(*args)

def Pixel_Ang2Pix(*args):
  """Pixel_Ang2Pix(uint32_t resolution, AngularCoordinate ang, uint32_t pixnum)"""
  return _stomp.Pixel_Ang2Pix(*args)

def Pixel_Pix2Ang(*args):
  """Pixel_Pix2Ang(uint32_t resolution, uint32_t pixnum, AngularCoordinate ang)"""
  return _stomp.Pixel_Pix2Ang(*args)

def Pixel_Pix2HPix(*args):
  """
    Pixel_Pix2HPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t output_hpixnum, 
        uint32_t output_superpixnum)
    """
  return _stomp.Pixel_Pix2HPix(*args)

def Pixel_HPix2Pix(*args):
  """
    Pixel_HPix2Pix(uint32_t input_resolution, uint32_t input_hpixnum, 
        uint32_t input_superpixnum, uint32_t output_pixnum)
    """
  return _stomp.Pixel_HPix2Pix(*args)

def Pixel_SuperPix(*args):
  """
    SuperPix(uint32_t lo_resolution) -> uint32_t
    Pixel_SuperPix(uint32_t hi_resolution, uint32_t hi_pixnum, uint32_t lo_resolution, 
        uint32_t lo_pixnum)
    """
  return _stomp.Pixel_SuperPix(*args)

def Pixel_SubPixels(*args):
  """
    Pixel_SubPixels(uint32_t lo_resolution, uint32_t hi_pixnum, uint32_t hi_resolution, 
        uint32_t x_min, uint32_t x_max, 
        uint32_t y_min, uint32_t y_max)
    """
  return _stomp.Pixel_SubPixels(*args)

def Pixel_NextSubPix(*args):
  """
    Pixel_NextSubPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t sub_pixnum1, 
        uint32_t sub_pixnum2, uint32_t sub_pixnum3, 
        uint32_t sub_pixnum4)
    """
  return _stomp.Pixel_NextSubPix(*args)

def Pixel_AreaIndex(*args):
  """
    Pixel_AreaIndex(uint32_t resolution, double lammin, double lammax, 
        double etamin, double etamax, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, uint32_t y_max)
    """
  return _stomp.Pixel_AreaIndex(*args)

def Pixel_PixelBound(*args):
  """
    Pixel_PixelBound(uint32_t resolution, uint32_t pixnum, double lammin, 
        double lammax, double etamin, double etamax)
    """
  return _stomp.Pixel_PixelBound(*args)

def Pixel_CohortPix(*args):
  """
    CohortPix(Pixel pix_a, Pixel pix_b, Pixel pix_c)
    Pixel_CohortPix(uint32_t resolution, uint32_t hpixnum, uint32_t pixnum1, 
        uint32_t pixnum2, uint32_t pixnum3)
    """
  return _stomp.Pixel_CohortPix(*args)

def Pixel_PixelArea(*args):
  """Pixel_PixelArea(uint32_t resolution) -> double"""
  return _stomp.Pixel_PixelArea(*args)

def Pixel_Pix2EtaStep(*args):
  """Pixel_Pix2EtaStep(uint32_t resolution, uint32_t pixnum, double theta) -> uint8_t"""
  return _stomp.Pixel_Pix2EtaStep(*args)

def Pixel_Ang2HPix(*args):
  """
    Pixel_Ang2HPix(uint32_t resolution, AngularCoordinate ang, uint32_t hpixnum, 
        uint32_t superpixnum)
    """
  return _stomp.Pixel_Ang2HPix(*args)

def Pixel_HPix2Ang(*args):
  """
    Pixel_HPix2Ang(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        AngularCoordinate ang)
    """
  return _stomp.Pixel_HPix2Ang(*args)

def Pixel_XY2HPix(*args):
  """
    Pixel_XY2HPix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t hpixnum, 
        uint32_t superpixnum)
    """
  return _stomp.Pixel_XY2HPix(*args)

def Pixel_HPix2XY(*args):
  """
    Pixel_HPix2XY(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        uint32_t x, uint32_t y)
    """
  return _stomp.Pixel_HPix2XY(*args)

def Pixel_SuperHPix(*args):
  """
    Pixel_SuperHPix(uint32_t hi_resolution, uint32_t hi_hpixnum, uint32_t lo_resolution, 
        uint32_t lo_hpixnum)
    """
  return _stomp.Pixel_SuperHPix(*args)

def Pixel_NextSubHPix(*args):
  """
    Pixel_NextSubHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
        uint32_t hpixnum2, uint32_t hpixnum3, 
        uint32_t hpixnum4)
    """
  return _stomp.Pixel_NextSubHPix(*args)

def Pixel_SubHPix(*args):
  """
    Pixel_SubHPix(uint32_t lo_resolution, uint32_t hi_hpixnum, uint32_t hi_superpixnum, 
        uint32_t hi_resolution, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, 
        uint32_t y_max)
    """
  return _stomp.Pixel_SubHPix(*args)

def Pixel_HPixelBound(*args):
  """
    Pixel_HPixelBound(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        double lammin, double lammax, double etamin, 
        double etamax)
    """
  return _stomp.Pixel_HPixelBound(*args)

def Pixel_CohortHPix(*args):
  """
    Pixel_CohortHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
        uint32_t hpixnum2, uint32_t hpixnum3)
    """
  return _stomp.Pixel_CohortHPix(*args)

def Pixel_HPixelArea(*args):
  """Pixel_HPixelArea(uint32_t resolution) -> double"""
  return _stomp.Pixel_HPixelArea(*args)

def Pixel_HPix2EtaStep(*args):
  """
    Pixel_HPix2EtaStep(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        double theta) -> uint8_t
    """
  return _stomp.Pixel_HPix2EtaStep(*args)

def Pixel_XY2Pix(*args):
  """Pixel_XY2Pix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t pixnum)"""
  return _stomp.Pixel_XY2Pix(*args)

def Pixel_Pix2XY(*args):
  """Pixel_Pix2XY(uint32_t resolution, uint32_t pixnum, uint32_t x, uint32_t y)"""
  return _stomp.Pixel_Pix2XY(*args)

def Pixel_LocalOrder(*args):
  """Pixel_LocalOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_LocalOrder(*args)

def Pixel_SuperPixelBasedOrder(*args):
  """Pixel_SuperPixelBasedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_SuperPixelBasedOrder(*args)

def Pixel_SuperPixelOrder(*args):
  """Pixel_SuperPixelOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_SuperPixelOrder(*args)

def Pixel_WeightedOrder(*args):
  """Pixel_WeightedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightedOrder(*args)

def Pixel_WeightMatch(*args):
  """Pixel_WeightMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightMatch(*args)

def Pixel_WeightedPixelMatch(*args):
  """Pixel_WeightedPixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightedPixelMatch(*args)

def Pixel_PixelMatch(*args):
  """Pixel_PixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_PixelMatch(*args)

def Pixel_ResolveSuperPixel(*args):
  """
    ResolveSuperPixel(PixelVector pix, bool ignore_weight=False)
    Pixel_ResolveSuperPixel(PixelVector pix)
    """
  return _stomp.Pixel_ResolveSuperPixel(*args)

def Pixel_ResolvePixel(*args):
  """
    ResolvePixel(PixelVector pix, bool ignore_weight=False)
    Pixel_ResolvePixel(PixelVector pix)
    """
  return _stomp.Pixel_ResolvePixel(*args)

def Pixel_FindUniquePixels(*args):
  """Pixel_FindUniquePixels(PixelVector input_pix, PixelVector unique_pix)"""
  return _stomp.Pixel_FindUniquePixels(*args)

class PixelOrdering(_object):
    """Proxy of C++ PixelOrdering class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelOrdering, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelOrdering, name)
    __repr__ = _swig_repr
    def __call__(*args):
        """__call__(self, Pixel pix_a, Pixel pix_b) -> int"""
        return _stomp.PixelOrdering___call__(*args)

    def __init__(self, *args): 
        """__init__(self) -> PixelOrdering"""
        this = _stomp.new_PixelOrdering(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_PixelOrdering
    __del__ = lambda self : None;
PixelOrdering_swigregister = _stomp.PixelOrdering_swigregister
PixelOrdering_swigregister(PixelOrdering)

class ScalarPixel(Pixel):
    """Proxy of C++ ScalarPixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarPixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarPixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight=0.0, 
            double intensity=0.0, uint32_t n_points=0) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight=0.0, 
            double intensity=0.0) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight=0.0) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight=0.0, 
            double intensity=0.0, uint32_t n_points=0) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight=0.0, 
            double intensity=0.0) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight=0.0) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight=0.0, 
            double intensity=0.0, uint32_t n_points=0) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight=0.0, 
            double intensity=0.0) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight=0.0) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> ScalarPixel
        """
        this = _stomp.new_ScalarPixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_ScalarPixel
    __del__ = lambda self : None;
    def SetIntensity(*args):
        """SetIntensity(self, double intensity)"""
        return _stomp.ScalarPixel_SetIntensity(*args)

    def SetNPoints(*args):
        """SetNPoints(self, uint32_t n_point)"""
        return _stomp.ScalarPixel_SetNPoints(*args)

    def Intensity(*args):
        """Intensity(self) -> double"""
        return _stomp.ScalarPixel_Intensity(*args)

    def NPoints(*args):
        """NPoints(self) -> uint32_t"""
        return _stomp.ScalarPixel_NPoints(*args)

    def MeanIntensity(*args):
        """MeanIntensity(self) -> double"""
        return _stomp.ScalarPixel_MeanIntensity(*args)

    def AddToIntensity(*args):
        """
        AddToIntensity(self, double intensity, uint32_t n_point=1)
        AddToIntensity(self, double intensity)
        """
        return _stomp.ScalarPixel_AddToIntensity(*args)

    def ScaleIntensity(*args):
        """ScaleIntensity(self, double scale_factor)"""
        return _stomp.ScalarPixel_ScaleIntensity(*args)

    def NormalizeIntensity(*args):
        """NormalizeIntensity(self)"""
        return _stomp.ScalarPixel_NormalizeIntensity(*args)

    def ConvertToOverDensity(*args):
        """ConvertToOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertToOverDensity(*args)

    def ConvertToFractionalOverDensity(*args):
        """ConvertToFractionalOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertToFractionalOverDensity(*args)

    def ConvertFromOverDensity(*args):
        """ConvertFromOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertFromOverDensity(*args)

    def ConvertFromFractionalOverDensity(*args):
        """ConvertFromFractionalOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertFromFractionalOverDensity(*args)

    def UnitSphereX(*args):
        """UnitSphereX(self) -> double"""
        return _stomp.ScalarPixel_UnitSphereX(*args)

    def UnitSphereY(*args):
        """UnitSphereY(self) -> double"""
        return _stomp.ScalarPixel_UnitSphereY(*args)

    def UnitSphereZ(*args):
        """UnitSphereZ(self) -> double"""
        return _stomp.ScalarPixel_UnitSphereZ(*args)

    def _WithinAnnulus(*args):
        """_WithinAnnulus(self, AngularBin theta, ScalarVector pix)"""
        return _stomp.ScalarPixel__WithinAnnulus(*args)

    def IsOverDensity(*args):
        """IsOverDensity(self) -> bool"""
        return _stomp.ScalarPixel_IsOverDensity(*args)

ScalarPixel_swigregister = _stomp.ScalarPixel_swigregister
ScalarPixel_swigregister(ScalarPixel)

class section(_object):
    """Proxy of C++ section class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, section, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, section, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min_stripe"] = _stomp.section_min_stripe_set
    __swig_getmethods__["min_stripe"] = _stomp.section_min_stripe_get
    if _newclass:min_stripe = _swig_property(_stomp.section_min_stripe_get, _stomp.section_min_stripe_set)
    __swig_setmethods__["max_stripe"] = _stomp.section_max_stripe_set
    __swig_getmethods__["max_stripe"] = _stomp.section_max_stripe_get
    if _newclass:max_stripe = _swig_property(_stomp.section_max_stripe_get, _stomp.section_max_stripe_set)
    def __init__(self, *args): 
        """__init__(self) -> section"""
        this = _stomp.new_section(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_section
    __del__ = lambda self : None;
section_swigregister = _stomp.section_swigregister
section_swigregister(section)

class RegionBound(_object):
    """Proxy of C++ RegionBound class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionBound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegionBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> RegionBound
        __init__(self, GeometricBound bound) -> RegionBound
        """
        this = _stomp.new_RegionBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RegionBound
    __del__ = lambda self : None;
    def SetGeometricBound(*args):
        """SetGeometricBound(self, GeometricBound bound)"""
        return _stomp.RegionBound_SetGeometricBound(*args)

    def SetNRegion(*args):
        """SetNRegion(self, uint16_t n_region)"""
        return _stomp.RegionBound_SetNRegion(*args)

    def NRegion(*args):
        """NRegion(self) -> uint16_t"""
        return _stomp.RegionBound_NRegion(*args)

    def CheckPixel(*args):
        """CheckPixel(self, Pixel pix) -> bool"""
        return _stomp.RegionBound_CheckPixel(*args)

    def ScorePixel(*args):
        """ScorePixel(self, Pixel pix) -> double"""
        return _stomp.RegionBound_ScorePixel(*args)

    def AddPixel(*args):
        """AddPixel(self, Pixel pix) -> bool"""
        return _stomp.RegionBound_AddPixel(*args)

    def RemovePixel(*args):
        """RemovePixel(self, Pixel pix) -> bool"""
        return _stomp.RegionBound_RemovePixel(*args)

    def ClearPixels(*args):
        """ClearPixels(self)"""
        return _stomp.RegionBound_ClearPixels(*args)

    def Coverage(*args):
        """Coverage(self, PixelVector pix)"""
        return _stomp.RegionBound_Coverage(*args)

    def CoveragePixels(*args):
        """CoveragePixels(self) -> uint32_t"""
        return _stomp.RegionBound_CoveragePixels(*args)

    def CoverageArea(*args):
        """CoverageArea(self) -> double"""
        return _stomp.RegionBound_CoverageArea(*args)

    def BoundArea(*args):
        """BoundArea(self) -> double"""
        return _stomp.RegionBound_BoundArea(*args)

RegionBound_swigregister = _stomp.RegionBound_swigregister
RegionBound_swigregister(RegionBound)

class RegionMap(_object):
    """Proxy of C++ RegionMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegionMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> RegionMap"""
        this = _stomp.new_RegionMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RegionMap
    __del__ = lambda self : None;
    def InitializeRegions(*args):
        """
        InitializeRegions(self, BaseMap base_map, uint16_t n_region, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(self, BaseMap base_map, uint16_t n_region) -> uint16_t
        InitializeRegions(self, BaseMap base_map, RegionBoundVector region_bounds, 
            uint16_t n_region, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(self, BaseMap base_map, RegionBoundVector region_bounds, 
            uint16_t n_region) -> uint16_t
        InitializeRegions(self, BaseMap base_map, BaseMap source_map) -> bool
        """
        return _stomp.RegionMap_InitializeRegions(*args)

    def _FindRegionResolution(*args):
        """_FindRegionResolution(self, BaseMap base_map, uint16_t n_region, uint32_t region_resolution)"""
        return _stomp.RegionMap__FindRegionResolution(*args)

    def _FindUniqueStripes(*args):
        """_FindUniqueStripes(self, PixelVector coverage_pix, IndexVector unique_stripes)"""
        return _stomp.RegionMap__FindUniqueStripes(*args)

    def _FindSections(*args):
        """
        _FindSections(self, IndexVector unique_stripes, double base_map_area, uint16_t n_region, 
            SectionVector sectionVec)
        """
        return _stomp.RegionMap__FindSections(*args)

    def _Regionate(*args):
        """
        _Regionate(self, PixelVector coverage_pix, SectionVector sectionVec, 
            uint16_t n_region, uint16_t starting_region_index=0)
        _Regionate(self, PixelVector coverage_pix, SectionVector sectionVec, 
            uint16_t n_region)
        """
        return _stomp.RegionMap__Regionate(*args)

    def _VerifyRegionation(*args):
        """_VerifyRegionation(self, uint16_t n_region)"""
        return _stomp.RegionMap__VerifyRegionation(*args)

    def FindRegion(*args):
        """
        FindRegion(self, AngularCoordinate ang) -> int16_t
        FindRegion(self, Pixel pix) -> int16_t
        """
        return _stomp.RegionMap_FindRegion(*args)

    def ClearRegions(*args):
        """ClearRegions(self)"""
        return _stomp.RegionMap_ClearRegions(*args)

    def Region(*args):
        """Region(self, uint32_t region_idx) -> int16_t"""
        return _stomp.RegionMap_Region(*args)

    def RegionArea(*args):
        """
        RegionArea(self, int16_t region, PixelVector pix)
        RegionArea(self, int16_t region) -> double
        """
        return _stomp.RegionMap_RegionArea(*args)

    def NRegion(*args):
        """NRegion(self) -> uint16_t"""
        return _stomp.RegionMap_NRegion(*args)

    def Resolution(*args):
        """Resolution(self) -> uint32_t"""
        return _stomp.RegionMap_Resolution(*args)

    def Initialized(*args):
        """Initialized(self) -> bool"""
        return _stomp.RegionMap_Initialized(*args)

    def Begin(*args):
        """Begin(self) -> RegionIterator"""
        return _stomp.RegionMap_Begin(*args)

    def End(*args):
        """End(self) -> RegionIterator"""
        return _stomp.RegionMap_End(*args)

RegionMap_swigregister = _stomp.RegionMap_swigregister
RegionMap_swigregister(RegionMap)

class BaseMap(_object):
    """Proxy of C++ BaseMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> BaseMap"""
        this = _stomp.new_BaseMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_BaseMap
    __del__ = lambda self : None;
    def Coverage(*args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution, 
            bool calculate_fraction=True)
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.BaseMap_Coverage(*args)

    def FindUnmaskedFraction(*args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.BaseMap_FindUnmaskedFraction(*args)

    def FindUnmaskedStatus(*args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.BaseMap_FindUnmaskedStatus(*args)

    def Empty(*args):
        """Empty(self) -> bool"""
        return _stomp.BaseMap_Empty(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.BaseMap_Clear(*args)

    def Size(*args):
        """Size(self) -> uint32_t"""
        return _stomp.BaseMap_Size(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.BaseMap_Area(*args)

    def MinResolution(*args):
        """MinResolution(self) -> uint32_t"""
        return _stomp.BaseMap_MinResolution(*args)

    def MaxResolution(*args):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.BaseMap_MaxResolution(*args)

    def MinLevel(*args):
        """MinLevel(self) -> uint8_t"""
        return _stomp.BaseMap_MinLevel(*args)

    def MaxLevel(*args):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.BaseMap_MaxLevel(*args)

    def InitializeRegions(*args):
        """
        InitializeRegions(self, uint16_t n_regions, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(self, uint16_t n_regions) -> uint16_t
        InitializeRegions(self, RegionBoundVector region_bounds, uint16_t n_region, 
            uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(self, RegionBoundVector region_bounds, uint16_t n_region) -> uint16_t
        InitializeRegions(self, BaseMap base_map) -> bool
        """
        return _stomp.BaseMap_InitializeRegions(*args)

    def FindRegion(*args):
        """
        FindRegion(self, AngularCoordinate ang) -> int16_t
        FindRegion(self, Pixel pix) -> int16_t
        """
        return _stomp.BaseMap_FindRegion(*args)

    def ClearRegions(*args):
        """ClearRegions(self)"""
        return _stomp.BaseMap_ClearRegions(*args)

    def Region(*args):
        """Region(self, uint32_t region_idx) -> int16_t"""
        return _stomp.BaseMap_Region(*args)

    def RegionArea(*args):
        """
        RegionArea(self, int16_t region, PixelVector pix)
        RegionArea(self, int16_t region) -> double
        """
        return _stomp.BaseMap_RegionArea(*args)

    def NRegion(*args):
        """NRegion(self) -> uint16_t"""
        return _stomp.BaseMap_NRegion(*args)

    def RegionResolution(*args):
        """RegionResolution(self) -> uint32_t"""
        return _stomp.BaseMap_RegionResolution(*args)

    def RegionsInitialized(*args):
        """RegionsInitialized(self) -> bool"""
        return _stomp.BaseMap_RegionsInitialized(*args)

    def RegionBegin(*args):
        """RegionBegin(self) -> RegionIterator"""
        return _stomp.BaseMap_RegionBegin(*args)

    def RegionEnd(*args):
        """RegionEnd(self) -> RegionIterator"""
        return _stomp.BaseMap_RegionEnd(*args)

BaseMap_swigregister = _stomp.BaseMap_swigregister
BaseMap_swigregister(BaseMap)

class SubMap(_object):
    """Proxy of C++ SubMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SubMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, uint32_t superpixnum) -> SubMap"""
        this = _stomp.new_SubMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_SubMap
    __del__ = lambda self : None;
    def AddPixel(*args):
        """AddPixel(self, Pixel pix)"""
        return _stomp.SubMap_AddPixel(*args)

    def Resolve(*args):
        """
        Resolve(self, bool force_resolve=False)
        Resolve(self)
        """
        return _stomp.SubMap_Resolve(*args)

    def SetMinimumWeight(*args):
        """SetMinimumWeight(self, double minimum_weight)"""
        return _stomp.SubMap_SetMinimumWeight(*args)

    def SetMaximumWeight(*args):
        """SetMaximumWeight(self, double maximum_weight)"""
        return _stomp.SubMap_SetMaximumWeight(*args)

    def SetMaximumResolution(*args):
        """SetMaximumResolution(self, uint32_t maximum_resolution, bool average_weights)"""
        return _stomp.SubMap_SetMaximumResolution(*args)

    def FindLocation(*args):
        """FindLocation(self, AngularCoordinate ang, double weight) -> bool"""
        return _stomp.SubMap_FindLocation(*args)

    def FindUnmaskedFraction(*args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.SubMap_FindUnmaskedFraction(*args)

    def FindUnmaskedStatus(*args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.SubMap_FindUnmaskedStatus(*args)

    def FindAverageWeight(*args):
        """FindAverageWeight(self, Pixel pix) -> double"""
        return _stomp.SubMap_FindAverageWeight(*args)

    def FindMatchingPixels(*args):
        """
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix, bool use_local_weights=False)
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix)
        """
        return _stomp.SubMap_FindMatchingPixels(*args)

    def AverageWeight(*args):
        """AverageWeight(self) -> double"""
        return _stomp.SubMap_AverageWeight(*args)

    def Soften(*args):
        """
        Soften(self, PixelVector softened_pix, uint32_t maximum_resolution, 
            bool average_weights)
        """
        return _stomp.SubMap_Soften(*args)

    def Add(*args):
        """Add(self, Map stomp_map, bool drop_single) -> bool"""
        return _stomp.SubMap_Add(*args)

    def Multiply(*args):
        """Multiply(self, Map stomp_map, bool drop_single) -> bool"""
        return _stomp.SubMap_Multiply(*args)

    def Exclude(*args):
        """Exclude(self, Map stomp_map) -> bool"""
        return _stomp.SubMap_Exclude(*args)

    def ScaleWeight(*args):
        """ScaleWeight(self, double weight_scale)"""
        return _stomp.SubMap_ScaleWeight(*args)

    def AddConstantWeight(*args):
        """AddConstantWeight(self, double add_weight)"""
        return _stomp.SubMap_AddConstantWeight(*args)

    def InvertWeight(*args):
        """InvertWeight(self)"""
        return _stomp.SubMap_InvertWeight(*args)

    def Pixels(*args):
        """Pixels(self, PixelVector pix)"""
        return _stomp.SubMap_Pixels(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.SubMap_Clear(*args)

    def Superpixnum(*args):
        """Superpixnum(self) -> uint32_t"""
        return _stomp.SubMap_Superpixnum(*args)

    def Begin(*args):
        """Begin(self) -> PixelIterator"""
        return _stomp.SubMap_Begin(*args)

    def End(*args):
        """End(self) -> PixelIterator"""
        return _stomp.SubMap_End(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.SubMap_Area(*args)

    def Initialized(*args):
        """Initialized(self) -> bool"""
        return _stomp.SubMap_Initialized(*args)

    def Unsorted(*args):
        """Unsorted(self) -> bool"""
        return _stomp.SubMap_Unsorted(*args)

    def SetUnsorted(*args):
        """SetUnsorted(self)"""
        return _stomp.SubMap_SetUnsorted(*args)

    def MinResolution(*args):
        """MinResolution(self) -> uint32_t"""
        return _stomp.SubMap_MinResolution(*args)

    def MaxResolution(*args):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.SubMap_MaxResolution(*args)

    def MinLevel(*args):
        """MinLevel(self) -> uint8_t"""
        return _stomp.SubMap_MinLevel(*args)

    def MaxLevel(*args):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.SubMap_MaxLevel(*args)

    def MinWeight(*args):
        """MinWeight(self) -> double"""
        return _stomp.SubMap_MinWeight(*args)

    def MaxWeight(*args):
        """MaxWeight(self) -> double"""
        return _stomp.SubMap_MaxWeight(*args)

    def LambdaMin(*args):
        """LambdaMin(self) -> double"""
        return _stomp.SubMap_LambdaMin(*args)

    def LambdaMax(*args):
        """LambdaMax(self) -> double"""
        return _stomp.SubMap_LambdaMax(*args)

    def EtaMin(*args):
        """EtaMin(self) -> double"""
        return _stomp.SubMap_EtaMin(*args)

    def EtaMax(*args):
        """EtaMax(self) -> double"""
        return _stomp.SubMap_EtaMax(*args)

    def ZMin(*args):
        """ZMin(self) -> double"""
        return _stomp.SubMap_ZMin(*args)

    def ZMax(*args):
        """ZMax(self) -> double"""
        return _stomp.SubMap_ZMax(*args)

    def Size(*args):
        """Size(self) -> uint32_t"""
        return _stomp.SubMap_Size(*args)

    def PixelCount(*args):
        """PixelCount(self, uint32_t resolution) -> uint32_t"""
        return _stomp.SubMap_PixelCount(*args)

SubMap_swigregister = _stomp.SubMap_swigregister
SubMap_swigregister(SubMap)

class Map(BaseMap):
    """Proxy of C++ Map class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Map, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Map, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Map
        __init__(self, PixelVector pix, bool force_resolve=True) -> Map
        __init__(self, PixelVector pix) -> Map
        __init__(self, string InputFile, bool hpixel_format=True, bool weighted_map=True) -> Map
        __init__(self, string InputFile, bool hpixel_format=True) -> Map
        __init__(self, string InputFile) -> Map
        __init__(self, GeometricBound bound, double weight=1.0, uint32_t maximum_resolution=MaxPixelResolution, 
            bool verbose=False) -> Map
        __init__(self, GeometricBound bound, double weight=1.0, uint32_t maximum_resolution=MaxPixelResolution) -> Map
        __init__(self, GeometricBound bound, double weight=1.0) -> Map
        __init__(self, GeometricBound bound) -> Map
        """
        this = _stomp.new_Map(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Map
    __del__ = lambda self : None;
    def Initialize(*args):
        """
        Initialize(self) -> bool
        Initialize(self, PixelVector pix, bool force_resolve=True) -> bool
        Initialize(self, PixelVector pix) -> bool
        """
        return _stomp.Map_Initialize(*args)

    def AddPixel(*args):
        """AddPixel(self, Pixel pix)"""
        return _stomp.Map_AddPixel(*args)

    def FindLocation(*args):
        """FindLocation(self, AngularCoordinate ang, double weight) -> bool"""
        return _stomp.Map_FindLocation(*args)

    def FindLocationWeight(*args):
        """FindLocationWeight(self, AngularCoordinate ang) -> double"""
        return _stomp.Map_FindLocationWeight(*args)

    def FindUnmaskedStatus(*args):
        """
        FindUnmaskedStatus(self, Pixel pix) -> int8_t
        FindUnmaskedStatus(self, PixelVector pix, std::vector<(int8_t,std::allocator<(int8_t)>)> unmasked_status)
        FindUnmaskedStatus(self, Map stomp_map) -> int8_t
        """
        return _stomp.Map_FindUnmaskedStatus(*args)

    def FindAverageWeight(*args):
        """
        FindAverageWeight(self, Pixel pix) -> double
        FindAverageWeight(self, PixelVector pix, DoubleVector average_weight)
        FindAverageWeight(self, PixelVector pix)
        """
        return _stomp.Map_FindAverageWeight(*args)

    def AverageWeight(*args):
        """AverageWeight(self) -> double"""
        return _stomp.Map_AverageWeight(*args)

    def FindMatchingPixels(*args):
        """
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix, bool use_local_weights=False)
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix)
        FindMatchingPixels(self, PixelVector pix, PixelVector match_pix, bool use_local_weights=False)
        FindMatchingPixels(self, PixelVector pix, PixelVector match_pix)
        """
        return _stomp.Map_FindMatchingPixels(*args)

    def Coverage(*args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution, 
            bool calculate_fraction=True)
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.Map_Coverage(*args)

    def Covering(*args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.Map_Covering(*args)

    def Soften(*args):
        """
        Soften(self, Map stomp_map, uint32_t maximum_resolution, bool average_weights=False)
        Soften(self, Map stomp_map, uint32_t maximum_resolution)
        Soften(self, uint32_t maximum_resolution, bool average_weights=False)
        Soften(self, uint32_t maximum_resolution)
        """
        return _stomp.Map_Soften(*args)

    def SetMinimumWeight(*args):
        """SetMinimumWeight(self, double min_weight)"""
        return _stomp.Map_SetMinimumWeight(*args)

    def SetMaximumWeight(*args):
        """SetMaximumWeight(self, double max_weight)"""
        return _stomp.Map_SetMaximumWeight(*args)

    def RegionOnlyMap(*args):
        """RegionOnlyMap(self, int16_t region_index, Map stomp_map) -> bool"""
        return _stomp.Map_RegionOnlyMap(*args)

    def RegionExcludedMap(*args):
        """RegionExcludedMap(self, int16_t region_index, Map stomp_map) -> bool"""
        return _stomp.Map_RegionExcludedMap(*args)

    def GenerateSingleRandomPoint(*args):
        """
        GenerateSingleRandomPoint(self, WeightedAngularCoordinate ang, bool return_local_weight=False, 
            bool use_weighted_sampling=False)
        GenerateSingleRandomPoint(self, WeightedAngularCoordinate ang, bool return_local_weight=False)
        GenerateSingleRandomPoint(self, WeightedAngularCoordinate ang)
        """
        return _stomp.Map_GenerateSingleRandomPoint(*args)

    def GenerateRandomPoints(*args):
        """
        GenerateRandomPoints(self, AngularVector ang, uint32_t n_point=1, bool use_weighted_sampling=False)
        GenerateRandomPoints(self, AngularVector ang, uint32_t n_point=1)
        GenerateRandomPoints(self, AngularVector ang)
        GenerateRandomPoints(self, WAngularVector ang, WAngularVector input_ang, bool use_weighted_sampling=False)
        GenerateRandomPoints(self, WAngularVector ang, WAngularVector input_ang)
        GenerateRandomPoints(self, WAngularVector ang, DoubleVector weights, bool use_weighted_sampling=False)
        GenerateRandomPoints(self, WAngularVector ang, DoubleVector weights)
        GenerateRandomPoints(self, uint32_t n_point, Sphere systemid, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomPoints(self, uint32_t n_point, Sphere systemid) -> PyObject
        GenerateRandomPoints(self, uint32_t n_point, string system, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomPoints(self, uint32_t n_point, string system) -> PyObject
        """
        return _stomp.Map_GenerateRandomPoints(*args)

    def GenerateRandomEq(*args):
        """
        GenerateRandomEq(self, uint32_t n_point, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomEq(self, uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomEq(*args)

    def GenerateRandomSurvey(*args):
        """
        GenerateRandomSurvey(self, uint32_t n_point, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomSurvey(self, uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomSurvey(*args)

    def GenerateRandomGal(*args):
        """
        GenerateRandomGal(self, uint32_t n_point, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomGal(self, uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomGal(*args)

    __swig_setmethods__["INSIDE_MAP"] = _stomp.Map_INSIDE_MAP_set
    __swig_getmethods__["INSIDE_MAP"] = _stomp.Map_INSIDE_MAP_get
    if _newclass:INSIDE_MAP = _swig_property(_stomp.Map_INSIDE_MAP_get, _stomp.Map_INSIDE_MAP_set)
    __swig_setmethods__["FIRST_QUADRANT_OK"] = _stomp.Map_FIRST_QUADRANT_OK_set
    __swig_getmethods__["FIRST_QUADRANT_OK"] = _stomp.Map_FIRST_QUADRANT_OK_get
    if _newclass:FIRST_QUADRANT_OK = _swig_property(_stomp.Map_FIRST_QUADRANT_OK_get, _stomp.Map_FIRST_QUADRANT_OK_set)
    __swig_setmethods__["SECOND_QUADRANT_OK"] = _stomp.Map_SECOND_QUADRANT_OK_set
    __swig_getmethods__["SECOND_QUADRANT_OK"] = _stomp.Map_SECOND_QUADRANT_OK_get
    if _newclass:SECOND_QUADRANT_OK = _swig_property(_stomp.Map_SECOND_QUADRANT_OK_get, _stomp.Map_SECOND_QUADRANT_OK_set)
    __swig_setmethods__["THIRD_QUADRANT_OK"] = _stomp.Map_THIRD_QUADRANT_OK_set
    __swig_getmethods__["THIRD_QUADRANT_OK"] = _stomp.Map_THIRD_QUADRANT_OK_get
    if _newclass:THIRD_QUADRANT_OK = _swig_property(_stomp.Map_THIRD_QUADRANT_OK_get, _stomp.Map_THIRD_QUADRANT_OK_set)
    __swig_setmethods__["FOURTH_QUADRANT_OK"] = _stomp.Map_FOURTH_QUADRANT_OK_set
    __swig_getmethods__["FOURTH_QUADRANT_OK"] = _stomp.Map_FOURTH_QUADRANT_OK_get
    if _newclass:FOURTH_QUADRANT_OK = _swig_property(_stomp.Map_FOURTH_QUADRANT_OK_get, _stomp.Map_FOURTH_QUADRANT_OK_set)
    def QuadrantsContainedMC(*args):
        """QuadrantsContainedMC(self, AngularCoordinate ang, double radius, Sphere coord_system) -> int"""
        return _stomp.Map_QuadrantsContainedMC(*args)

    def QuadrantContainedMC(*args):
        """QuadrantContainedMC(self, AngularCoordinate ang, double radius, int quadrant) -> bool"""
        return _stomp.Map_QuadrantContainedMC(*args)

    def Contains(*args):
        """
        Contains(self, AngularCoordinate ang) -> bool
        Contains(self, Pixel pix) -> bool
        Contains(self, Map stomp_map) -> bool
        Contains(self, PyObject x1obj, PyObject x2obj, string system, PyObject radobj=None) -> PyObject
        Contains(self, PyObject x1obj, PyObject x2obj, string system) -> PyObject
        Contains(self, GeometricBound bound, double area_resolution=0.5, double precision=0.01) -> bool
        Contains(self, GeometricBound bound, double area_resolution=0.5) -> bool
        Contains(self, GeometricBound bound) -> bool
        """
        return _stomp.Map_Contains(*args)

    def FindUnmaskedFraction(*args):
        """
        FindUnmaskedFraction(self, Pixel pix) -> double
        FindUnmaskedFraction(self, PixelVector pix, DoubleVector unmasked_fraction)
        FindUnmaskedFraction(self, PixelVector pix)
        FindUnmaskedFraction(self, Map stomp_map) -> double
        FindUnmaskedFraction(self, GeometricBound bound, double area_resolution=0.5, double precision=0.01) -> double
        FindUnmaskedFraction(self, GeometricBound bound, double area_resolution=0.5) -> double
        FindUnmaskedFraction(self, GeometricBound bound) -> double
        """
        return _stomp.Map_FindUnmaskedFraction(*args)

    def Write(*args):
        """
        Write(self, string OutputFile, bool hpixel_format=True, bool weighted_map=True) -> bool
        Write(self, string OutputFile, bool hpixel_format=True) -> bool
        Write(self, string OutputFile) -> bool
        """
        return _stomp.Map_Write(*args)

    def Read(*args):
        """
        Read(self, string InputFile, bool hpixel_format=True, bool weighted_map=True) -> bool
        Read(self, string InputFile, bool hpixel_format=True) -> bool
        Read(self, string InputFile) -> bool
        """
        return _stomp.Map_Read(*args)

    def PixelizeBound(*args):
        """
        PixelizeBound(self, GeometricBound bound, double weight=1.0, uint32_t maximum_resolution=MaxPixelResolution) -> bool
        PixelizeBound(self, GeometricBound bound, double weight=1.0) -> bool
        PixelizeBound(self, GeometricBound bound) -> bool
        """
        return _stomp.Map_PixelizeBound(*args)

    def _FindStartingResolutionLevel(*args):
        """_FindStartingResolutionLevel(self, double bound_area) -> uint8_t"""
        return _stomp.Map__FindStartingResolutionLevel(*args)

    def _FindXYBounds(*args):
        """
        _FindXYBounds(self, uint8_t resolution_level, GeometricBound bound, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, 
            uint32_t y_max) -> bool
        """
        return _stomp.Map__FindXYBounds(*args)

    def ScaleWeight(*args):
        """ScaleWeight(self, double weight_scale)"""
        return _stomp.Map_ScaleWeight(*args)

    def AddConstantWeight(*args):
        """AddConstantWeight(self, double add_weight)"""
        return _stomp.Map_AddConstantWeight(*args)

    def InvertWeight(*args):
        """InvertWeight(self)"""
        return _stomp.Map_InvertWeight(*args)

    def IngestMap(*args):
        """
        IngestMap(self, PixelVector pix, bool destroy_copy=True) -> bool
        IngestMap(self, PixelVector pix) -> bool
        IngestMap(self, Map stomp_map, bool destroy_copy=True) -> bool
        IngestMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_IngestMap(*args)

    def IntersectMap(*args):
        """
        IntersectMap(self, PixelVector pix) -> bool
        IntersectMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_IntersectMap(*args)

    def ExcludeMap(*args):
        """
        ExcludeMap(self, PixelVector pix, bool destroy_copy=True) -> bool
        ExcludeMap(self, PixelVector pix) -> bool
        ExcludeMap(self, Map stomp_map, bool destroy_copy=True) -> bool
        ExcludeMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_ExcludeMap(*args)

    def AddMap(*args):
        """
        AddMap(self, PixelVector pix, bool drop_single=True) -> bool
        AddMap(self, PixelVector pix) -> bool
        AddMap(self, Map stomp_map, bool drop_single=True) -> bool
        AddMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_AddMap(*args)

    def MultiplyMap(*args):
        """
        MultiplyMap(self, PixelVector pix, bool drop_single=True) -> bool
        MultiplyMap(self, PixelVector pix) -> bool
        MultiplyMap(self, Map stomp_map, bool drop_single=True) -> bool
        MultiplyMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_MultiplyMap(*args)

    def ImprintMap(*args):
        """
        ImprintMap(self, PixelVector pix) -> bool
        ImprintMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_ImprintMap(*args)

    def Pixels(*args):
        """
        Pixels(self, PixelVector pix, uint32_t superpixnum=MaxSuperpixnum)
        Pixels(self, PixelVector pix)
        """
        return _stomp.Map_Pixels(*args)

    def Begin(*args):
        """Begin(self) -> MapIterator"""
        return _stomp.Map_Begin(*args)

    def End(*args):
        """End(self) -> MapIterator"""
        return _stomp.Map_End(*args)

    def Iterate(*args):
        """Iterate(self, MapIterator iter)"""
        return _stomp.Map_Iterate(*args)

    def Clear(*args):
        """
        Clear(self)
        Clear(self, uint32_t superpixnum)
        """
        return _stomp.Map_Clear(*args)

    def ContainsSuperpixel(*args):
        """ContainsSuperpixel(self, uint32_t superpixnum) -> bool"""
        return _stomp.Map_ContainsSuperpixel(*args)

    def Area(*args):
        """
        Area(self) -> double
        Area(self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_Area(*args)

    def MinResolution(*args):
        """
        MinResolution(self) -> uint32_t
        MinResolution(self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_MinResolution(*args)

    def MaxResolution(*args):
        """
        MaxResolution(self) -> uint32_t
        MaxResolution(self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_MaxResolution(*args)

    def MinLevel(*args):
        """
        MinLevel(self) -> uint8_t
        MinLevel(self, uint32_t superpixnum) -> uint8_t
        """
        return _stomp.Map_MinLevel(*args)

    def MaxLevel(*args):
        """
        MaxLevel(self) -> uint8_t
        MaxLevel(self, uint32_t superpixnum) -> uint8_t
        """
        return _stomp.Map_MaxLevel(*args)

    def MinWeight(*args):
        """
        MinWeight(self) -> double
        MinWeight(self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_MinWeight(*args)

    def MaxWeight(*args):
        """
        MaxWeight(self) -> double
        MaxWeight(self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_MaxWeight(*args)

    def Size(*args):
        """
        Size(self) -> uint32_t
        Size(self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_Size(*args)

    def Empty(*args):
        """Empty(self) -> bool"""
        return _stomp.Map_Empty(*args)

    def PixelCount(*args):
        """PixelCount(self, uint32_t resolution) -> uint32_t"""
        return _stomp.Map_PixelCount(*args)

Map_swigregister = _stomp.Map_swigregister
Map_swigregister(Map)

class ScalarMap(BaseMap):
    """Proxy of C++ ScalarMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarMap, name)
    __repr__ = _swig_repr
    ScalarField = _stomp.ScalarMap_ScalarField
    DensityField = _stomp.ScalarMap_DensityField
    SampledField = _stomp.ScalarMap_SampledField
    def __init__(self, *args): 
        """
        __init__(self) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution, ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001, 
            bool use_map_weight_as_intensity=False) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution, ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution, ScalarMapType scalar_map_type=ScalarField) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution) -> ScalarMap
        __init__(self, ScalarMap scalar_map, uint32_t resolution, double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(self, ScalarMap scalar_map, uint32_t resolution) -> ScalarMap
        __init__(self, ScalarVector pix, ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(self, ScalarVector pix, ScalarMapType scalar_map_type=ScalarField) -> ScalarMap
        __init__(self, ScalarVector pix) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution, ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001, 
            double theta_min=-1.0) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution, ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution, ScalarMapType scalar_map_type=ScalarField) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution) -> ScalarMap
        """
        this = _stomp.new_ScalarMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_ScalarMap
    __del__ = lambda self : None;
    def SetResolution(*args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.ScalarMap_SetResolution(*args)

    def InitializeFromMap(*args):
        """
        InitializeFromMap(self, Map stomp_map, uint32_t resolution=0, bool use_map_weight_as_intensity=False)
        InitializeFromMap(self, Map stomp_map, uint32_t resolution=0)
        InitializeFromMap(self, Map stomp_map)
        """
        return _stomp.ScalarMap_InitializeFromMap(*args)

    def InitializeFromScalarMap(*args):
        """
        InitializeFromScalarMap(self, ScalarMap scalar_map, uint32_t resolution=0)
        InitializeFromScalarMap(self, ScalarMap scalar_map)
        """
        return _stomp.ScalarMap_InitializeFromScalarMap(*args)

    def InitializeFromScalarPixels(*args):
        """
        InitializeFromScalarPixels(self, ScalarVector pix, ScalarMapType map_type=ScalarField)
        InitializeFromScalarPixels(self, ScalarVector pix)
        """
        return _stomp.ScalarMap_InitializeFromScalarPixels(*args)

    def AddToMap(*args):
        """
        AddToMap(self, AngularCoordinate ang, double object_weight=1.0) -> bool
        AddToMap(self, AngularCoordinate ang) -> bool
        AddToMap(self, WeightedAngularCoordinate ang) -> bool
        AddToMap(self, Pixel pix) -> bool
        """
        return _stomp.ScalarMap_AddToMap(*args)

    def Coverage(*args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution, 
            bool calculate_fraction=True)
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.ScalarMap_Coverage(*args)

    def Covering(*args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.ScalarMap_Covering(*args)

    def FindUnmaskedFraction(*args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindUnmaskedFraction(*args)

    def FindUnmaskedStatus(*args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.ScalarMap_FindUnmaskedStatus(*args)

    def Resample(*args):
        """Resample(self, ScalarPixel pix)"""
        return _stomp.ScalarMap_Resample(*args)

    def FindIntensity(*args):
        """FindIntensity(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindIntensity(*args)

    def FindDensity(*args):
        """FindDensity(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindDensity(*args)

    def FindPointDensity(*args):
        """FindPointDensity(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindPointDensity(*args)

    def FindLocalArea(*args):
        """
        FindLocalArea(self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalArea(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalArea(*args)

    def FindLocalIntensity(*args):
        """
        FindLocalIntensity(self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalIntensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalIntensity(*args)

    def FindLocalDensity(*args):
        """
        FindLocalDensity(self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalDensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalDensity(*args)

    def FindLocalPointDensity(*args):
        """
        FindLocalPointDensity(self, AngularCoordinate ang, double theta_max, double theta_min=0.0) -> double
        FindLocalPointDensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalPointDensity(*args)

    def CalculateMeanIntensity(*args):
        """CalculateMeanIntensity(self)"""
        return _stomp.ScalarMap_CalculateMeanIntensity(*args)

    def ConvertToOverDensity(*args):
        """ConvertToOverDensity(self)"""
        return _stomp.ScalarMap_ConvertToOverDensity(*args)

    def ConvertFromOverDensity(*args):
        """ConvertFromOverDensity(self)"""
        return _stomp.ScalarMap_ConvertFromOverDensity(*args)

    def UseLocalMeanIntensity(*args):
        """UseLocalMeanIntensity(self, bool use_local_mean) -> bool"""
        return _stomp.ScalarMap_UseLocalMeanIntensity(*args)

    def UsingLocalMeanIntensity(*args):
        """UsingLocalMeanIntensity(self) -> bool"""
        return _stomp.ScalarMap_UsingLocalMeanIntensity(*args)

    def ImprintMap(*args):
        """
        ImprintMap(self, Map stomp_map, bool use_mean_local_intensity=False) -> bool
        ImprintMap(self, Map stomp_map) -> bool
        """
        return _stomp.ScalarMap_ImprintMap(*args)

    def AutoCorrelate(*args):
        """
        AutoCorrelate(self, ThetaIterator theta_iter)
        AutoCorrelate(self, AngularCorrelation wtheta)
        """
        return _stomp.ScalarMap_AutoCorrelate(*args)

    def AutoCorrelateWithRegions(*args):
        """
        AutoCorrelateWithRegions(self, AngularCorrelation wtheta)
        AutoCorrelateWithRegions(self, ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_AutoCorrelateWithRegions(*args)

    def CrossCorrelate(*args):
        """
        CrossCorrelate(self, ScalarMap scalar_map, AngularCorrelation wtheta)
        CrossCorrelate(self, ScalarMap scalar_map, ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_CrossCorrelate(*args)

    def CrossCorrelateWithRegions(*args):
        """
        CrossCorrelateWithRegions(self, ScalarMap scalar_map, AngularCorrelation wtheta)
        CrossCorrelateWithRegions(self, ScalarMap scalar_map, ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_CrossCorrelateWithRegions(*args)

    def Variance(*args):
        """Variance(self) -> double"""
        return _stomp.ScalarMap_Variance(*args)

    def Covariance(*args):
        """Covariance(self, ScalarMap scalar_map) -> double"""
        return _stomp.ScalarMap_Covariance(*args)

    def VarianceWithErrors(*args):
        """VarianceWithErrors(self, double variance, double variance_error)"""
        return _stomp.ScalarMap_VarianceWithErrors(*args)

    def CovarianceWithErrors(*args):
        """CovarianceWithErrors(self, ScalarMap scalar_map, double covariance, double covariance_error)"""
        return _stomp.ScalarMap_CovarianceWithErrors(*args)

    def Resolution(*args):
        """Resolution(self) -> uint32_t"""
        return _stomp.ScalarMap_Resolution(*args)

    def Intensity(*args):
        """Intensity(self) -> double"""
        return _stomp.ScalarMap_Intensity(*args)

    def NPoints(*args):
        """NPoints(self) -> int"""
        return _stomp.ScalarMap_NPoints(*args)

    def Density(*args):
        """Density(self) -> double"""
        return _stomp.ScalarMap_Density(*args)

    def PointDensity(*args):
        """PointDensity(self) -> double"""
        return _stomp.ScalarMap_PointDensity(*args)

    def Begin(*args):
        """Begin(self) -> ScalarIterator"""
        return _stomp.ScalarMap_Begin(*args)

    def End(*args):
        """End(self) -> ScalarIterator"""
        return _stomp.ScalarMap_End(*args)

    def MeanIntensity(*args):
        """MeanIntensity(self) -> double"""
        return _stomp.ScalarMap_MeanIntensity(*args)

    def IsOverDensityMap(*args):
        """IsOverDensityMap(self) -> bool"""
        return _stomp.ScalarMap_IsOverDensityMap(*args)

    def MapType(*args):
        """MapType(self) -> ScalarMapType"""
        return _stomp.ScalarMap_MapType(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.ScalarMap_Area(*args)

    def Size(*args):
        """Size(self) -> uint32_t"""
        return _stomp.ScalarMap_Size(*args)

    def MinResolution(*args):
        """MinResolution(self) -> uint32_t"""
        return _stomp.ScalarMap_MinResolution(*args)

    def MaxResolution(*args):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.ScalarMap_MaxResolution(*args)

    def MinLevel(*args):
        """MinLevel(self) -> uint8_t"""
        return _stomp.ScalarMap_MinLevel(*args)

    def MaxLevel(*args):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.ScalarMap_MaxLevel(*args)

    def Empty(*args):
        """Empty(self) -> bool"""
        return _stomp.ScalarMap_Empty(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.ScalarMap_Clear(*args)

ScalarMap_swigregister = _stomp.ScalarMap_swigregister
ScalarMap_swigregister(ScalarMap)

class GeometricBound(_object):
    """Proxy of C++ GeometricBound class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricBound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> GeometricBound"""
        this = _stomp.new_GeometricBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_GeometricBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.GeometricBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.GeometricBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.GeometricBound_FindArea(*args)

    def CheckPixel(*args):
        """CheckPixel(self, Pixel pix) -> bool"""
        return _stomp.GeometricBound_CheckPixel(*args)

    def ScorePixel(*args):
        """ScorePixel(self, Pixel pix) -> double"""
        return _stomp.GeometricBound_ScorePixel(*args)

    def SetArea(*args):
        """SetArea(self, double input_area)"""
        return _stomp.GeometricBound_SetArea(*args)

    def SetAngularBounds(*args):
        """SetAngularBounds(self, double lammin, double lammax, double etamin, double etamax)"""
        return _stomp.GeometricBound_SetAngularBounds(*args)

    def SetContinuousBounds(*args):
        """SetContinuousBounds(self, bool continuous_bounds)"""
        return _stomp.GeometricBound_SetContinuousBounds(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.GeometricBound_Area(*args)

    def LambdaMin(*args):
        """LambdaMin(self) -> double"""
        return _stomp.GeometricBound_LambdaMin(*args)

    def LambdaMax(*args):
        """LambdaMax(self) -> double"""
        return _stomp.GeometricBound_LambdaMax(*args)

    def EtaMin(*args):
        """EtaMin(self) -> double"""
        return _stomp.GeometricBound_EtaMin(*args)

    def EtaMax(*args):
        """EtaMax(self) -> double"""
        return _stomp.GeometricBound_EtaMax(*args)

    def ContinuousBounds(*args):
        """ContinuousBounds(self) -> bool"""
        return _stomp.GeometricBound_ContinuousBounds(*args)

    def GenerateRandomPoint(*args):
        """GenerateRandomPoint(self, AngularCoordinate ang)"""
        return _stomp.GeometricBound_GenerateRandomPoint(*args)

    def GenerateRandomPoints(*args):
        """GenerateRandomPoints(self, AngularVector angVec, uint32_t n_rand)"""
        return _stomp.GeometricBound_GenerateRandomPoints(*args)

GeometricBound_swigregister = _stomp.GeometricBound_swigregister
GeometricBound_swigregister(GeometricBound)

class CircleBound(GeometricBound):
    """Proxy of C++ CircleBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircleBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircleBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, AngularCoordinate center_point, double radius) -> CircleBound"""
        this = _stomp.new_CircleBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_CircleBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.CircleBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.CircleBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.CircleBound_FindArea(*args)

CircleBound_swigregister = _stomp.CircleBound_swigregister
CircleBound_swigregister(CircleBound)

class AnnulusBound(GeometricBound):
    """Proxy of C++ AnnulusBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnulusBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AnnulusBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate center_point, double min_radius, 
            double max_radius) -> AnnulusBound
        __init__(self, AngularCoordinate center_point, AngularBin angular_bin) -> AnnulusBound
        """
        this = _stomp.new_AnnulusBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AnnulusBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.AnnulusBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.AnnulusBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.AnnulusBound_FindArea(*args)

AnnulusBound_swigregister = _stomp.AnnulusBound_swigregister
AnnulusBound_swigregister(AnnulusBound)

class WedgeBound(GeometricBound):
    """Proxy of C++ WedgeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WedgeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WedgeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate center_point, double radius, double position_angle_min, 
            double position_angle_max, 
            Sphere sphere=Survey) -> WedgeBound
        __init__(self, AngularCoordinate center_point, double radius, double position_angle_min, 
            double position_angle_max) -> WedgeBound
        """
        this = _stomp.new_WedgeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_WedgeBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.WedgeBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.WedgeBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.WedgeBound_FindArea(*args)

WedgeBound_swigregister = _stomp.WedgeBound_swigregister
WedgeBound_swigregister(WedgeBound)

class PolygonBound(GeometricBound):
    """Proxy of C++ PolygonBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, AngularVector ang) -> PolygonBound"""
        this = _stomp.new_PolygonBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_PolygonBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.PolygonBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.PolygonBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.PolygonBound_FindArea(*args)

PolygonBound_swigregister = _stomp.PolygonBound_swigregister
PolygonBound_swigregister(PolygonBound)

class LongitudeBound(GeometricBound):
    """Proxy of C++ LongitudeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongitudeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongitudeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double min_longitude, double max_longitude, Sphere sphere) -> LongitudeBound"""
        this = _stomp.new_LongitudeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LongitudeBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.LongitudeBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.LongitudeBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.LongitudeBound_FindArea(*args)

    def LongitudeMin(*args):
        """LongitudeMin(self) -> double"""
        return _stomp.LongitudeBound_LongitudeMin(*args)

    def LongitudeMax(*args):
        """LongitudeMax(self) -> double"""
        return _stomp.LongitudeBound_LongitudeMax(*args)

    def Sphere(*args):
        """Sphere(self) -> Sphere"""
        return _stomp.LongitudeBound_Sphere(*args)

LongitudeBound_swigregister = _stomp.LongitudeBound_swigregister
LongitudeBound_swigregister(LongitudeBound)

class LatitudeBound(GeometricBound):
    """Proxy of C++ LatitudeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatitudeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatitudeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double min_latitude, double max_latitude, Sphere sphere) -> LatitudeBound"""
        this = _stomp.new_LatitudeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LatitudeBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.LatitudeBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.LatitudeBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.LatitudeBound_FindArea(*args)

    def LatitudeMin(*args):
        """LatitudeMin(self) -> double"""
        return _stomp.LatitudeBound_LatitudeMin(*args)

    def LatitudeMax(*args):
        """LatitudeMax(self) -> double"""
        return _stomp.LatitudeBound_LatitudeMax(*args)

    def Sphere(*args):
        """Sphere(self) -> Sphere"""
        return _stomp.LatitudeBound_Sphere(*args)

LatitudeBound_swigregister = _stomp.LatitudeBound_swigregister
LatitudeBound_swigregister(LatitudeBound)

class LatLonBound(GeometricBound):
    """Proxy of C++ LatLonBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatLonBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatLonBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double min_latitude, double max_latitude, double min_longitude, 
            double max_longitude, Sphere sphere) -> LatLonBound
        """
        this = _stomp.new_LatLonBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LatLonBound
    __del__ = lambda self : None;
    def CheckPoint(*args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.LatLonBound_CheckPoint(*args)

    def FindAngularBounds(*args):
        """FindAngularBounds(self) -> bool"""
        return _stomp.LatLonBound_FindAngularBounds(*args)

    def FindArea(*args):
        """FindArea(self) -> bool"""
        return _stomp.LatLonBound_FindArea(*args)

    def LongitudeMin(*args):
        """LongitudeMin(self) -> double"""
        return _stomp.LatLonBound_LongitudeMin(*args)

    def LongitudeMax(*args):
        """LongitudeMax(self) -> double"""
        return _stomp.LatLonBound_LongitudeMax(*args)

    def LatitudeMin(*args):
        """LatitudeMin(self) -> double"""
        return _stomp.LatLonBound_LatitudeMin(*args)

    def LatitudeMax(*args):
        """LatitudeMax(self) -> double"""
        return _stomp.LatLonBound_LatitudeMax(*args)

    def Sphere(*args):
        """Sphere(self) -> Sphere"""
        return _stomp.LatLonBound_Sphere(*args)

LatLonBound_swigregister = _stomp.LatLonBound_swigregister
LatLonBound_swigregister(LatLonBound)

class Cosmology(_object):
    """Proxy of C++ Cosmology class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cosmology, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Cosmology, name)
    __repr__ = _swig_repr
    __swig_setmethods__["omega_m"] = _stomp.Cosmology_omega_m_set
    __swig_getmethods__["omega_m"] = _stomp.Cosmology_omega_m_get
    if _newclass:omega_m = _swig_property(_stomp.Cosmology_omega_m_get, _stomp.Cosmology_omega_m_set)
    __swig_setmethods__["h"] = _stomp.Cosmology_h_set
    __swig_getmethods__["h"] = _stomp.Cosmology_h_get
    if _newclass:h = _swig_property(_stomp.Cosmology_h_get, _stomp.Cosmology_h_set)
    __swig_setmethods__["a_"] = _stomp.Cosmology_a__set
    __swig_getmethods__["a_"] = _stomp.Cosmology_a__get
    if _newclass:a_ = _swig_property(_stomp.Cosmology_a__get, _stomp.Cosmology_a__set)
    __swig_setmethods__["b_"] = _stomp.Cosmology_b__set
    __swig_getmethods__["b_"] = _stomp.Cosmology_b__get
    if _newclass:b_ = _swig_property(_stomp.Cosmology_b__get, _stomp.Cosmology_b__set)
    def OmegaM(*args):
        """OmegaM() -> double"""
        return _stomp.Cosmology_OmegaM(*args)

    if _newclass:OmegaM = staticmethod(OmegaM)
    __swig_getmethods__["OmegaM"] = lambda x: OmegaM
    def HubbleConstant(*args):
        """HubbleConstant() -> double"""
        return _stomp.Cosmology_HubbleConstant(*args)

    if _newclass:HubbleConstant = staticmethod(HubbleConstant)
    __swig_getmethods__["HubbleConstant"] = lambda x: HubbleConstant
    def HubbleDistance(*args):
        """HubbleDistance() -> double"""
        return _stomp.Cosmology_HubbleDistance(*args)

    if _newclass:HubbleDistance = staticmethod(HubbleDistance)
    __swig_getmethods__["HubbleDistance"] = lambda x: HubbleDistance
    def OmegaL(*args):
        """OmegaL() -> double"""
        return _stomp.Cosmology_OmegaL(*args)

    if _newclass:OmegaL = staticmethod(OmegaL)
    __swig_getmethods__["OmegaL"] = lambda x: OmegaL
    def SetOmegaM(*args):
        """SetOmegaM(double omega_m)"""
        return _stomp.Cosmology_SetOmegaM(*args)

    if _newclass:SetOmegaM = staticmethod(SetOmegaM)
    __swig_getmethods__["SetOmegaM"] = lambda x: SetOmegaM
    def SetHubbleConstant(*args):
        """SetHubbleConstant(double hubble)"""
        return _stomp.Cosmology_SetHubbleConstant(*args)

    if _newclass:SetHubbleConstant = staticmethod(SetHubbleConstant)
    __swig_getmethods__["SetHubbleConstant"] = lambda x: SetHubbleConstant
    def SetOmegaL(*args):
        """SetOmegaL(double omega_lambda)"""
        return _stomp.Cosmology_SetOmegaL(*args)

    if _newclass:SetOmegaL = staticmethod(SetOmegaL)
    __swig_getmethods__["SetOmegaL"] = lambda x: SetOmegaL
    def ComovingDistance(*args):
        """ComovingDistance(double z) -> double"""
        return _stomp.Cosmology_ComovingDistance(*args)

    if _newclass:ComovingDistance = staticmethod(ComovingDistance)
    __swig_getmethods__["ComovingDistance"] = lambda x: ComovingDistance
    def AngularDiameterDistance(*args):
        """AngularDiameterDistance(double z) -> double"""
        return _stomp.Cosmology_AngularDiameterDistance(*args)

    if _newclass:AngularDiameterDistance = staticmethod(AngularDiameterDistance)
    __swig_getmethods__["AngularDiameterDistance"] = lambda x: AngularDiameterDistance
    def LuminosityDistance(*args):
        """LuminosityDistance(double z) -> double"""
        return _stomp.Cosmology_LuminosityDistance(*args)

    if _newclass:LuminosityDistance = staticmethod(LuminosityDistance)
    __swig_getmethods__["LuminosityDistance"] = lambda x: LuminosityDistance
    def ProjectedDistance(*args):
        """ProjectedDistance(double z, double theta) -> double"""
        return _stomp.Cosmology_ProjectedDistance(*args)

    if _newclass:ProjectedDistance = staticmethod(ProjectedDistance)
    __swig_getmethods__["ProjectedDistance"] = lambda x: ProjectedDistance
    def ProjectedAngle(*args):
        """ProjectedAngle(double z, double radius) -> double"""
        return _stomp.Cosmology_ProjectedAngle(*args)

    if _newclass:ProjectedAngle = staticmethod(ProjectedAngle)
    __swig_getmethods__["ProjectedAngle"] = lambda x: ProjectedAngle
    def __init__(self, *args): 
        """__init__(self) -> Cosmology"""
        this = _stomp.new_Cosmology(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Cosmology
    __del__ = lambda self : None;
Cosmology_swigregister = _stomp.Cosmology_swigregister
Cosmology_swigregister(Cosmology)
Cosmology.AA_ = _stomp.cvar.Cosmology_AA_
Cosmology.BB_ = _stomp.cvar.Cosmology_BB_

def Cosmology_OmegaM(*args):
  """Cosmology_OmegaM() -> double"""
  return _stomp.Cosmology_OmegaM(*args)

def Cosmology_HubbleConstant(*args):
  """Cosmology_HubbleConstant() -> double"""
  return _stomp.Cosmology_HubbleConstant(*args)

def Cosmology_HubbleDistance(*args):
  """Cosmology_HubbleDistance() -> double"""
  return _stomp.Cosmology_HubbleDistance(*args)

def Cosmology_OmegaL(*args):
  """Cosmology_OmegaL() -> double"""
  return _stomp.Cosmology_OmegaL(*args)

def Cosmology_SetOmegaM(*args):
  """Cosmology_SetOmegaM(double omega_m)"""
  return _stomp.Cosmology_SetOmegaM(*args)

def Cosmology_SetHubbleConstant(*args):
  """Cosmology_SetHubbleConstant(double hubble)"""
  return _stomp.Cosmology_SetHubbleConstant(*args)

def Cosmology_SetOmegaL(*args):
  """Cosmology_SetOmegaL(double omega_lambda)"""
  return _stomp.Cosmology_SetOmegaL(*args)

def Cosmology_ComovingDistance(*args):
  """Cosmology_ComovingDistance(double z) -> double"""
  return _stomp.Cosmology_ComovingDistance(*args)

def Cosmology_AngularDiameterDistance(*args):
  """Cosmology_AngularDiameterDistance(double z) -> double"""
  return _stomp.Cosmology_AngularDiameterDistance(*args)

def Cosmology_LuminosityDistance(*args):
  """Cosmology_LuminosityDistance(double z) -> double"""
  return _stomp.Cosmology_LuminosityDistance(*args)

def Cosmology_ProjectedDistance(*args):
  """Cosmology_ProjectedDistance(double z, double theta) -> double"""
  return _stomp.Cosmology_ProjectedDistance(*args)

def Cosmology_ProjectedAngle(*args):
  """Cosmology_ProjectedAngle(double z, double radius) -> double"""
  return _stomp.Cosmology_ProjectedAngle(*args)

class StompWatch(_object):
    """Proxy of C++ StompWatch class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StompWatch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StompWatch, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> StompWatch"""
        this = _stomp.new_StompWatch(*args)
        try: self.this.append(this)
        except: self.this = this
    def StartTimer(*args):
        """StartTimer(self)"""
        return _stomp.StompWatch_StartTimer(*args)

    def StopTimer(*args):
        """StopTimer(self)"""
        return _stomp.StompWatch_StopTimer(*args)

    def ElapsedTime(*args):
        """ElapsedTime(self) -> double"""
        return _stomp.StompWatch_ElapsedTime(*args)

    __swig_destroy__ = _stomp.delete_StompWatch
    __del__ = lambda self : None;
StompWatch_swigregister = _stomp.StompWatch_swigregister
StompWatch_swigregister(StompWatch)

class HistogramBin(_object):
    """Proxy of C++ HistogramBin class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HistogramBin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HistogramBin, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> HistogramBin
        __init__(self, double bin_min, double bin_max) -> HistogramBin
        """
        this = _stomp.new_HistogramBin(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_HistogramBin
    __del__ = lambda self : None;
    def SetBounds(*args):
        """SetBounds(self, double bin_min, double bin_max)"""
        return _stomp.HistogramBin_SetBounds(*args)

    def AddToBin(*args):
        """
        AddToBin(self, double bin_value, double weight=1.0) -> bool
        AddToBin(self, double bin_value) -> bool
        """
        return _stomp.HistogramBin_AddToBin(*args)

    def BinMinimum(*args):
        """BinMinimum(self) -> double"""
        return _stomp.HistogramBin_BinMinimum(*args)

    def BinMaximum(*args):
        """BinMaximum(self) -> double"""
        return _stomp.HistogramBin_BinMaximum(*args)

    def BinCenter(*args):
        """BinCenter(self) -> double"""
        return _stomp.HistogramBin_BinCenter(*args)

    def BinLogCenter(*args):
        """BinLogCenter(self) -> double"""
        return _stomp.HistogramBin_BinLogCenter(*args)

    def BinWeightedCenter(*args):
        """BinWeightedCenter(self) -> double"""
        return _stomp.HistogramBin_BinWeightedCenter(*args)

    def BinAveragedCenter(*args):
        """BinAveragedCenter(self) -> double"""
        return _stomp.HistogramBin_BinAveragedCenter(*args)

    def WithinBin(*args):
        """WithinBin(self, double bin_value) -> bool"""
        return _stomp.HistogramBin_WithinBin(*args)

    def BinWeight(*args):
        """BinWeight(self) -> double"""
        return _stomp.HistogramBin_BinWeight(*args)

    def BinItems(*args):
        """BinItems(self) -> uint32_t"""
        return _stomp.HistogramBin_BinItems(*args)

    def BinMeanWeight(*args):
        """BinMeanWeight(self) -> double"""
        return _stomp.HistogramBin_BinMeanWeight(*args)

HistogramBin_swigregister = _stomp.HistogramBin_swigregister
HistogramBin_swigregister(HistogramBin)

class Histogram(_object):
    """Proxy of C++ Histogram class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Histogram, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Histogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Histogram
        __init__(self, double hist_min, double hist_max, uint16_t n_bins, 
            bool log_binning=False) -> Histogram
        __init__(self, double hist_min, double hist_max, uint16_t n_bins) -> Histogram
        """
        this = _stomp.new_Histogram(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Histogram
    __del__ = lambda self : None;
    def SetBounds(*args):
        """SetBounds(self, double bin_min, double bin_max)"""
        return _stomp.Histogram_SetBounds(*args)

    def SetNBins(*args):
        """SetNBins(self, uint16_t n_bins)"""
        return _stomp.Histogram_SetNBins(*args)

    def SetLogBinning(*args):
        """SetLogBinning(self, bool log_binning) -> bool"""
        return _stomp.Histogram_SetLogBinning(*args)

    def AssignBins(*args):
        """AssignBins(self) -> bool"""
        return _stomp.Histogram_AssignBins(*args)

    def AddToBin(*args):
        """
        AddToBin(self, double bin_value, double weight=1.0) -> bool
        AddToBin(self, double bin_value) -> bool
        """
        return _stomp.Histogram_AddToBin(*args)

    def Begin(*args):
        """Begin(self) -> BinIterator"""
        return _stomp.Histogram_Begin(*args)

    def End(*args):
        """End(self) -> BinIterator"""
        return _stomp.Histogram_End(*args)

    def BoundMin(*args):
        """BoundMin(self) -> double"""
        return _stomp.Histogram_BoundMin(*args)

    def BoundMax(*args):
        """BoundMax(self) -> double"""
        return _stomp.Histogram_BoundMax(*args)

    def NBins(*args):
        """NBins(self) -> uint16_t"""
        return _stomp.Histogram_NBins(*args)

    def LogBinning(*args):
        """LogBinning(self) -> bool"""
        return _stomp.Histogram_LogBinning(*args)

    def TotalItems(*args):
        """TotalItems(self) -> uint32_t"""
        return _stomp.Histogram_TotalItems(*args)

    def TotalWeight(*args):
        """TotalWeight(self) -> double"""
        return _stomp.Histogram_TotalWeight(*args)

    def MeanItemWeight(*args):
        """MeanItemWeight(self) -> double"""
        return _stomp.Histogram_MeanItemWeight(*args)

    def MeanBinValue(*args):
        """MeanBinValue(self) -> double"""
        return _stomp.Histogram_MeanBinValue(*args)

    def MeanWeightedBinValue(*args):
        """MeanWeightedBinValue(self) -> double"""
        return _stomp.Histogram_MeanWeightedBinValue(*args)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(*args):
        """_begin_Bins(self) -> std::vector<(Stomp::HistogramBin,std::allocator<(Stomp::HistogramBin)>)>::const_iterator"""
        return _stomp.Histogram__begin_Bins(*args)

    def _deref_Bins(*args):
        """_deref_Bins(self, std::vector<(Stomp::HistogramBin,std::allocator<(Stomp::HistogramBin)>)>::const_iterator iter) -> HistogramBin"""
        return _stomp.Histogram__deref_Bins(*args)

Histogram_swigregister = _stomp.Histogram_swigregister
Histogram_swigregister(Histogram)


def Tokenize(*args):
  """
    Tokenize(string str, std::vector<(std::string,std::allocator<(std::string)>)> tokens, 
        string delimiters)
    """
  return _stomp.Tokenize(*args)
class AngularCoordinate(_object):
    """Proxy of C++ AngularCoordinate class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularCoordinate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularCoordinate, name)
    __repr__ = _swig_repr
    Survey = _stomp.AngularCoordinate_Survey
    Equatorial = _stomp.AngularCoordinate_Equatorial
    Galactic = _stomp.AngularCoordinate_Galactic
    def __init__(self, *args): 
        """
        __init__(self, double theta=0.0, double phi=0.0, Sphere sphere=Survey, 
            bool radians=False) -> AngularCoordinate
        __init__(self, double theta=0.0, double phi=0.0, Sphere sphere=Survey) -> AngularCoordinate
        __init__(self, double theta=0.0, double phi=0.0) -> AngularCoordinate
        __init__(self, double theta=0.0) -> AngularCoordinate
        __init__(self) -> AngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z) -> AngularCoordinate
        """
        this = _stomp.new_AngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AngularCoordinate
    __del__ = lambda self : None;
    def SetSurveyCoordinates(*args):
        """
        SetSurveyCoordinates(self, double lambda, double eta, bool radians=False)
        SetSurveyCoordinates(self, double lambda, double eta)
        """
        return _stomp.AngularCoordinate_SetSurveyCoordinates(*args)

    def SetEquatorialCoordinates(*args):
        """
        SetEquatorialCoordinates(self, double ra, double dec, bool radians=False)
        SetEquatorialCoordinates(self, double ra, double dec)
        """
        return _stomp.AngularCoordinate_SetEquatorialCoordinates(*args)

    def SetGalacticCoordinates(*args):
        """
        SetGalacticCoordinates(self, double gal_lon, double gal_lat, bool radians=False)
        SetGalacticCoordinates(self, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_SetGalacticCoordinates(*args)

    def SetUnitSphereCoordinates(*args):
        """
        SetUnitSphereCoordinates(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z)
        SetUnitSphereCoordinates(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            Sphere sphere)
        """
        return _stomp.AngularCoordinate_SetUnitSphereCoordinates(*args)

    def Set(*args):
        """
        Set(self, double theta, double phi, Sphere sphere, bool radians=False)
        Set(self, double theta, double phi, Sphere sphere)
        """
        return _stomp.AngularCoordinate_Set(*args)

    def Lambda(*args):
        """Lambda(self) -> double"""
        return _stomp.AngularCoordinate_Lambda(*args)

    def Eta(*args):
        """Eta(self) -> double"""
        return _stomp.AngularCoordinate_Eta(*args)

    def LambdaRadians(*args):
        """LambdaRadians(self) -> double"""
        return _stomp.AngularCoordinate_LambdaRadians(*args)

    def EtaRadians(*args):
        """EtaRadians(self) -> double"""
        return _stomp.AngularCoordinate_EtaRadians(*args)

    def RA(*args):
        """RA(self) -> double"""
        return _stomp.AngularCoordinate_RA(*args)

    def DEC(*args):
        """DEC(self) -> double"""
        return _stomp.AngularCoordinate_DEC(*args)

    def RARadians(*args):
        """RARadians(self) -> double"""
        return _stomp.AngularCoordinate_RARadians(*args)

    def DECRadians(*args):
        """DECRadians(self) -> double"""
        return _stomp.AngularCoordinate_DECRadians(*args)

    def GalLon(*args):
        """GalLon(self) -> double"""
        return _stomp.AngularCoordinate_GalLon(*args)

    def GalLat(*args):
        """GalLat(self) -> double"""
        return _stomp.AngularCoordinate_GalLat(*args)

    def GalLonRadians(*args):
        """GalLonRadians(self) -> double"""
        return _stomp.AngularCoordinate_GalLonRadians(*args)

    def GalLatRadians(*args):
        """GalLatRadians(self) -> double"""
        return _stomp.AngularCoordinate_GalLatRadians(*args)

    def UnitSphereX(*args):
        """
        UnitSphereX(self) -> double
        UnitSphereX(self, Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereX(*args)

    def UnitSphereY(*args):
        """
        UnitSphereY(self) -> double
        UnitSphereY(self, Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereY(*args)

    def UnitSphereZ(*args):
        """
        UnitSphereZ(self) -> double
        UnitSphereZ(self, Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereZ(*args)

    def AngularDistance(*args):
        """AngularDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.AngularCoordinate_AngularDistance(*args)

    def DotProduct(*args):
        """DotProduct(self, AngularCoordinate ang) -> double"""
        return _stomp.AngularCoordinate_DotProduct(*args)

    def CrossProduct(*args):
        """
        CrossProduct(self, AngularCoordinate ang, Sphere sphere=Equatorial) -> AngularCoordinate
        CrossProduct(self, AngularCoordinate ang) -> AngularCoordinate
        """
        return _stomp.AngularCoordinate_CrossProduct(*args)

    def GreatCircle(*args):
        """
        GreatCircle(self, AngularCoordinate ang, AngularCoordinate great_circle, 
            Sphere sphere=Equatorial)
        GreatCircle(self, AngularCoordinate ang, AngularCoordinate great_circle)
        """
        return _stomp.AngularCoordinate_GreatCircle(*args)

    def PositionAngle(*args):
        """
        PositionAngle(self, AngularCoordinate ang, Sphere sphere=Equatorial) -> double
        PositionAngle(self, AngularCoordinate ang) -> double
        PositionAngle(self, Pixel pix, Sphere sphere=Equatorial) -> double
        PositionAngle(self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_PositionAngle(*args)

    def CosPositionAngle(*args):
        """
        CosPositionAngle(self, AngularCoordinate ang, Sphere sphere=Equatorial) -> double
        CosPositionAngle(self, AngularCoordinate ang) -> double
        CosPositionAngle(self, Pixel pix, Sphere sphere=Equatorial) -> double
        CosPositionAngle(self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_CosPositionAngle(*args)

    def SinPositionAngle(*args):
        """
        SinPositionAngle(self, AngularCoordinate ang, Sphere sphere=Equatorial) -> double
        SinPositionAngle(self, AngularCoordinate ang) -> double
        SinPositionAngle(self, Pixel pix, Sphere sphere=Equatorial) -> double
        SinPositionAngle(self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_SinPositionAngle(*args)

    def Rotate(*args):
        """
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            Sphere sphere=Equatorial)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            AngularCoordinate rotated_ang, Sphere sphere=Equatorial)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            AngularCoordinate rotated_ang)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            Sphere sphere, double unit_sphere_x, double unit_sphere_y, 
            double unit_sphere_z)
        """
        return _stomp.AngularCoordinate_Rotate(*args)

    def SurveyToGalactic(*args):
        """
        SurveyToGalactic(double lambda, double eta, double gal_lon, double gal_lat, 
            bool radians=False)
        SurveyToGalactic(double lambda, double eta, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_SurveyToGalactic(*args)

    if _newclass:SurveyToGalactic = staticmethod(SurveyToGalactic)
    __swig_getmethods__["SurveyToGalactic"] = lambda x: SurveyToGalactic
    def SurveyToEquatorial(*args):
        """
        SurveyToEquatorial(double lambda, double eta, double ra, double dec, bool radians=False)
        SurveyToEquatorial(double lambda, double eta, double ra, double dec)
        """
        return _stomp.AngularCoordinate_SurveyToEquatorial(*args)

    if _newclass:SurveyToEquatorial = staticmethod(SurveyToEquatorial)
    __swig_getmethods__["SurveyToEquatorial"] = lambda x: SurveyToEquatorial
    def EquatorialToSurvey(*args):
        """
        EquatorialToSurvey(double ra, double dec, double lambda, double eta, bool radians=False)
        EquatorialToSurvey(double ra, double dec, double lambda, double eta)
        """
        return _stomp.AngularCoordinate_EquatorialToSurvey(*args)

    if _newclass:EquatorialToSurvey = staticmethod(EquatorialToSurvey)
    __swig_getmethods__["EquatorialToSurvey"] = lambda x: EquatorialToSurvey
    def EquatorialToGalactic(*args):
        """
        EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat, 
            bool radians=False)
        EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_EquatorialToGalactic(*args)

    if _newclass:EquatorialToGalactic = staticmethod(EquatorialToGalactic)
    __swig_getmethods__["EquatorialToGalactic"] = lambda x: EquatorialToGalactic
    def GalacticToSurvey(*args):
        """
        GalacticToSurvey(double gal_lon, double gal_lat, double lambda, double eta, 
            bool radians=False)
        GalacticToSurvey(double gal_lon, double gal_lat, double lambda, double eta)
        """
        return _stomp.AngularCoordinate_GalacticToSurvey(*args)

    if _newclass:GalacticToSurvey = staticmethod(GalacticToSurvey)
    __swig_getmethods__["GalacticToSurvey"] = lambda x: GalacticToSurvey
    def GalacticToEquatorial(*args):
        """
        GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec, 
            bool radians=False)
        GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec)
        """
        return _stomp.AngularCoordinate_GalacticToEquatorial(*args)

    if _newclass:GalacticToEquatorial = staticmethod(GalacticToEquatorial)
    __swig_getmethods__["GalacticToEquatorial"] = lambda x: GalacticToEquatorial
    def SurveyToXYZ(*args):
        """
        SurveyToXYZ(double lambda, double eta, double x, double y, double z, 
            bool radians=False)
        SurveyToXYZ(double lambda, double eta, double x, double y, double z)
        """
        return _stomp.AngularCoordinate_SurveyToXYZ(*args)

    if _newclass:SurveyToXYZ = staticmethod(SurveyToXYZ)
    __swig_getmethods__["SurveyToXYZ"] = lambda x: SurveyToXYZ
    def EquatorialToXYZ(*args):
        """
        EquatorialToXYZ(double ra, double dec, double x, double y, double z, 
            bool radians=False)
        EquatorialToXYZ(double ra, double dec, double x, double y, double z)
        """
        return _stomp.AngularCoordinate_EquatorialToXYZ(*args)

    if _newclass:EquatorialToXYZ = staticmethod(EquatorialToXYZ)
    __swig_getmethods__["EquatorialToXYZ"] = lambda x: EquatorialToXYZ
    def GalacticToXYZ(*args):
        """
        GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
            double z, bool radians=False)
        GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
            double z)
        """
        return _stomp.AngularCoordinate_GalacticToXYZ(*args)

    if _newclass:GalacticToXYZ = staticmethod(GalacticToXYZ)
    __swig_getmethods__["GalacticToXYZ"] = lambda x: GalacticToXYZ
    def EtaMultiplier(*args):
        """EtaMultiplier(double lam) -> double"""
        return _stomp.AngularCoordinate_EtaMultiplier(*args)

    if _newclass:EtaMultiplier = staticmethod(EtaMultiplier)
    __swig_getmethods__["EtaMultiplier"] = lambda x: EtaMultiplier
    def RAMultiplier(*args):
        """RAMultiplier(double dec) -> double"""
        return _stomp.AngularCoordinate_RAMultiplier(*args)

    if _newclass:RAMultiplier = staticmethod(RAMultiplier)
    __swig_getmethods__["RAMultiplier"] = lambda x: RAMultiplier
    def GalLonMultiplier(*args):
        """GalLonMultiplier(double glat) -> double"""
        return _stomp.AngularCoordinate_GalLonMultiplier(*args)

    if _newclass:GalLonMultiplier = staticmethod(GalLonMultiplier)
    __swig_getmethods__["GalLonMultiplier"] = lambda x: GalLonMultiplier
    def ToAngularVector(*args):
        """
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
            Sphere sphere=Equatorial, bool radians=False) -> bool
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
            Sphere sphere=Equatorial) -> bool
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial) -> bool
        ToAngularVector(string input_file, AngularVector ang) -> bool
        """
        return _stomp.AngularCoordinate_ToAngularVector(*args)

    if _newclass:ToAngularVector = staticmethod(ToAngularVector)
    __swig_getmethods__["ToAngularVector"] = lambda x: ToAngularVector
    def FromAngularVector(*args):
        """
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
            Sphere sphere=Equatorial, bool radians=False) -> bool
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
            Sphere sphere=Equatorial) -> bool
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec) -> bool
        FromAngularVector(AngularVector ang, string output_file, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromAngularVector(AngularVector ang, string output_file, Sphere sphere=Equatorial) -> bool
        FromAngularVector(AngularVector ang, string output_file) -> bool
        """
        return _stomp.AngularCoordinate_FromAngularVector(*args)

    if _newclass:FromAngularVector = staticmethod(FromAngularVector)
    __swig_getmethods__["FromAngularVector"] = lambda x: FromAngularVector
AngularCoordinate_swigregister = _stomp.AngularCoordinate_swigregister
AngularCoordinate_swigregister(AngularCoordinate)

def AngularCoordinate_SurveyToGalactic(*args):
  """
    SurveyToGalactic(double lambda, double eta, double gal_lon, double gal_lat, 
        bool radians=False)
    AngularCoordinate_SurveyToGalactic(double lambda, double eta, double gal_lon, double gal_lat)
    """
  return _stomp.AngularCoordinate_SurveyToGalactic(*args)

def AngularCoordinate_SurveyToEquatorial(*args):
  """
    SurveyToEquatorial(double lambda, double eta, double ra, double dec, bool radians=False)
    AngularCoordinate_SurveyToEquatorial(double lambda, double eta, double ra, double dec)
    """
  return _stomp.AngularCoordinate_SurveyToEquatorial(*args)

def AngularCoordinate_EquatorialToSurvey(*args):
  """
    EquatorialToSurvey(double ra, double dec, double lambda, double eta, bool radians=False)
    AngularCoordinate_EquatorialToSurvey(double ra, double dec, double lambda, double eta)
    """
  return _stomp.AngularCoordinate_EquatorialToSurvey(*args)

def AngularCoordinate_EquatorialToGalactic(*args):
  """
    EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat, 
        bool radians=False)
    AngularCoordinate_EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat)
    """
  return _stomp.AngularCoordinate_EquatorialToGalactic(*args)

def AngularCoordinate_GalacticToSurvey(*args):
  """
    GalacticToSurvey(double gal_lon, double gal_lat, double lambda, double eta, 
        bool radians=False)
    AngularCoordinate_GalacticToSurvey(double gal_lon, double gal_lat, double lambda, double eta)
    """
  return _stomp.AngularCoordinate_GalacticToSurvey(*args)

def AngularCoordinate_GalacticToEquatorial(*args):
  """
    GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec, 
        bool radians=False)
    AngularCoordinate_GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec)
    """
  return _stomp.AngularCoordinate_GalacticToEquatorial(*args)

def AngularCoordinate_SurveyToXYZ(*args):
  """
    SurveyToXYZ(double lambda, double eta, double x, double y, double z, 
        bool radians=False)
    AngularCoordinate_SurveyToXYZ(double lambda, double eta, double x, double y, double z)
    """
  return _stomp.AngularCoordinate_SurveyToXYZ(*args)

def AngularCoordinate_EquatorialToXYZ(*args):
  """
    EquatorialToXYZ(double ra, double dec, double x, double y, double z, 
        bool radians=False)
    AngularCoordinate_EquatorialToXYZ(double ra, double dec, double x, double y, double z)
    """
  return _stomp.AngularCoordinate_EquatorialToXYZ(*args)

def AngularCoordinate_GalacticToXYZ(*args):
  """
    GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
        double z, bool radians=False)
    AngularCoordinate_GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
        double z)
    """
  return _stomp.AngularCoordinate_GalacticToXYZ(*args)

def AngularCoordinate_EtaMultiplier(*args):
  """AngularCoordinate_EtaMultiplier(double lam) -> double"""
  return _stomp.AngularCoordinate_EtaMultiplier(*args)

def AngularCoordinate_RAMultiplier(*args):
  """AngularCoordinate_RAMultiplier(double dec) -> double"""
  return _stomp.AngularCoordinate_RAMultiplier(*args)

def AngularCoordinate_GalLonMultiplier(*args):
  """AngularCoordinate_GalLonMultiplier(double glat) -> double"""
  return _stomp.AngularCoordinate_GalLonMultiplier(*args)

def AngularCoordinate_ToAngularVector(*args):
  """
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
        Sphere sphere=Equatorial, bool radians=False) -> bool
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
        Sphere sphere=Equatorial) -> bool
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere=Equatorial) -> bool
    AngularCoordinate_ToAngularVector(string input_file, AngularVector ang) -> bool
    """
  return _stomp.AngularCoordinate_ToAngularVector(*args)

def AngularCoordinate_FromAngularVector(*args):
  """
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
        Sphere sphere=Equatorial, bool radians=False) -> bool
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
        Sphere sphere=Equatorial) -> bool
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec) -> bool
    FromAngularVector(AngularVector ang, string output_file, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromAngularVector(AngularVector ang, string output_file, Sphere sphere=Equatorial) -> bool
    AngularCoordinate_FromAngularVector(AngularVector ang, string output_file) -> bool
    """
  return _stomp.AngularCoordinate_FromAngularVector(*args)

class WeightedAngularCoordinate(AngularCoordinate):
    """Proxy of C++ WeightedAngularCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [AngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedAngularCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedAngularCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, Sphere sphere=Survey, 
            bool radians=False) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, Sphere sphere=Survey) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, FieldDict fields, 
            Sphere sphere=Survey, bool radians=False) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, FieldDict fields, 
            Sphere sphere=Survey) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, FieldDict fields) -> WeightedAngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            double weight) -> WeightedAngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            double weight, FieldDict fields) -> WeightedAngularCoordinate
        """
        this = _stomp.new_WeightedAngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_WeightedAngularCoordinate
    __del__ = lambda self : None;
    def SetWeight(*args):
        """SetWeight(self, double weight)"""
        return _stomp.WeightedAngularCoordinate_SetWeight(*args)

    def Weight(*args):
        """Weight(self) -> double"""
        return _stomp.WeightedAngularCoordinate_Weight(*args)

    def SetField(*args):
        """SetField(self, string field_name, double weight)"""
        return _stomp.WeightedAngularCoordinate_SetField(*args)

    def Field(*args):
        """Field(self, string field_name) -> double"""
        return _stomp.WeightedAngularCoordinate_Field(*args)

    def NFields(*args):
        """NFields(self) -> uint16_t"""
        return _stomp.WeightedAngularCoordinate_NFields(*args)

    def HasFields(*args):
        """HasFields(self) -> bool"""
        return _stomp.WeightedAngularCoordinate_HasFields(*args)

    def FieldNames(*args):
        """FieldNames(self, std::vector<(std::string,std::allocator<(std::string)>)> field_names)"""
        return _stomp.WeightedAngularCoordinate_FieldNames(*args)

    def CopyFields(*args):
        """CopyFields(self, WeightedAngularCoordinate w_ang)"""
        return _stomp.WeightedAngularCoordinate_CopyFields(*args)

    def CopyFieldToWeight(*args):
        """CopyFieldToWeight(self, string field_name)"""
        return _stomp.WeightedAngularCoordinate_CopyFieldToWeight(*args)

    def RestoreOriginalWeight(*args):
        """RestoreOriginalWeight(self)"""
        return _stomp.WeightedAngularCoordinate_RestoreOriginalWeight(*args)

    def ToWAngularVector(*args):
        """
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            WAngularVector w_ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            WAngularVector w_ang, Sphere sphere=Equatorial) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            WAngularVector w_ang) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
            WAngularVector w_ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
            WAngularVector w_ang, Sphere sphere=Equatorial) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
            WAngularVector w_ang) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, int8_t weight_column=-1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, int8_t weight_column=-1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere=Equatorial) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns) -> bool
        """
        return _stomp.WeightedAngularCoordinate_ToWAngularVector(*args)

    if _newclass:ToWAngularVector = staticmethod(ToWAngularVector)
    __swig_getmethods__["ToWAngularVector"] = lambda x: ToWAngularVector
    def FromWAngularVector(*args):
        """
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector weightVec, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector weightVec, Sphere sphere=Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector weightVec) -> bool
        FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere=Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, string output_file) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, uint8_t weight_column=2) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere=Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file) -> bool
        """
        return _stomp.WeightedAngularCoordinate_FromWAngularVector(*args)

    if _newclass:FromWAngularVector = staticmethod(FromWAngularVector)
    __swig_getmethods__["FromWAngularVector"] = lambda x: FromWAngularVector
    def AddField(*args):
        """AddField(WAngularVector w_ang, string field_name, DoubleVector field_value) -> bool"""
        return _stomp.WeightedAngularCoordinate_AddField(*args)

    if _newclass:AddField = staticmethod(AddField)
    __swig_getmethods__["AddField"] = lambda x: AddField
WeightedAngularCoordinate_swigregister = _stomp.WeightedAngularCoordinate_swigregister
WeightedAngularCoordinate_swigregister(WeightedAngularCoordinate)

def WeightedAngularCoordinate_ToWAngularVector(*args):
  """
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        WAngularVector w_ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        WAngularVector w_ang, Sphere sphere=Equatorial) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        WAngularVector w_ang) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
        WAngularVector w_ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
        WAngularVector w_ang, Sphere sphere=Equatorial) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
        WAngularVector w_ang) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1, int8_t weight_column=-1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere=Equatorial) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1, int8_t weight_column=-1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere=Equatorial) -> bool
    WeightedAngularCoordinate_ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns) -> bool
    """
  return _stomp.WeightedAngularCoordinate_ToWAngularVector(*args)

def WeightedAngularCoordinate_FromWAngularVector(*args):
  """
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector weightVec, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector weightVec, Sphere sphere=Equatorial) -> bool
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector weightVec) -> bool
    FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere=Equatorial) -> bool
    FromWAngularVector(WAngularVector w_ang, string output_file) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1, uint8_t weight_column=2) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere=Equatorial) -> bool
    WeightedAngularCoordinate_FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file) -> bool
    """
  return _stomp.WeightedAngularCoordinate_FromWAngularVector(*args)

def WeightedAngularCoordinate_AddField(*args):
  """WeightedAngularCoordinate_AddField(WAngularVector w_ang, string field_name, DoubleVector field_value) -> bool"""
  return _stomp.WeightedAngularCoordinate_AddField(*args)

class CosmoCoordinate(WeightedAngularCoordinate):
    """Proxy of C++ CosmoCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [WeightedAngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosmoCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [WeightedAngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CosmoCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CosmoCoordinate
        __init__(self, double theta, double phi, double redshift, double weight, 
            Sphere sphere=Survey, bool radians=False) -> CosmoCoordinate
        __init__(self, double theta, double phi, double redshift, double weight, 
            Sphere sphere=Survey) -> CosmoCoordinate
        __init__(self, double theta, double phi, double redshift, double weight) -> CosmoCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            double redshift, double weight) -> CosmoCoordinate
        """
        this = _stomp.new_CosmoCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_CosmoCoordinate
    __del__ = lambda self : None;
    def ProjectedRadius(*args):
        """ProjectedRadius(self, AngularCoordinate ang) -> double"""
        return _stomp.CosmoCoordinate_ProjectedRadius(*args)

    def DotProduct(*args):
        """DotProduct(self, CosmoCoordinate ang) -> double"""
        return _stomp.CosmoCoordinate_DotProduct(*args)

    def ComovingDistance(*args):
        """ComovingDistance(self) -> double"""
        return _stomp.CosmoCoordinate_ComovingDistance(*args)

    def AngularDiameterDistance(*args):
        """AngularDiameterDistance(self) -> double"""
        return _stomp.CosmoCoordinate_AngularDiameterDistance(*args)

    def LuminosityDistance(*args):
        """LuminosityDistance(self) -> double"""
        return _stomp.CosmoCoordinate_LuminosityDistance(*args)

    def Redshift(*args):
        """Redshift(self) -> double"""
        return _stomp.CosmoCoordinate_Redshift(*args)

    def SetRedshift(*args):
        """SetRedshift(self, double redshift)"""
        return _stomp.CosmoCoordinate_SetRedshift(*args)

    def ToCosmoVector(*args):
        """
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, CosmoVector z_ang, 
            Sphere sphere=Equatorial, bool radians=False) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, CosmoVector z_ang, 
            Sphere sphere=Equatorial) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, CosmoVector z_ang) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            double weight, CosmoVector z_ang, 
            Sphere sphere=Equatorial, bool radians=False) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            double weight, CosmoVector z_ang, 
            Sphere sphere=Equatorial) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            double weight, CosmoVector z_ang) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, uint8_t redshift_column=2, 
            int8_t weight_column=-1) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, uint8_t redshift_column=2) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang) -> bool
        """
        return _stomp.CosmoCoordinate_ToCosmoVector(*args)

    if _newclass:ToCosmoVector = staticmethod(ToCosmoVector)
    __swig_getmethods__["ToCosmoVector"] = lambda x: ToCosmoVector
    def FromCosmoVector(*args):
        """
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector redshiftVec, DoubleVector weightVec, 
            Sphere sphere=Equatorial, bool radians=False) -> bool
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector redshiftVec, DoubleVector weightVec, 
            Sphere sphere=Equatorial) -> bool
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector redshiftVec, DoubleVector weightVec) -> bool
        FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere=Equatorial) -> bool
        FromCosmoVector(CosmoVector z_ang, string output_file) -> bool
        """
        return _stomp.CosmoCoordinate_FromCosmoVector(*args)

    if _newclass:FromCosmoVector = staticmethod(FromCosmoVector)
    __swig_getmethods__["FromCosmoVector"] = lambda x: FromCosmoVector
CosmoCoordinate_swigregister = _stomp.CosmoCoordinate_swigregister
CosmoCoordinate_swigregister(CosmoCoordinate)

def CosmoCoordinate_ToCosmoVector(*args):
  """
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, CosmoVector z_ang, 
        Sphere sphere=Equatorial, bool radians=False) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, CosmoVector z_ang, 
        Sphere sphere=Equatorial) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, CosmoVector z_ang) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        double weight, CosmoVector z_ang, 
        Sphere sphere=Equatorial, bool radians=False) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        double weight, CosmoVector z_ang, 
        Sphere sphere=Equatorial) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        double weight, CosmoVector z_ang) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1, uint8_t redshift_column=2, 
        int8_t weight_column=-1) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1, uint8_t redshift_column=2) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere=Equatorial) -> bool
    CosmoCoordinate_ToCosmoVector(string input_file, CosmoVector z_ang) -> bool
    """
  return _stomp.CosmoCoordinate_ToCosmoVector(*args)

def CosmoCoordinate_FromCosmoVector(*args):
  """
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector redshiftVec, DoubleVector weightVec, 
        Sphere sphere=Equatorial, bool radians=False) -> bool
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector redshiftVec, DoubleVector weightVec, 
        Sphere sphere=Equatorial) -> bool
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector redshiftVec, DoubleVector weightVec) -> bool
    FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere=Equatorial) -> bool
    CosmoCoordinate_FromCosmoVector(CosmoVector z_ang, string output_file) -> bool
    """
  return _stomp.CosmoCoordinate_FromCosmoVector(*args)

class IndexedAngularCoordinate(AngularCoordinate):
    """Proxy of C++ IndexedAngularCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [AngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedAngularCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedAngularCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IndexedAngularCoordinate
        __init__(self, double theta, double phi, uint32_t index, Sphere sphere=Survey, 
            bool radians=False) -> IndexedAngularCoordinate
        __init__(self, double theta, double phi, uint32_t index, Sphere sphere=Survey) -> IndexedAngularCoordinate
        __init__(self, double theta, double phi, uint32_t index) -> IndexedAngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            uint32_t index) -> IndexedAngularCoordinate
        """
        this = _stomp.new_IndexedAngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedAngularCoordinate
    __del__ = lambda self : None;
    def SetIndex(*args):
        """SetIndex(self, uint32_t index)"""
        return _stomp.IndexedAngularCoordinate_SetIndex(*args)

    def Index(*args):
        """Index(self) -> uint32_t"""
        return _stomp.IndexedAngularCoordinate_Index(*args)

    def ToIAngularVector(*args):
        """
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            IAngularVector i_ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            IAngularVector i_ang, Sphere sphere=Equatorial) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            IAngularVector i_ang) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
            Sphere sphere=Equatorial, bool radians=False) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
            Sphere sphere=Equatorial) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, int8_t index_column=-1) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang) -> bool
        """
        return _stomp.IndexedAngularCoordinate_ToIAngularVector(*args)

    if _newclass:ToIAngularVector = staticmethod(ToIAngularVector)
    __swig_getmethods__["ToIAngularVector"] = lambda x: ToIAngularVector
    def FromIAngularVector(*args):
        """
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            IndexVector indexVec, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            IndexVector indexVec, Sphere sphere=Equatorial) -> bool
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            IndexVector indexVec) -> bool
        FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere=Equatorial) -> bool
        FromIAngularVector(IAngularVector i_ang, string output_file) -> bool
        """
        return _stomp.IndexedAngularCoordinate_FromIAngularVector(*args)

    if _newclass:FromIAngularVector = staticmethod(FromIAngularVector)
    __swig_getmethods__["FromIAngularVector"] = lambda x: FromIAngularVector
IndexedAngularCoordinate_swigregister = _stomp.IndexedAngularCoordinate_swigregister
IndexedAngularCoordinate_swigregister(IndexedAngularCoordinate)

def IndexedAngularCoordinate_ToIAngularVector(*args):
  """
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        IAngularVector i_ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        IAngularVector i_ang, Sphere sphere=Equatorial) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        IAngularVector i_ang) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
        Sphere sphere=Equatorial, bool radians=False) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
        Sphere sphere=Equatorial) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1, int8_t index_column=-1) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, 
        uint8_t phi_column=1) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere=Equatorial) -> bool
    IndexedAngularCoordinate_ToIAngularVector(string input_file, IAngularVector i_ang) -> bool
    """
  return _stomp.IndexedAngularCoordinate_ToIAngularVector(*args)

def IndexedAngularCoordinate_FromIAngularVector(*args):
  """
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        IndexVector indexVec, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        IndexVector indexVec, Sphere sphere=Equatorial) -> bool
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        IndexVector indexVec) -> bool
    FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere=Equatorial) -> bool
    IndexedAngularCoordinate_FromIAngularVector(IAngularVector i_ang, string output_file) -> bool
    """
  return _stomp.IndexedAngularCoordinate_FromIAngularVector(*args)

class TreePixel(Pixel):
    """Proxy of C++ TreePixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TreePixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> TreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum, uint16_t maximum_points=200) -> TreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> TreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, uint16_t maximum_points=200) -> TreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> TreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, uint16_t maximum_points=200) -> TreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> TreePixel
        """
        this = _stomp.new_TreePixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreePixel
    __del__ = lambda self : None;
    def _InitializeSubPixels(*args):
        """_InitializeSubPixels(self) -> bool"""
        return _stomp.TreePixel__InitializeSubPixels(*args)

    def DirectPairCount(*args):
        """
        DirectPairCount(self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> uint32_t
        DirectPairCount(self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        """
        return _stomp.TreePixel_DirectPairCount(*args)

    def FindPairs(*args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> uint32_t
        FindPairs(self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_max) -> uint32_t
        FindPairs(self, AngularVector ang, AngularBin theta, int16_t region=-1)
        FindPairs(self, AngularVector ang, AngularBin theta)
        FindPairs(self, AngularVector ang, AngularCorrelation wtheta, int16_t region=-1)
        FindPairs(self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreePixel_FindPairs(*args)

    def DirectWeightedPairs(*args):
        """
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> double
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            int16_t region=-1) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name, 
            int16_t region=-1) -> double
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name, int16_t region=-1) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name, int16_t region=-1) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name) -> double
        """
        return _stomp.TreePixel_DirectWeightedPairs(*args)

    def FindWeightedPairs(*args):
        """
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> double
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            int16_t region=-1) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, int16_t region=-1)
        FindWeightedPairs(self, AngularVector ang, AngularBin theta)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, int16_t region=-1)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, int16_t region=-1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, int16_t region=-1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name, 
            int16_t region=-1) -> double
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max, string field_name) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, string field_name, 
            int16_t region=-1)
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, string field_name, 
            int16_t region=-1)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name, int16_t region=-1) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, string field_name, 
            int16_t region=-1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name, 
            int16_t region=-1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name, int16_t region=-1) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_min, double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name, int16_t region=-1)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name, int16_t region=-1)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name)
        """
        return _stomp.TreePixel_FindWeightedPairs(*args)

    def FindKNearestNeighbors(*args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, WAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.TreePixel_FindKNearestNeighbors(*args)

    def FindNearestNeighbor(*args):
        """FindNearestNeighbor(self, AngularCoordinate ang, WeightedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.TreePixel_FindNearestNeighbor(*args)

    def KNearestNeighborDistance(*args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.TreePixel_KNearestNeighborDistance(*args)

    def NearestNeighborDistance(*args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.TreePixel_NearestNeighborDistance(*args)

    def ClosestMatch(*args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, WeightedAngularCoordinate match_ang) -> bool"""
        return _stomp.TreePixel_ClosestMatch(*args)

    def InitializeCorners(*args):
        """InitializeCorners(self)"""
        return _stomp.TreePixel_InitializeCorners(*args)

    def AddPoint(*args):
        """
        AddPoint(self, WeightedAngularCoordinate w_ang) -> bool
        AddPoint(self, AngularCoordinate ang, double object_weight=1.0) -> bool
        AddPoint(self, AngularCoordinate ang) -> bool
        """
        return _stomp.TreePixel_AddPoint(*args)

    def NPoints(*args):
        """
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.TreePixel_NPoints(*args)

    def PixelWeight(*args):
        """PixelWeight(self, Pixel pix) -> double"""
        return _stomp.TreePixel_PixelWeight(*args)

    def Coverage(*args):
        """
        Coverage(self) -> double
        Coverage(self, Pixel pix) -> double
        """
        return _stomp.TreePixel_Coverage(*args)

    def Points(*args):
        """
        Points(self, WAngularVector w_ang)
        Points(self, WAngularVector w_ang, Pixel pix)
        """
        return _stomp.TreePixel_Points(*args)

    def Nodes(*args):
        """Nodes(self) -> uint16_t"""
        return _stomp.TreePixel_Nodes(*args)

    def AddToWeight(*args):
        """AddToWeight(self, double weight)"""
        return _stomp.TreePixel_AddToWeight(*args)

    def FieldTotal(*args):
        """
        FieldTotal(self, string field_name) -> double
        FieldTotal(self, string field_name, Pixel pix) -> double
        """
        return _stomp.TreePixel_FieldTotal(*args)

    def AddToField(*args):
        """AddToField(self, string field_name, double weight)"""
        return _stomp.TreePixel_AddToField(*args)

    def NField(*args):
        """NField(self) -> uint16_t"""
        return _stomp.TreePixel_NField(*args)

    def HasFields(*args):
        """HasFields(self) -> bool"""
        return _stomp.TreePixel_HasFields(*args)

    def FieldNames(*args):
        """FieldNames(self, std::vector<(std::string,std::allocator<(std::string)>)> field_names)"""
        return _stomp.TreePixel_FieldNames(*args)

    def SetPixelCapacity(*args):
        """SetPixelCapacity(self, uint16_t maximum_points)"""
        return _stomp.TreePixel_SetPixelCapacity(*args)

    def PixelCapacity(*args):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.TreePixel_PixelCapacity(*args)

    def HasPoints(*args):
        """HasPoints(self) -> bool"""
        return _stomp.TreePixel_HasPoints(*args)

    def HasNodes(*args):
        """HasNodes(self) -> bool"""
        return _stomp.TreePixel_HasNodes(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.TreePixel_Clear(*args)

    def UnitSphereX(*args):
        """UnitSphereX(self) -> double"""
        return _stomp.TreePixel_UnitSphereX(*args)

    def UnitSphereY(*args):
        """UnitSphereY(self) -> double"""
        return _stomp.TreePixel_UnitSphereY(*args)

    def UnitSphereZ(*args):
        """UnitSphereZ(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ(*args)

    def UnitSphereX_UL(*args):
        """UnitSphereX_UL(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_UL(*args)

    def UnitSphereY_UL(*args):
        """UnitSphereY_UL(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_UL(*args)

    def UnitSphereZ_UL(*args):
        """UnitSphereZ_UL(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_UL(*args)

    def UnitSphereX_UR(*args):
        """UnitSphereX_UR(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_UR(*args)

    def UnitSphereY_UR(*args):
        """UnitSphereY_UR(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_UR(*args)

    def UnitSphereZ_UR(*args):
        """UnitSphereZ_UR(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_UR(*args)

    def UnitSphereX_LL(*args):
        """UnitSphereX_LL(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_LL(*args)

    def UnitSphereY_LL(*args):
        """UnitSphereY_LL(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_LL(*args)

    def UnitSphereZ_LL(*args):
        """UnitSphereZ_LL(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_LL(*args)

    def UnitSphereX_LR(*args):
        """UnitSphereX_LR(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_LR(*args)

    def UnitSphereY_LR(*args):
        """UnitSphereY_LR(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_LR(*args)

    def UnitSphereZ_LR(*args):
        """UnitSphereZ_LR(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_LR(*args)

    def WithinAnnulus(*args):
        """WithinAnnulus(self, AngularBin theta, PixelVector pix, bool check_full_pixel)"""
        return _stomp.TreePixel_WithinAnnulus(*args)

TreePixel_swigregister = _stomp.TreePixel_swigregister
TreePixel_swigregister(TreePixel)

class NearestNeighborPixel(_object):
    """Proxy of C++ NearestNeighborPixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborPixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborPixel, name)
    __repr__ = _swig_repr
    def __call__(*args):
        """__call__(self, DistancePixelPair x, DistancePixelPair y) -> int"""
        return _stomp.NearestNeighborPixel___call__(*args)

    def __init__(self, *args): 
        """__init__(self) -> NearestNeighborPixel"""
        this = _stomp.new_NearestNeighborPixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborPixel
    __del__ = lambda self : None;
NearestNeighborPixel_swigregister = _stomp.NearestNeighborPixel_swigregister
NearestNeighborPixel_swigregister(NearestNeighborPixel)

class NearestNeighborPoint(_object):
    """Proxy of C++ NearestNeighborPoint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborPoint, name)
    __repr__ = _swig_repr
    def __call__(*args):
        """__call__(self, DistancePointPair x, DistancePointPair y) -> int"""
        return _stomp.NearestNeighborPoint___call__(*args)

    def __init__(self, *args): 
        """__init__(self) -> NearestNeighborPoint"""
        this = _stomp.new_NearestNeighborPoint(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborPoint
    __del__ = lambda self : None;
NearestNeighborPoint_swigregister = _stomp.NearestNeighborPoint_swigregister
NearestNeighborPoint_swigregister(NearestNeighborPoint)

class TreeNeighbor(_object):
    """Proxy of C++ TreeNeighbor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeNeighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeNeighbor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate reference_ang, uint8_t n_neighbors=1) -> TreeNeighbor
        __init__(self, AngularCoordinate reference_ang) -> TreeNeighbor
        """
        this = _stomp.new_TreeNeighbor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreeNeighbor
    __del__ = lambda self : None;
    def NearestNeighbors(*args):
        """
        NearestNeighbors(self, WAngularVector w_ang, bool save_neighbors=True)
        NearestNeighbors(self, WAngularVector w_ang)
        """
        return _stomp.TreeNeighbor_NearestNeighbors(*args)

    def Neighbors(*args):
        """Neighbors(self) -> uint8_t"""
        return _stomp.TreeNeighbor_Neighbors(*args)

    def MaxNeighbors(*args):
        """MaxNeighbors(self) -> uint8_t"""
        return _stomp.TreeNeighbor_MaxNeighbors(*args)

    def TestPoint(*args):
        """TestPoint(self, WeightedAngularCoordinate test_ang) -> bool"""
        return _stomp.TreeNeighbor_TestPoint(*args)

    def MaxDistance(*args):
        """MaxDistance(self) -> double"""
        return _stomp.TreeNeighbor_MaxDistance(*args)

    def MaxAngularDistance(*args):
        """MaxAngularDistance(self) -> double"""
        return _stomp.TreeNeighbor_MaxAngularDistance(*args)

    def NodesVisited(*args):
        """NodesVisited(self) -> uint16_t"""
        return _stomp.TreeNeighbor_NodesVisited(*args)

    def AddNode(*args):
        """AddNode(self)"""
        return _stomp.TreeNeighbor_AddNode(*args)

TreeNeighbor_swigregister = _stomp.TreeNeighbor_swigregister
TreeNeighbor_swigregister(TreeNeighbor)

class IndexedTreePixel(Pixel):
    """Proxy of C++ IndexedTreePixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreePixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreePixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IndexedTreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum, uint16_t maximum_points=200) -> IndexedTreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> IndexedTreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, uint16_t maximum_points=200) -> IndexedTreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> IndexedTreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, uint16_t maximum_points=200) -> IndexedTreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> IndexedTreePixel
        """
        this = _stomp.new_IndexedTreePixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreePixel
    __del__ = lambda self : None;
    def FindPairs(*args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IAngularVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IndexVector pair_indices)
        """
        return _stomp.IndexedTreePixel_FindPairs(*args)

    def FindKNearestNeighbors(*args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, IAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.IndexedTreePixel_FindKNearestNeighbors(*args)

    def FindNearestNeighbor(*args):
        """FindNearestNeighbor(self, AngularCoordinate ang, IndexedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.IndexedTreePixel_FindNearestNeighbor(*args)

    def KNearestNeighborDistance(*args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreePixel_KNearestNeighborDistance(*args)

    def NearestNeighborDistance(*args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreePixel_NearestNeighborDistance(*args)

    def ClosestMatch(*args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, IndexedAngularCoordinate match_ang) -> bool"""
        return _stomp.IndexedTreePixel_ClosestMatch(*args)

    def InitializeCorners(*args):
        """InitializeCorners(self)"""
        return _stomp.IndexedTreePixel_InitializeCorners(*args)

    def AddPoint(*args):
        """
        AddPoint(self, IndexedAngularCoordinate w_ang) -> bool
        AddPoint(self, AngularCoordinate ang, uint32_t index) -> bool
        """
        return _stomp.IndexedTreePixel_AddPoint(*args)

    def NPoints(*args):
        """
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.IndexedTreePixel_NPoints(*args)

    def Indices(*args):
        """Indices(self, Pixel pix, IndexVector indices)"""
        return _stomp.IndexedTreePixel_Indices(*args)

    def Coverage(*args):
        """
        Coverage(self) -> double
        Coverage(self, Pixel pix) -> double
        """
        return _stomp.IndexedTreePixel_Coverage(*args)

    def Points(*args):
        """
        Points(self, IAngularVector i_ang)
        Points(self, IAngularVector i_ang, Pixel pix)
        """
        return _stomp.IndexedTreePixel_Points(*args)

    def Nodes(*args):
        """Nodes(self) -> uint16_t"""
        return _stomp.IndexedTreePixel_Nodes(*args)

    def SetPixelCapacity(*args):
        """SetPixelCapacity(self, uint16_t maximum_points)"""
        return _stomp.IndexedTreePixel_SetPixelCapacity(*args)

    def PixelCapacity(*args):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.IndexedTreePixel_PixelCapacity(*args)

    def HasPoints(*args):
        """HasPoints(self) -> bool"""
        return _stomp.IndexedTreePixel_HasPoints(*args)

    def HasNodes(*args):
        """HasNodes(self) -> bool"""
        return _stomp.IndexedTreePixel_HasNodes(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.IndexedTreePixel_Clear(*args)

    def UnitSphereX(*args):
        """UnitSphereX(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX(*args)

    def UnitSphereY(*args):
        """UnitSphereY(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY(*args)

    def UnitSphereZ(*args):
        """UnitSphereZ(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ(*args)

    def UnitSphereX_UL(*args):
        """UnitSphereX_UL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_UL(*args)

    def UnitSphereY_UL(*args):
        """UnitSphereY_UL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_UL(*args)

    def UnitSphereZ_UL(*args):
        """UnitSphereZ_UL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_UL(*args)

    def UnitSphereX_UR(*args):
        """UnitSphereX_UR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_UR(*args)

    def UnitSphereY_UR(*args):
        """UnitSphereY_UR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_UR(*args)

    def UnitSphereZ_UR(*args):
        """UnitSphereZ_UR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_UR(*args)

    def UnitSphereX_LL(*args):
        """UnitSphereX_LL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_LL(*args)

    def UnitSphereY_LL(*args):
        """UnitSphereY_LL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_LL(*args)

    def UnitSphereZ_LL(*args):
        """UnitSphereZ_LL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_LL(*args)

    def UnitSphereX_LR(*args):
        """UnitSphereX_LR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_LR(*args)

    def UnitSphereY_LR(*args):
        """UnitSphereY_LR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_LR(*args)

    def UnitSphereZ_LR(*args):
        """UnitSphereZ_LR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_LR(*args)

    def WithinAnnulus(*args):
        """WithinAnnulus(self, AngularBin theta, PixelVector pix, bool check_full_pixel)"""
        return _stomp.IndexedTreePixel_WithinAnnulus(*args)

IndexedTreePixel_swigregister = _stomp.IndexedTreePixel_swigregister
IndexedTreePixel_swigregister(IndexedTreePixel)

class NearestNeighborIndexedPixel(_object):
    """Proxy of C++ NearestNeighborIndexedPixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborIndexedPixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborIndexedPixel, name)
    __repr__ = _swig_repr
    def __call__(*args):
        """__call__(self, DistanceIPixelPair x, DistanceIPixelPair y) -> int"""
        return _stomp.NearestNeighborIndexedPixel___call__(*args)

    def __init__(self, *args): 
        """__init__(self) -> NearestNeighborIndexedPixel"""
        this = _stomp.new_NearestNeighborIndexedPixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborIndexedPixel
    __del__ = lambda self : None;
NearestNeighborIndexedPixel_swigregister = _stomp.NearestNeighborIndexedPixel_swigregister
NearestNeighborIndexedPixel_swigregister(NearestNeighborIndexedPixel)

class NearestNeighborIndexedPoint(_object):
    """Proxy of C++ NearestNeighborIndexedPoint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborIndexedPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborIndexedPoint, name)
    __repr__ = _swig_repr
    def __call__(*args):
        """__call__(self, DistanceIPointPair x, DistanceIPointPair y) -> int"""
        return _stomp.NearestNeighborIndexedPoint___call__(*args)

    def __init__(self, *args): 
        """__init__(self) -> NearestNeighborIndexedPoint"""
        this = _stomp.new_NearestNeighborIndexedPoint(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborIndexedPoint
    __del__ = lambda self : None;
NearestNeighborIndexedPoint_swigregister = _stomp.NearestNeighborIndexedPoint_swigregister
NearestNeighborIndexedPoint_swigregister(NearestNeighborIndexedPoint)

class IndexedTreeNeighbor(_object):
    """Proxy of C++ IndexedTreeNeighbor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreeNeighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreeNeighbor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate reference_ang, uint8_t n_neighbors=1) -> IndexedTreeNeighbor
        __init__(self, AngularCoordinate reference_ang) -> IndexedTreeNeighbor
        __init__(self, AngularCoordinate reference_ang, uint8_t n_neighbors, 
            double max_distance) -> IndexedTreeNeighbor
        """
        this = _stomp.new_IndexedTreeNeighbor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreeNeighbor
    __del__ = lambda self : None;
    def NearestNeighbors(*args):
        """
        NearestNeighbors(self, IAngularVector i_ang, bool save_neighbors=True)
        NearestNeighbors(self, IAngularVector i_ang)
        """
        return _stomp.IndexedTreeNeighbor_NearestNeighbors(*args)

    def Neighbors(*args):
        """Neighbors(self) -> uint8_t"""
        return _stomp.IndexedTreeNeighbor_Neighbors(*args)

    def MaxNeighbors(*args):
        """MaxNeighbors(self) -> uint8_t"""
        return _stomp.IndexedTreeNeighbor_MaxNeighbors(*args)

    def TestPoint(*args):
        """TestPoint(self, IndexedAngularCoordinate test_ang) -> bool"""
        return _stomp.IndexedTreeNeighbor_TestPoint(*args)

    def MaxDistance(*args):
        """MaxDistance(self) -> double"""
        return _stomp.IndexedTreeNeighbor_MaxDistance(*args)

    def MaxAngularDistance(*args):
        """MaxAngularDistance(self) -> double"""
        return _stomp.IndexedTreeNeighbor_MaxAngularDistance(*args)

    def NodesVisited(*args):
        """NodesVisited(self) -> uint16_t"""
        return _stomp.IndexedTreeNeighbor_NodesVisited(*args)

    def AddNode(*args):
        """AddNode(self)"""
        return _stomp.IndexedTreeNeighbor_AddNode(*args)

IndexedTreeNeighbor_swigregister = _stomp.IndexedTreeNeighbor_swigregister
IndexedTreeNeighbor_swigregister(IndexedTreeNeighbor)

class TreeMap(BaseMap):
    """Proxy of C++ TreeMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TreeMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, uint32_t resolution=HPixResolution, uint16_t maximum_points=50) -> TreeMap
        __init__(self, uint32_t resolution=HPixResolution) -> TreeMap
        __init__(self) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, int8_t weight_column=-1) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50) -> TreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution) -> TreeMap
        __init__(self, string input_file) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, 
            Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t weight_column=-1) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, 
            Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, 
            Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, 
            Sphere sphere=Equatorial, bool verbose=False) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, 
            Sphere sphere=Equatorial) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns) -> TreeMap
        """
        this = _stomp.new_TreeMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreeMap
    __del__ = lambda self : None;
    def FindPairs(*args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_max) -> uint32_t
        FindPairs(self, AngularVector ang, AngularBin theta)
        FindPairs(self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreeMap_FindPairs(*args)

    def FindWeightedPairs(*args):
        """
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max) -> double
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max, string field_name) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_min, double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name)
        """
        return _stomp.TreeMap_FindWeightedPairs(*args)

    def FindPairsWithRegions(*args):
        """
        FindPairsWithRegions(self, AngularVector ang, AngularBin theta)
        FindPairsWithRegions(self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreeMap_FindPairsWithRegions(*args)

    def FindWeightedPairsWithRegions(*args):
        """
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularBin theta)
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularBin theta, string field_name)
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularBin theta, string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name)
        """
        return _stomp.TreeMap_FindWeightedPairsWithRegions(*args)

    def FindKNearestNeighbors(*args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, WAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.TreeMap_FindKNearestNeighbors(*args)

    def FindNearestNeighbor(*args):
        """FindNearestNeighbor(self, AngularCoordinate ang, WeightedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.TreeMap_FindNearestNeighbor(*args)

    def KNearestNeighborDistance(*args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.TreeMap_KNearestNeighborDistance(*args)

    def NearestNeighborDistance(*args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.TreeMap_NearestNeighborDistance(*args)

    def ClosestMatch(*args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, WeightedAngularCoordinate match_ang) -> bool"""
        return _stomp.TreeMap_ClosestMatch(*args)

    def AddPoint(*args):
        """
        AddPoint(self, WeightedAngularCoordinate w_ang) -> bool
        AddPoint(self, AngularCoordinate ang, double object_weight=1.0) -> bool
        AddPoint(self, AngularCoordinate ang) -> bool
        """
        return _stomp.TreeMap_AddPoint(*args)

    def Read(*args):
        """
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t weight_column=-1) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial) -> bool
        Read(self, string input_file) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere=Equatorial, 
            bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t weight_column=-1) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere=Equatorial, 
            bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere=Equatorial, 
            bool verbose=False, 
            uint8_t theta_column=0) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere=Equatorial, 
            bool verbose=False) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere=Equatorial) -> bool
        Read(self, string input_file, FieldColumnDict field_columns) -> bool
        """
        return _stomp.TreeMap_Read(*args)

    def Coverage(*args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.TreeMap_Coverage(*args)

    def Covering(*args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.TreeMap_Covering(*args)

    def FindUnmaskedFraction(*args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.TreeMap_FindUnmaskedFraction(*args)

    def FindUnmaskedStatus(*args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.TreeMap_FindUnmaskedStatus(*args)

    def NodeMap(*args):
        """NodeMap(self, Map stomp_map)"""
        return _stomp.TreeMap_NodeMap(*args)

    def Resolution(*args):
        """Resolution(self) -> uint32_t"""
        return _stomp.TreeMap_Resolution(*args)

    def PixelCapacity(*args):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.TreeMap_PixelCapacity(*args)

    def SetResolution(*args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.TreeMap_SetResolution(*args)

    def SetPixelCapacity(*args):
        """SetPixelCapacity(self, int pixel_capacity)"""
        return _stomp.TreeMap_SetPixelCapacity(*args)

    def NPoints(*args):
        """
        NPoints(self, uint32_t k=MaxPixnum) -> uint32_t
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.TreeMap_NPoints(*args)

    def Points(*args):
        """
        Points(self, WAngularVector w_ang)
        Points(self, WAngularVector w_ang, Pixel pix)
        """
        return _stomp.TreeMap_Points(*args)

    def Weight(*args):
        """
        Weight(self, uint32_t k=MaxPixnum) -> double
        Weight(self) -> double
        Weight(self, Pixel pix) -> double
        """
        return _stomp.TreeMap_Weight(*args)

    def FieldTotal(*args):
        """
        FieldTotal(self, string field_name, uint32_t k=MaxPixnum) -> double
        FieldTotal(self, string field_name) -> double
        FieldTotal(self, string field_name, Pixel pix) -> double
        """
        return _stomp.TreeMap_FieldTotal(*args)

    def NField(*args):
        """NField(self) -> uint16_t"""
        return _stomp.TreeMap_NField(*args)

    def HasFields(*args):
        """HasFields(self) -> bool"""
        return _stomp.TreeMap_HasFields(*args)

    def FieldNames(*args):
        """FieldNames(self, std::vector<(std::string,std::allocator<(std::string)>)> field_names)"""
        return _stomp.TreeMap_FieldNames(*args)

    def BaseNodes(*args):
        """BaseNodes(self) -> uint16_t"""
        return _stomp.TreeMap_BaseNodes(*args)

    def Nodes(*args):
        """Nodes(self) -> uint16_t"""
        return _stomp.TreeMap_Nodes(*args)

    def Size(*args):
        """Size(self) -> uint32_t"""
        return _stomp.TreeMap_Size(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.TreeMap_Area(*args)

    def CalculateArea(*args):
        """CalculateArea(self)"""
        return _stomp.TreeMap_CalculateArea(*args)

    def MinResolution(*args):
        """MinResolution(self) -> uint32_t"""
        return _stomp.TreeMap_MinResolution(*args)

    def MaxResolution(*args):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.TreeMap_MaxResolution(*args)

    def MinLevel(*args):
        """MinLevel(self) -> uint8_t"""
        return _stomp.TreeMap_MinLevel(*args)

    def MaxLevel(*args):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.TreeMap_MaxLevel(*args)

    def Empty(*args):
        """Empty(self) -> bool"""
        return _stomp.TreeMap_Empty(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.TreeMap_Clear(*args)

TreeMap_swigregister = _stomp.TreeMap_swigregister
TreeMap_swigregister(TreeMap)

class IndexedTreeMap(BaseMap):
    """Proxy of C++ IndexedTreeMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreeMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreeMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, uint32_t resolution=HPixResolution, uint16_t maximum_points=50) -> IndexedTreeMap
        __init__(self, uint32_t resolution=HPixResolution) -> IndexedTreeMap
        __init__(self) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, int8_t index_column=-1) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial, 
            bool verbose=False) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Sphere sphere=Equatorial) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution=HPixResolution) -> IndexedTreeMap
        __init__(self, string input_file) -> IndexedTreeMap
        """
        this = _stomp.new_IndexedTreeMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreeMap
    __del__ = lambda self : None;
    def FindPairs(*args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IAngularVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IndexVector pair_indices)
        """
        return _stomp.IndexedTreeMap_FindPairs(*args)

    def FindKNearestNeighbors(*args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, IAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.IndexedTreeMap_FindKNearestNeighbors(*args)

    def FindNearestNeighbor(*args):
        """FindNearestNeighbor(self, AngularCoordinate ang, IndexedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.IndexedTreeMap_FindNearestNeighbor(*args)

    def KNearestNeighborDistance(*args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreeMap_KNearestNeighborDistance(*args)

    def NearestNeighborDistance(*args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreeMap_NearestNeighborDistance(*args)

    def ClosestMatch(*args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, IndexedAngularCoordinate match_ang) -> bool"""
        return _stomp.IndexedTreeMap_ClosestMatch(*args)

    def AddPoint(*args):
        """
        AddPoint(self, IndexedAngularCoordinate i_ang) -> bool
        AddPoint(self, AngularCoordinate ang, uint32_t index) -> bool
        """
        return _stomp.IndexedTreeMap_AddPoint(*args)

    def Read(*args):
        """
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t index_column=-1) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial, bool verbose=False) -> bool
        Read(self, string input_file, Sphere sphere=Equatorial) -> bool
        Read(self, string input_file) -> bool
        """
        return _stomp.IndexedTreeMap_Read(*args)

    def Coverage(*args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution, 
            bool calculate_fraction=True)
        Coverage(self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.IndexedTreeMap_Coverage(*args)

    def Covering(*args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.IndexedTreeMap_Covering(*args)

    def FindUnmaskedFraction(*args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.IndexedTreeMap_FindUnmaskedFraction(*args)

    def FindUnmaskedStatus(*args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.IndexedTreeMap_FindUnmaskedStatus(*args)

    def NodeMap(*args):
        """NodeMap(self, Map stomp_map)"""
        return _stomp.IndexedTreeMap_NodeMap(*args)

    def Resolution(*args):
        """Resolution(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_Resolution(*args)

    def PixelCapacity(*args):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.IndexedTreeMap_PixelCapacity(*args)

    def SetResolution(*args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.IndexedTreeMap_SetResolution(*args)

    def SetPixelCapacity(*args):
        """SetPixelCapacity(self, int pixel_capacity)"""
        return _stomp.IndexedTreeMap_SetPixelCapacity(*args)

    def NPoints(*args):
        """
        NPoints(self, uint32_t k=MaxPixnum) -> uint32_t
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.IndexedTreeMap_NPoints(*args)

    def Points(*args):
        """
        Points(self, IAngularVector i_ang)
        Points(self, IAngularVector i_ang, Pixel pix)
        """
        return _stomp.IndexedTreeMap_Points(*args)

    def Indices(*args):
        """Indices(self, Pixel pix, IndexVector indices)"""
        return _stomp.IndexedTreeMap_Indices(*args)

    def BaseNodes(*args):
        """BaseNodes(self) -> uint16_t"""
        return _stomp.IndexedTreeMap_BaseNodes(*args)

    def Nodes(*args):
        """Nodes(self) -> uint16_t"""
        return _stomp.IndexedTreeMap_Nodes(*args)

    def Size(*args):
        """Size(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_Size(*args)

    def Area(*args):
        """Area(self) -> double"""
        return _stomp.IndexedTreeMap_Area(*args)

    def CalculateArea(*args):
        """CalculateArea(self)"""
        return _stomp.IndexedTreeMap_CalculateArea(*args)

    def MinResolution(*args):
        """MinResolution(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_MinResolution(*args)

    def MaxResolution(*args):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_MaxResolution(*args)

    def MinLevel(*args):
        """MinLevel(self) -> uint8_t"""
        return _stomp.IndexedTreeMap_MinLevel(*args)

    def MaxLevel(*args):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.IndexedTreeMap_MaxLevel(*args)

    def Empty(*args):
        """Empty(self) -> bool"""
        return _stomp.IndexedTreeMap_Empty(*args)

    def Clear(*args):
        """Clear(self)"""
        return _stomp.IndexedTreeMap_Clear(*args)

IndexedTreeMap_swigregister = _stomp.IndexedTreeMap_swigregister
IndexedTreeMap_swigregister(IndexedTreeMap)

class AngularVector(_object):
    """Proxy of C++ AngularVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.AngularVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.AngularVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.AngularVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.AngularVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> AngularVector"""
        return _stomp.AngularVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, AngularVector v)"""
        return _stomp.AngularVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.AngularVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.AngularVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.AngularVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.AngularVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.AngularVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.AngularVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.AngularVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.AngularVector_clear(*args)

    def swap(*args):
        """swap(self, AngularVector v)"""
        return _stomp.AngularVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.AngularVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.AngularVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.AngularVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.AngularVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.AngularVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.AngularVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.AngularVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> AngularVector
        __init__(self, AngularVector ?) -> AngularVector
        __init__(self, size_type size) -> AngularVector
        __init__(self, size_type size, value_type value) -> AngularVector
        """
        this = _stomp.new_AngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.AngularVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.AngularVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.AngularVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.AngularVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.AngularVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.AngularVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.AngularVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.AngularVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_AngularVector
    __del__ = lambda self : None;
AngularVector_swigregister = _stomp.AngularVector_swigregister
AngularVector_swigregister(AngularVector)

class ThetaVector(_object):
    """Proxy of C++ ThetaVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThetaVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThetaVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.ThetaVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.ThetaVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.ThetaVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.ThetaVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> ThetaVector"""
        return _stomp.ThetaVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, ThetaVector v)"""
        return _stomp.ThetaVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.ThetaVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.ThetaVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.ThetaVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.ThetaVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.ThetaVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.ThetaVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.ThetaVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.ThetaVector_clear(*args)

    def swap(*args):
        """swap(self, ThetaVector v)"""
        return _stomp.ThetaVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.ThetaVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.ThetaVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.ThetaVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.ThetaVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.ThetaVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.ThetaVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.ThetaVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> ThetaVector
        __init__(self, ThetaVector ?) -> ThetaVector
        __init__(self, size_type size) -> ThetaVector
        __init__(self, size_type size, value_type value) -> ThetaVector
        """
        this = _stomp.new_ThetaVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.ThetaVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.ThetaVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.ThetaVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.ThetaVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.ThetaVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.ThetaVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.ThetaVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.ThetaVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_ThetaVector
    __del__ = lambda self : None;
ThetaVector_swigregister = _stomp.ThetaVector_swigregister
ThetaVector_swigregister(ThetaVector)

class RadialVector(_object):
    """Proxy of C++ RadialVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadialVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.RadialVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.RadialVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.RadialVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.RadialVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> RadialVector"""
        return _stomp.RadialVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, RadialVector v)"""
        return _stomp.RadialVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.RadialVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.RadialVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.RadialVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.RadialVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.RadialVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.RadialVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.RadialVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.RadialVector_clear(*args)

    def swap(*args):
        """swap(self, RadialVector v)"""
        return _stomp.RadialVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.RadialVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.RadialVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.RadialVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.RadialVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.RadialVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.RadialVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.RadialVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> RadialVector
        __init__(self, RadialVector ?) -> RadialVector
        __init__(self, size_type size) -> RadialVector
        __init__(self, size_type size, value_type value) -> RadialVector
        """
        this = _stomp.new_RadialVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.RadialVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.RadialVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.RadialVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.RadialVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.RadialVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.RadialVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.RadialVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.RadialVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_RadialVector
    __del__ = lambda self : None;
RadialVector_swigregister = _stomp.RadialVector_swigregister
RadialVector_swigregister(RadialVector)

class WAngularVector(_object):
    """Proxy of C++ WAngularVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WAngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WAngularVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.WAngularVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.WAngularVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.WAngularVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.WAngularVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> WAngularVector"""
        return _stomp.WAngularVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, WAngularVector v)"""
        return _stomp.WAngularVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.WAngularVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.WAngularVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.WAngularVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.WAngularVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.WAngularVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.WAngularVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.WAngularVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.WAngularVector_clear(*args)

    def swap(*args):
        """swap(self, WAngularVector v)"""
        return _stomp.WAngularVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.WAngularVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.WAngularVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.WAngularVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.WAngularVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.WAngularVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.WAngularVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.WAngularVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> WAngularVector
        __init__(self, WAngularVector ?) -> WAngularVector
        __init__(self, size_type size) -> WAngularVector
        __init__(self, size_type size, value_type value) -> WAngularVector
        """
        this = _stomp.new_WAngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.WAngularVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.WAngularVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.WAngularVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.WAngularVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.WAngularVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.WAngularVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.WAngularVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.WAngularVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_WAngularVector
    __del__ = lambda self : None;
WAngularVector_swigregister = _stomp.WAngularVector_swigregister
WAngularVector_swigregister(WAngularVector)

class CosmoVector(_object):
    """Proxy of C++ CosmoVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosmoVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CosmoVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.CosmoVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.CosmoVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.CosmoVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.CosmoVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> CosmoVector"""
        return _stomp.CosmoVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, CosmoVector v)"""
        return _stomp.CosmoVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.CosmoVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.CosmoVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.CosmoVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.CosmoVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.CosmoVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.CosmoVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.CosmoVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.CosmoVector_clear(*args)

    def swap(*args):
        """swap(self, CosmoVector v)"""
        return _stomp.CosmoVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.CosmoVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.CosmoVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.CosmoVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.CosmoVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.CosmoVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.CosmoVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.CosmoVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> CosmoVector
        __init__(self, CosmoVector ?) -> CosmoVector
        __init__(self, size_type size) -> CosmoVector
        __init__(self, size_type size, value_type value) -> CosmoVector
        """
        this = _stomp.new_CosmoVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.CosmoVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.CosmoVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.CosmoVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.CosmoVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.CosmoVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.CosmoVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.CosmoVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.CosmoVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_CosmoVector
    __del__ = lambda self : None;
CosmoVector_swigregister = _stomp.CosmoVector_swigregister
CosmoVector_swigregister(CosmoVector)

class IAngularVector(_object):
    """Proxy of C++ IAngularVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAngularVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.IAngularVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.IAngularVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.IAngularVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.IAngularVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> IAngularVector"""
        return _stomp.IAngularVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, IAngularVector v)"""
        return _stomp.IAngularVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.IAngularVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.IAngularVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.IAngularVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.IAngularVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.IAngularVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.IAngularVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.IAngularVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.IAngularVector_clear(*args)

    def swap(*args):
        """swap(self, IAngularVector v)"""
        return _stomp.IAngularVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.IAngularVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.IAngularVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.IAngularVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.IAngularVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.IAngularVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.IAngularVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.IAngularVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IAngularVector
        __init__(self, IAngularVector ?) -> IAngularVector
        __init__(self, size_type size) -> IAngularVector
        __init__(self, size_type size, value_type value) -> IAngularVector
        """
        this = _stomp.new_IAngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.IAngularVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.IAngularVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.IAngularVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.IAngularVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.IAngularVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.IAngularVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.IAngularVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.IAngularVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_IAngularVector
    __del__ = lambda self : None;
IAngularVector_swigregister = _stomp.IAngularVector_swigregister
IAngularVector_swigregister(IAngularVector)

class PixelVector(_object):
    """Proxy of C++ PixelVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.PixelVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.PixelVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.PixelVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.PixelVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> PixelVector"""
        return _stomp.PixelVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, PixelVector v)"""
        return _stomp.PixelVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.PixelVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.PixelVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.PixelVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.PixelVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.PixelVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.PixelVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.PixelVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.PixelVector_clear(*args)

    def swap(*args):
        """swap(self, PixelVector v)"""
        return _stomp.PixelVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.PixelVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.PixelVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.PixelVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.PixelVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.PixelVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.PixelVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.PixelVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> PixelVector
        __init__(self, PixelVector ?) -> PixelVector
        __init__(self, size_type size) -> PixelVector
        __init__(self, size_type size, value_type value) -> PixelVector
        """
        this = _stomp.new_PixelVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.PixelVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.PixelVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.PixelVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.PixelVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.PixelVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.PixelVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.PixelVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.PixelVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_PixelVector
    __del__ = lambda self : None;
PixelVector_swigregister = _stomp.PixelVector_swigregister
PixelVector_swigregister(PixelVector)

class FieldDict(_object):
    """Proxy of C++ FieldDict class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FieldDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FieldDict, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.FieldDict_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.FieldDict___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.FieldDict___len__(*args)

    def __getitem__(*args):
        """__getitem__(self, key_type key) -> mapped_type"""
        return _stomp.FieldDict___getitem__(*args)

    def __delitem__(*args):
        """__delitem__(self, key_type key)"""
        return _stomp.FieldDict___delitem__(*args)

    def has_key(*args):
        """has_key(self, key_type key) -> bool"""
        return _stomp.FieldDict_has_key(*args)

    def keys(*args):
        """keys(self) -> PyObject"""
        return _stomp.FieldDict_keys(*args)

    def values(*args):
        """values(self) -> PyObject"""
        return _stomp.FieldDict_values(*args)

    def items(*args):
        """items(self) -> PyObject"""
        return _stomp.FieldDict_items(*args)

    def __contains__(*args):
        """__contains__(self, key_type key) -> bool"""
        return _stomp.FieldDict___contains__(*args)

    def key_iterator(*args):
        """key_iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.FieldDict_key_iterator(*args)

    def value_iterator(*args):
        """value_iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.FieldDict_value_iterator(*args)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __setitem__(*args):
        """__setitem__(self, key_type key, mapped_type x)"""
        return _stomp.FieldDict___setitem__(*args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> ?) -> FieldDict
        __init__(self) -> FieldDict
        __init__(self, FieldDict ?) -> FieldDict
        """
        this = _stomp.new_FieldDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.FieldDict_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.FieldDict_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.FieldDict_clear(*args)

    def swap(*args):
        """swap(self, FieldDict v)"""
        return _stomp.FieldDict_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.FieldDict_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.FieldDict_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.FieldDict_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.FieldDict_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.FieldDict_rend(*args)

    def count(*args):
        """count(self, key_type x) -> size_type"""
        return _stomp.FieldDict_count(*args)

    def erase(*args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator position)
        erase(self, iterator first, iterator last)
        """
        return _stomp.FieldDict_erase(*args)

    def find(*args):
        """find(self, key_type x) -> iterator"""
        return _stomp.FieldDict_find(*args)

    def lower_bound(*args):
        """lower_bound(self, key_type x) -> iterator"""
        return _stomp.FieldDict_lower_bound(*args)

    def upper_bound(*args):
        """upper_bound(self, key_type x) -> iterator"""
        return _stomp.FieldDict_upper_bound(*args)

    __swig_destroy__ = _stomp.delete_FieldDict
    __del__ = lambda self : None;
FieldDict_swigregister = _stomp.FieldDict_swigregister
FieldDict_swigregister(FieldDict)

class FieldColumnDict(_object):
    """Proxy of C++ FieldColumnDict class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FieldColumnDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FieldColumnDict, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.FieldColumnDict_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.FieldColumnDict___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::map<(std::string,unsigned char)>::size_type"""
        return _stomp.FieldColumnDict___len__(*args)

    def __getitem__(*args):
        """__getitem__(self, std::map<(std::string,unsigned char)>::key_type key) -> std::map<(std::string,unsigned char)>::mapped_type"""
        return _stomp.FieldColumnDict___getitem__(*args)

    def __delitem__(*args):
        """__delitem__(self, std::map<(std::string,unsigned char)>::key_type key)"""
        return _stomp.FieldColumnDict___delitem__(*args)

    def has_key(*args):
        """has_key(self, std::map<(std::string,unsigned char)>::key_type key) -> bool"""
        return _stomp.FieldColumnDict_has_key(*args)

    def keys(*args):
        """keys(self) -> PyObject"""
        return _stomp.FieldColumnDict_keys(*args)

    def values(*args):
        """values(self) -> PyObject"""
        return _stomp.FieldColumnDict_values(*args)

    def items(*args):
        """items(self) -> PyObject"""
        return _stomp.FieldColumnDict_items(*args)

    def __contains__(*args):
        """__contains__(self, std::map<(std::string,unsigned char)>::key_type key) -> bool"""
        return _stomp.FieldColumnDict___contains__(*args)

    def key_iterator(*args):
        """key_iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.FieldColumnDict_key_iterator(*args)

    def value_iterator(*args):
        """value_iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.FieldColumnDict_value_iterator(*args)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __setitem__(*args):
        """
        __setitem__(self, std::map<(std::string,unsigned char)>::key_type key, 
            std::map<(std::string,unsigned char)>::mapped_type x)
        """
        return _stomp.FieldColumnDict___setitem__(*args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> ?) -> FieldColumnDict
        __init__(self) -> FieldColumnDict
        __init__(self, FieldColumnDict ?) -> FieldColumnDict
        """
        this = _stomp.new_FieldColumnDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.FieldColumnDict_empty(*args)

    def size(*args):
        """size(self) -> std::map<(std::string,unsigned char)>::size_type"""
        return _stomp.FieldColumnDict_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.FieldColumnDict_clear(*args)

    def swap(*args):
        """swap(self, FieldColumnDict v)"""
        return _stomp.FieldColumnDict_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::map<(std::string,unsigned char)>::allocator_type"""
        return _stomp.FieldColumnDict_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::map<(std::string,unsigned char)>::const_iterator"""
        return _stomp.FieldColumnDict_begin(*args)

    def end(*args):
        """end(self) -> std::map<(std::string,unsigned char)>::const_iterator"""
        return _stomp.FieldColumnDict_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::map<(std::string,unsigned char)>::const_reverse_iterator"""
        return _stomp.FieldColumnDict_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::map<(std::string,unsigned char)>::const_reverse_iterator"""
        return _stomp.FieldColumnDict_rend(*args)

    def count(*args):
        """count(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::size_type"""
        return _stomp.FieldColumnDict_count(*args)

    def erase(*args):
        """
        erase(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::size_type
        erase(self, std::map<(std::string,unsigned char)>::iterator position)
        erase(self, std::map<(std::string,unsigned char)>::iterator first, 
            std::map<(std::string,unsigned char)>::iterator last)
        """
        return _stomp.FieldColumnDict_erase(*args)

    def find(*args):
        """find(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_find(*args)

    def lower_bound(*args):
        """lower_bound(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_lower_bound(*args)

    def upper_bound(*args):
        """upper_bound(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_upper_bound(*args)

    __swig_destroy__ = _stomp.delete_FieldColumnDict
    __del__ = lambda self : None;
FieldColumnDict_swigregister = _stomp.FieldColumnDict_swigregister
FieldColumnDict_swigregister(FieldColumnDict)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _stomp.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _stomp.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> DoubleVector"""
        return _stomp.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, DoubleVector v)"""
        return _stomp.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _stomp.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _stomp.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _stomp.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _stomp.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _stomp.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, DoubleVector v)"""
        return _stomp.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _stomp.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _stomp.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _stomp.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _stomp.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _stomp.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, DoubleVector ?) -> DoubleVector
        __init__(self, size_type size) -> DoubleVector
        __init__(self, size_type size, value_type value) -> DoubleVector
        """
        this = _stomp.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _stomp.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _stomp.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _stomp.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _stomp.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _stomp.DoubleVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _stomp.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class IndexVector(_object):
    """Proxy of C++ IndexVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _stomp.IndexVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _stomp.IndexVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(unsigned int)>::size_type"""
        return _stomp.IndexVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j) -> IndexVector"""
        return _stomp.IndexVector___getslice__(*args)

    def __setslice__(*args):
        """
        __setslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j, 
            IndexVector v)
        """
        return _stomp.IndexVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j)"""
        return _stomp.IndexVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, std::vector<(unsigned int)>::difference_type i)"""
        return _stomp.IndexVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, std::vector<(unsigned int)>::difference_type i) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector___setitem__(*args)

    def append(*args):
        """append(self, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _stomp.IndexVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(unsigned int)>::size_type"""
        return _stomp.IndexVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _stomp.IndexVector_clear(*args)

    def swap(*args):
        """swap(self, IndexVector v)"""
        return _stomp.IndexVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(unsigned int)>::allocator_type"""
        return _stomp.IndexVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(unsigned int)>::const_iterator"""
        return _stomp.IndexVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(unsigned int)>::const_iterator"""
        return _stomp.IndexVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(unsigned int)>::const_reverse_iterator"""
        return _stomp.IndexVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(unsigned int)>::const_reverse_iterator"""
        return _stomp.IndexVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _stomp.IndexVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, std::vector<(unsigned int)>::iterator pos) -> std::vector<(unsigned int)>::iterator
        erase(self, std::vector<(unsigned int)>::iterator first, std::vector<(unsigned int)>::iterator last) -> std::vector<(unsigned int)>::iterator
        """
        return _stomp.IndexVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IndexVector
        __init__(self, IndexVector ?) -> IndexVector
        __init__(self, std::vector<(unsigned int)>::size_type size) -> IndexVector
        __init__(self, std::vector<(unsigned int)>::size_type size, std::vector<(unsigned int)>::value_type value) -> IndexVector
        """
        this = _stomp.new_IndexVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector_back(*args)

    def assign(*args):
        """assign(self, std::vector<(unsigned int)>::size_type n, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector_assign(*args)

    def resize(*args):
        """
        resize(self, std::vector<(unsigned int)>::size_type new_size)
        resize(self, std::vector<(unsigned int)>::size_type new_size, std::vector<(unsigned int)>::value_type x)
        """
        return _stomp.IndexVector_resize(*args)

    def insert(*args):
        """
        insert(self, std::vector<(unsigned int)>::iterator pos, std::vector<(unsigned int)>::value_type x) -> std::vector<(unsigned int)>::iterator
        insert(self, std::vector<(unsigned int)>::iterator pos, std::vector<(unsigned int)>::size_type n, 
            std::vector<(unsigned int)>::value_type x)
        """
        return _stomp.IndexVector_insert(*args)

    def reserve(*args):
        """reserve(self, std::vector<(unsigned int)>::size_type n)"""
        return _stomp.IndexVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(unsigned int)>::size_type"""
        return _stomp.IndexVector_capacity(*args)

    __swig_destroy__ = _stomp.delete_IndexVector
    __del__ = lambda self : None;
IndexVector_swigregister = _stomp.IndexVector_swigregister
IndexVector_swigregister(IndexVector)



def _iter_incr(*args):
  """
    _iter_incr(std::vector<(Stomp::AngularBin,std::allocator<(Stomp::AngularBin)>)>::const_iterator iter)
    _iter_incr(std::vector<(Stomp::HistogramBin,std::allocator<(Stomp::HistogramBin)>)>::const_iterator iter)
    """
  return _stomp._iter_incr(*args)

