# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_stomp', [dirname(__file__)])
        except ImportError:
            import _stomp
            return _stomp
        if fp is not None:
            try:
                _mod = imp.load_module('_stomp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _stomp = swig_import_helper()
    del swig_import_helper
else:
    import _stomp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _stomp.SwigPyIterator_value(self)

    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _stomp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _stomp.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _stomp.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _stomp.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _stomp.SwigPyIterator_copy(self)

    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _stomp.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _stomp.SwigPyIterator___next__(self)

    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _stomp.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _stomp.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _stomp.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _stomp.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _stomp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class GenericIterator:
    def __init__(self, begin_iter_method, deref_method, incr_method):
        self.it = begin_iter_method()
        self.incr   = incr_method
        self.deref  = deref_method

    def __iter__(self):
        return self

    def next(self):
        obj = self.deref( self.it )
        if obj is not None:
            self.incr( self.it )
            return obj
        else:
            raise StopIteration


def DoubleLT(*args):
  """DoubleLT(double a, double b) -> bool"""
  return _stomp.DoubleLT(*args)

def DoubleLE(*args):
  """DoubleLE(double a, double b) -> bool"""
  return _stomp.DoubleLE(*args)

def DoubleGT(*args):
  """DoubleGT(double a, double b) -> bool"""
  return _stomp.DoubleGT(*args)

def DoubleGE(*args):
  """DoubleGE(double a, double b) -> bool"""
  return _stomp.DoubleGE(*args)

def DoubleEQ(*args):
  """DoubleEQ(double a, double b) -> bool"""
  return _stomp.DoubleEQ(*args)

def MostSignificantBit(*args):
  """MostSignificantBit(uint32_t input_int) -> uint8_t"""
  return _stomp.MostSignificantBit(*args)
class AngularBin(_object):
    """Proxy of C++ Stomp::AngularBin class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularBin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularBin, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_AngularBin
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(Stomp::AngularBin self) -> AngularBin
        __init__(Stomp::AngularBin self, double theta_min, double theta_max) -> AngularBin
        __init__(Stomp::AngularBin self, double theta_min, double theta_max, int16_t n_regions) -> AngularBin
        """
        this = _stomp.new_AngularBin(*args)
        try: self.this.append(this)
        except: self.this = this
    def ClearRegions(self):
        """ClearRegions(AngularBin self)"""
        return _stomp.AngularBin_ClearRegions(self)

    def InitializeRegions(self, *args):
        """InitializeRegions(AngularBin self, int16_t n_regions)"""
        return _stomp.AngularBin_InitializeRegions(self, *args)

    def SetResolution(self, *args):
        """SetResolution(AngularBin self, uint32_t resolution)"""
        return _stomp.AngularBin_SetResolution(self, *args)

    def CalculateResolution(self, *args):
        """
        CalculateResolution(AngularBin self, double lammin=-70.0, double lammax=70.0, uint32_t max_resolution=MaxPixelResolution)
        CalculateResolution(AngularBin self, double lammin=-70.0, double lammax=70.0)
        CalculateResolution(AngularBin self, double lammin=-70.0)
        CalculateResolution(AngularBin self)
        """
        return _stomp.AngularBin_CalculateResolution(self, *args)

    def SetThetaMin(self, *args):
        """SetThetaMin(AngularBin self, double theta_min)"""
        return _stomp.AngularBin_SetThetaMin(self, *args)

    def SetThetaMax(self, *args):
        """SetThetaMax(AngularBin self, double theta_max)"""
        return _stomp.AngularBin_SetThetaMax(self, *args)

    def SetTheta(self, *args):
        """SetTheta(AngularBin self, double theta)"""
        return _stomp.AngularBin_SetTheta(self, *args)

    def WithinBounds(self, *args):
        """WithinBounds(AngularBin self, double theta) -> bool"""
        return _stomp.AngularBin_WithinBounds(self, *args)

    def WithinSin2Bounds(self, *args):
        """WithinSin2Bounds(AngularBin self, double sin2theta) -> bool"""
        return _stomp.AngularBin_WithinSin2Bounds(self, *args)

    def WithinCosBounds(self, *args):
        """WithinCosBounds(AngularBin self, double costheta) -> bool"""
        return _stomp.AngularBin_WithinCosBounds(self, *args)

    def Area(self):
        """Area(AngularBin self) -> double"""
        return _stomp.AngularBin_Area(self)

    def PoissonNoise(self, *args):
        """PoissonNoise(AngularBin self, double objects_per_square_degree, double survey_area) -> double"""
        return _stomp.AngularBin_PoissonNoise(self, *args)

    def AddToPixelWtheta(self, *args):
        """
        AddToPixelWtheta(AngularBin self, double dwtheta, double dweight, int16_t region_a=-1, int16_t region_b=-1)
        AddToPixelWtheta(AngularBin self, double dwtheta, double dweight, int16_t region_a=-1)
        AddToPixelWtheta(AngularBin self, double dwtheta, double dweight)
        """
        return _stomp.AngularBin_AddToPixelWtheta(self, *args)

    def AddToWeight(self, *args):
        """
        AddToWeight(AngularBin self, double weight, int16_t region=-1)
        AddToWeight(AngularBin self, double weight)
        """
        return _stomp.AngularBin_AddToWeight(self, *args)

    def AddToCounter(self, *args):
        """
        AddToCounter(AngularBin self, uint32_t step=1, int16_t region=-1)
        AddToCounter(AngularBin self, uint32_t step=1)
        AddToCounter(AngularBin self)
        """
        return _stomp.AngularBin_AddToCounter(self, *args)

    def MoveWeightToGalGal(self):
        """MoveWeightToGalGal(AngularBin self)"""
        return _stomp.AngularBin_MoveWeightToGalGal(self)

    def MoveWeightToGalRand(self, move_to_rand_gal=False):
        """
        MoveWeightToGalRand(AngularBin self, bool move_to_rand_gal=False)
        MoveWeightToGalRand(AngularBin self)
        """
        return _stomp.AngularBin_MoveWeightToGalRand(self, move_to_rand_gal)

    def MoveWeightToRandGal(self, move_to_gal_rand=False):
        """
        MoveWeightToRandGal(AngularBin self, bool move_to_gal_rand=False)
        MoveWeightToRandGal(AngularBin self)
        """
        return _stomp.AngularBin_MoveWeightToRandGal(self, move_to_gal_rand)

    def MoveWeightToRandRand(self):
        """MoveWeightToRandRand(AngularBin self)"""
        return _stomp.AngularBin_MoveWeightToRandRand(self)

    def RescaleGalGal(self, *args):
        """RescaleGalGal(AngularBin self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleGalGal(self, *args)

    def RescaleGalRand(self, *args):
        """RescaleGalRand(AngularBin self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleGalRand(self, *args)

    def RescaleRandGal(self, *args):
        """RescaleRandGal(AngularBin self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleRandGal(self, *args)

    def RescaleRandRand(self, *args):
        """RescaleRandRand(AngularBin self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleRandRand(self, *args)

    def Reset(self):
        """Reset(AngularBin self)"""
        return _stomp.AngularBin_Reset(self)

    def ResetPixelWtheta(self):
        """ResetPixelWtheta(AngularBin self)"""
        return _stomp.AngularBin_ResetPixelWtheta(self)

    def ResetWeight(self):
        """ResetWeight(AngularBin self)"""
        return _stomp.AngularBin_ResetWeight(self)

    def ResetCounter(self):
        """ResetCounter(AngularBin self)"""
        return _stomp.AngularBin_ResetCounter(self)

    def ResetGalGal(self):
        """ResetGalGal(AngularBin self)"""
        return _stomp.AngularBin_ResetGalGal(self)

    def ResetGalRand(self):
        """ResetGalRand(AngularBin self)"""
        return _stomp.AngularBin_ResetGalRand(self)

    def ResetRandGal(self):
        """ResetRandGal(AngularBin self)"""
        return _stomp.AngularBin_ResetRandGal(self)

    def ResetRandRand(self):
        """ResetRandRand(AngularBin self)"""
        return _stomp.AngularBin_ResetRandRand(self)

    def Resolution(self):
        """Resolution(AngularBin self) -> uint32_t"""
        return _stomp.AngularBin_Resolution(self)

    def NRegion(self):
        """NRegion(AngularBin self) -> int16_t"""
        return _stomp.AngularBin_NRegion(self)

    def Theta(self):
        """Theta(AngularBin self) -> double"""
        return _stomp.AngularBin_Theta(self)

    def ThetaMin(self):
        """ThetaMin(AngularBin self) -> double"""
        return _stomp.AngularBin_ThetaMin(self)

    def ThetaMax(self):
        """ThetaMax(AngularBin self) -> double"""
        return _stomp.AngularBin_ThetaMax(self)

    def Sin2ThetaMin(self):
        """Sin2ThetaMin(AngularBin self) -> double"""
        return _stomp.AngularBin_Sin2ThetaMin(self)

    def Sin2ThetaMax(self):
        """Sin2ThetaMax(AngularBin self) -> double"""
        return _stomp.AngularBin_Sin2ThetaMax(self)

    def CosThetaMin(self):
        """CosThetaMin(AngularBin self) -> double"""
        return _stomp.AngularBin_CosThetaMin(self)

    def CosThetaMax(self):
        """CosThetaMax(AngularBin self) -> double"""
        return _stomp.AngularBin_CosThetaMax(self)

    def Wtheta(self, *args):
        """
        Wtheta(AngularBin self, int16_t region=-1) -> double
        Wtheta(AngularBin self) -> double
        """
        return _stomp.AngularBin_Wtheta(self, *args)

    def WthetaError(self, *args):
        """
        WthetaError(AngularBin self, int16_t region=-1) -> double
        WthetaError(AngularBin self) -> double
        """
        return _stomp.AngularBin_WthetaError(self, *args)

    def WeightedCrossCorrelation(self, *args):
        """
        WeightedCrossCorrelation(AngularBin self, int16_t region=-1) -> double
        WeightedCrossCorrelation(AngularBin self) -> double
        """
        return _stomp.AngularBin_WeightedCrossCorrelation(self, *args)

    def PixelWtheta(self, *args):
        """
        PixelWtheta(AngularBin self, int16_t region=-1) -> double
        PixelWtheta(AngularBin self) -> double
        """
        return _stomp.AngularBin_PixelWtheta(self, *args)

    def PixelWeight(self, *args):
        """
        PixelWeight(AngularBin self, int16_t region=-1) -> double
        PixelWeight(AngularBin self) -> double
        """
        return _stomp.AngularBin_PixelWeight(self, *args)

    def Weight(self, *args):
        """
        Weight(AngularBin self, int16_t region=-1) -> double
        Weight(AngularBin self) -> double
        """
        return _stomp.AngularBin_Weight(self, *args)

    def Counter(self, *args):
        """
        Counter(AngularBin self, int16_t region=-1) -> uint32_t
        Counter(AngularBin self) -> uint32_t
        """
        return _stomp.AngularBin_Counter(self, *args)

    def GalGal(self, *args):
        """
        GalGal(AngularBin self, int16_t region=-1) -> double
        GalGal(AngularBin self) -> double
        """
        return _stomp.AngularBin_GalGal(self, *args)

    def GalRand(self, *args):
        """
        GalRand(AngularBin self, int16_t region=-1) -> double
        GalRand(AngularBin self) -> double
        """
        return _stomp.AngularBin_GalRand(self, *args)

    def RandGal(self, *args):
        """
        RandGal(AngularBin self, int16_t region=-1) -> double
        RandGal(AngularBin self) -> double
        """
        return _stomp.AngularBin_RandGal(self, *args)

    def RandRand(self, *args):
        """
        RandRand(AngularBin self, int16_t region=-1) -> double
        RandRand(AngularBin self) -> double
        """
        return _stomp.AngularBin_RandRand(self, *args)

    def MeanWtheta(self):
        """MeanWtheta(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanWtheta(self)

    def MeanWthetaError(self):
        """MeanWthetaError(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanWthetaError(self)

    def MeanWeightedCrossCorrelation(self):
        """MeanWeightedCrossCorrelation(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanWeightedCrossCorrelation(self)

    def MeanWeightedCrossCorrelationError(self):
        """MeanWeightedCrossCorrelationError(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanWeightedCrossCorrelationError(self)

    def MeanWeight(self):
        """MeanWeight(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanWeight(self)

    def MeanCounter(self):
        """MeanCounter(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanCounter(self)

    def MeanGalGal(self):
        """MeanGalGal(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanGalGal(self)

    def MeanGalRand(self):
        """MeanGalRand(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanGalRand(self)

    def MeanRandGal(self):
        """MeanRandGal(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanRandGal(self)

    def MeanRandRand(self):
        """MeanRandRand(AngularBin self) -> double"""
        return _stomp.AngularBin_MeanRandRand(self)

    def ThetaOrder(*args):
        """ThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_ThetaOrder(*args)

    if _newclass:ThetaOrder = staticmethod(ThetaOrder)
    __swig_getmethods__["ThetaOrder"] = lambda x: ThetaOrder
    def SinThetaOrder(*args):
        """SinThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_SinThetaOrder(*args)

    if _newclass:SinThetaOrder = staticmethod(SinThetaOrder)
    __swig_getmethods__["SinThetaOrder"] = lambda x: SinThetaOrder
    def ReverseResolutionOrder(*args):
        """ReverseResolutionOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_ReverseResolutionOrder(*args)

    if _newclass:ReverseResolutionOrder = staticmethod(ReverseResolutionOrder)
    __swig_getmethods__["ReverseResolutionOrder"] = lambda x: ReverseResolutionOrder
AngularBin_swigregister = _stomp.AngularBin_swigregister
AngularBin_swigregister(AngularBin)
cvar = _stomp.cvar
Pi = cvar.Pi
DegToRad = cvar.DegToRad
RadToDeg = cvar.RadToDeg
StradToDeg = cvar.StradToDeg
EtaOffSet = cvar.EtaOffSet
SurveyCenterRA = cvar.SurveyCenterRA
SurveyCenterDEC = cvar.SurveyCenterDEC
Node = cvar.Node
EtaPole = cvar.EtaPole
Nx0 = cvar.Nx0
Ny0 = cvar.Ny0
HPixLevel = cvar.HPixLevel
MaxPixelLevel = cvar.MaxPixelLevel
HPixResolution = cvar.HPixResolution
MaxPixelResolution = cvar.MaxPixelResolution
ResolutionLevels = cvar.ResolutionLevels
HPixArea = cvar.HPixArea
MaxPixnum = cvar.MaxPixnum
MaxSuperpixnum = cvar.MaxSuperpixnum

def AngularBin_ThetaOrder(*args):
  """AngularBin_ThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_ThetaOrder(*args)

def AngularBin_SinThetaOrder(*args):
  """AngularBin_SinThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_SinThetaOrder(*args)

def AngularBin_ReverseResolutionOrder(*args):
  """AngularBin_ReverseResolutionOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_ReverseResolutionOrder(*args)

class RadialBin(AngularBin):
    """Proxy of C++ Stomp::RadialBin class"""
    __swig_setmethods__ = {}
    for _s in [AngularBin]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialBin, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularBin]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialBin, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_RadialBin
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(Stomp::RadialBin self) -> RadialBin
        __init__(Stomp::RadialBin self, double r_min, double r_max, double redshift) -> RadialBin
        __init__(Stomp::RadialBin self, double r_min, double r_max, double redshift, int16_t n_regions) -> RadialBin
        """
        this = _stomp.new_RadialBin(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetRadiusMin(self, *args):
        """SetRadiusMin(RadialBin self, double r_min)"""
        return _stomp.RadialBin_SetRadiusMin(self, *args)

    def SetRadiusMax(self, *args):
        """SetRadiusMax(RadialBin self, double r_max)"""
        return _stomp.RadialBin_SetRadiusMax(self, *args)

    def SetRadius(self, *args):
        """SetRadius(RadialBin self, double r)"""
        return _stomp.RadialBin_SetRadius(self, *args)

    def SetRedshift(self, *args):
        """SetRedshift(RadialBin self, double z)"""
        return _stomp.RadialBin_SetRedshift(self, *args)

    def WithinRadialBounds(self, *args):
        """WithinRadialBounds(RadialBin self, double r) -> bool"""
        return _stomp.RadialBin_WithinRadialBounds(self, *args)

    def Radius(self):
        """Radius(RadialBin self) -> double"""
        return _stomp.RadialBin_Radius(self)

    def RadiusMin(self):
        """RadiusMin(RadialBin self) -> double"""
        return _stomp.RadialBin_RadiusMin(self)

    def RadiusMax(self):
        """RadiusMax(RadialBin self) -> double"""
        return _stomp.RadialBin_RadiusMax(self)

    def Redshift(self):
        """Redshift(RadialBin self) -> double"""
        return _stomp.RadialBin_Redshift(self)

    def RadialOrder(*args):
        """RadialOrder(RadialBin r_a, RadialBin r_b) -> bool"""
        return _stomp.RadialBin_RadialOrder(*args)

    if _newclass:RadialOrder = staticmethod(RadialOrder)
    __swig_getmethods__["RadialOrder"] = lambda x: RadialOrder
    def ReverseResolutionOrder(*args):
        """ReverseResolutionOrder(RadialBin r_a, RadialBin r_b) -> bool"""
        return _stomp.RadialBin_ReverseResolutionOrder(*args)

    if _newclass:ReverseResolutionOrder = staticmethod(ReverseResolutionOrder)
    __swig_getmethods__["ReverseResolutionOrder"] = lambda x: ReverseResolutionOrder
RadialBin_swigregister = _stomp.RadialBin_swigregister
RadialBin_swigregister(RadialBin)

def RadialBin_RadialOrder(*args):
  """RadialBin_RadialOrder(RadialBin r_a, RadialBin r_b) -> bool"""
  return _stomp.RadialBin_RadialOrder(*args)

def RadialBin_ReverseResolutionOrder(*args):
  """RadialBin_ReverseResolutionOrder(RadialBin r_a, RadialBin r_b) -> bool"""
  return _stomp.RadialBin_ReverseResolutionOrder(*args)

class AngularCorrelation(_object):
    """Proxy of C++ Stomp::AngularCorrelation class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularCorrelation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularCorrelation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::AngularCorrelation self) -> AngularCorrelation
        __init__(Stomp::AngularCorrelation self, double theta_min, double theta_max, double bins_per_decade, bool assign_resolutions=True) -> AngularCorrelation
        __init__(Stomp::AngularCorrelation self, double theta_min, double theta_max, double bins_per_decade) -> AngularCorrelation
        __init__(Stomp::AngularCorrelation self, uint32_t n_bins, double theta_min, double theta_max, bool assign_resolutions=True) -> AngularCorrelation
        __init__(Stomp::AngularCorrelation self, uint32_t n_bins, double theta_min, double theta_max) -> AngularCorrelation
        """
        this = _stomp.new_AngularCorrelation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AngularCorrelation
    __del__ = lambda self : None;
    def AssignBinResolutions(self, *args):
        """
        AssignBinResolutions(AngularCorrelation self, double lammin=-70.0, double lammax=70.0, uint32_t max_resolution=MaxPixelResolution)
        AssignBinResolutions(AngularCorrelation self, double lammin=-70.0, double lammax=70.0)
        AssignBinResolutions(AngularCorrelation self, double lammin=-70.0)
        AssignBinResolutions(AngularCorrelation self)
        """
        return _stomp.AngularCorrelation_AssignBinResolutions(self, *args)

    def SetMaxResolution(self, *args):
        """
        SetMaxResolution(AngularCorrelation self, uint32_t resolution, bool manual_break=True)
        SetMaxResolution(AngularCorrelation self, uint32_t resolution)
        """
        return _stomp.AngularCorrelation_SetMaxResolution(self, *args)

    def SetMinResolution(self, *args):
        """SetMinResolution(AngularCorrelation self, uint32_t resolution)"""
        return _stomp.AngularCorrelation_SetMinResolution(self, *args)

    def AutoMaxResolution(self, *args):
        """AutoMaxResolution(AngularCorrelation self, uint32_t n_obj, double area)"""
        return _stomp.AngularCorrelation_AutoMaxResolution(self, *args)

    def InitializeRegions(self, *args):
        """InitializeRegions(AngularCorrelation self, int16_t n_regions)"""
        return _stomp.AngularCorrelation_InitializeRegions(self, *args)

    def ClearRegions(self):
        """ClearRegions(AngularCorrelation self)"""
        return _stomp.AngularCorrelation_ClearRegions(self)

    def NRegion(self):
        """NRegion(AngularCorrelation self) -> int16_t"""
        return _stomp.AngularCorrelation_NRegion(self)

    def FindAutoCorrelation(self, *args):
        """
        FindAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1, bool use_weighted_randoms=False)
        FindAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1)
        FindAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindAutoCorrelation(self, *args)

    def FindCrossCorrelation(self, *args):
        """
        FindCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1, bool use_weighted_randoms=False)
        FindCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1)
        FindCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindCrossCorrelation(self, *args)

    def FindAutoCorrelationWithRegions(self, *args):
        """
        FindAutoCorrelationWithRegions(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1, uint16_t n_regions=0, 
            bool use_weighted_randoms=False)
        FindAutoCorrelationWithRegions(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1, uint16_t n_regions=0)
        FindAutoCorrelationWithRegions(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1)
        FindAutoCorrelationWithRegions(AngularCorrelation self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindAutoCorrelationWithRegions(self, *args)

    def FindCrossCorrelationWithRegions(self, *args):
        """
        FindCrossCorrelationWithRegions(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1, uint16_t n_regions=0, bool use_weighted_randoms=False)
        FindCrossCorrelationWithRegions(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1, uint16_t n_regions=0)
        FindCrossCorrelationWithRegions(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1)
        FindCrossCorrelationWithRegions(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindCrossCorrelationWithRegions(self, *args)

    def FindPixelAutoCorrelation(self, *args):
        """
        FindPixelAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, bool use_weighted_randoms=False)
        FindPixelAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy)
        FindPixelAutoCorrelation(AngularCorrelation self, ScalarMap stomp_map)
        """
        return _stomp.AngularCorrelation_FindPixelAutoCorrelation(self, *args)

    def FindPixelCrossCorrelation(self, *args):
        """
        FindPixelCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            bool use_weighted_randoms=False)
        FindPixelCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b)
        FindPixelCrossCorrelation(AngularCorrelation self, ScalarMap stomp_map_a, ScalarMap stomp_map_b)
        """
        return _stomp.AngularCorrelation_FindPixelCrossCorrelation(self, *args)

    def FindPairAutoCorrelation(self, *args):
        """
        FindPairAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1, bool use_weighted_randoms=False)
        FindPairAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations=1)
        FindPairAutoCorrelation(AngularCorrelation self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindPairAutoCorrelation(self, *args)

    def FindPairCrossCorrelation(self, *args):
        """
        FindPairCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1, bool use_weighted_randoms=False)
        FindPairCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations=1)
        FindPairCrossCorrelation(AngularCorrelation self, Map stomp_map_a, Map stomp_map_b, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindPairCrossCorrelation(self, *args)

    def Write(self, *args):
        """Write(AngularCorrelation self, std::string const & output_file_name) -> bool"""
        return _stomp.AngularCorrelation_Write(self, *args)

    def UseOnlyPixels(self):
        """UseOnlyPixels(AngularCorrelation self)"""
        return _stomp.AngularCorrelation_UseOnlyPixels(self)

    def UseOnlyPairs(self):
        """UseOnlyPairs(AngularCorrelation self)"""
        return _stomp.AngularCorrelation_UseOnlyPairs(self)

    def ThetaMin(self, resolution=1):
        """
        ThetaMin(AngularCorrelation self, uint32_t resolution=1) -> double
        ThetaMin(AngularCorrelation self) -> double
        """
        return _stomp.AngularCorrelation_ThetaMin(self, resolution)

    def ThetaMax(self, resolution=1):
        """
        ThetaMax(AngularCorrelation self, uint32_t resolution=1) -> double
        ThetaMax(AngularCorrelation self) -> double
        """
        return _stomp.AngularCorrelation_ThetaMax(self, resolution)

    def Sin2ThetaMin(self, resolution=1):
        """
        Sin2ThetaMin(AngularCorrelation self, uint32_t resolution=1) -> double
        Sin2ThetaMin(AngularCorrelation self) -> double
        """
        return _stomp.AngularCorrelation_Sin2ThetaMin(self, resolution)

    def Sin2ThetaMax(self, resolution=1):
        """
        Sin2ThetaMax(AngularCorrelation self, uint32_t resolution=1) -> double
        Sin2ThetaMax(AngularCorrelation self) -> double
        """
        return _stomp.AngularCorrelation_Sin2ThetaMax(self, resolution)

    def Begin(self, resolution=1):
        """
        Begin(AngularCorrelation self, uint32_t resolution=1) -> Stomp::ThetaIterator
        Begin(AngularCorrelation self) -> Stomp::ThetaIterator
        """
        return _stomp.AngularCorrelation_Begin(self, resolution)

    def End(self, resolution=1):
        """
        End(AngularCorrelation self, uint32_t resolution=1) -> Stomp::ThetaIterator
        End(AngularCorrelation self) -> Stomp::ThetaIterator
        """
        return _stomp.AngularCorrelation_End(self, resolution)

    def Find(self, *args):
        """Find(AngularCorrelation self, Stomp::ThetaIterator begin, Stomp::ThetaIterator end, double sin2theta) -> Stomp::ThetaIterator"""
        return _stomp.AngularCorrelation_Find(self, *args)

    def BinIterator(self, bin_idx=0):
        """
        BinIterator(AngularCorrelation self, uint8_t bin_idx=0) -> Stomp::ThetaIterator
        BinIterator(AngularCorrelation self) -> Stomp::ThetaIterator
        """
        return _stomp.AngularCorrelation_BinIterator(self, bin_idx)

    def NBins(self):
        """NBins(AngularCorrelation self) -> uint32_t"""
        return _stomp.AngularCorrelation_NBins(self)

    def MinResolution(self):
        """MinResolution(AngularCorrelation self) -> uint32_t"""
        return _stomp.AngularCorrelation_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(AngularCorrelation self) -> uint32_t"""
        return _stomp.AngularCorrelation_MaxResolution(self)

    def Covariance(self, *args):
        """Covariance(AngularCorrelation self, uint8_t bin_idx_a, uint8_t bin_idx_b) -> double"""
        return _stomp.AngularCorrelation_Covariance(self, *args)

    def WriteCovariance(self, *args):
        """WriteCovariance(AngularCorrelation self, std::string const & output_file_name) -> bool"""
        return _stomp.AngularCorrelation_WriteCovariance(self, *args)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(self):
        """_begin_Bins(AngularCorrelation self) -> std::vector< Stomp::AngularBin,std::allocator< Stomp::AngularBin > >::const_iterator *"""
        return _stomp.AngularCorrelation__begin_Bins(self)

    def _deref_Bins(self, *args):
        """_deref_Bins(AngularCorrelation self, std::vector< Stomp::AngularBin,std::allocator< Stomp::AngularBin > >::const_iterator const * iter) -> AngularBin"""
        return _stomp.AngularCorrelation__deref_Bins(self, *args)

AngularCorrelation_swigregister = _stomp.AngularCorrelation_swigregister
AngularCorrelation_swigregister(AngularCorrelation)

class RadialCorrelation(AngularCorrelation):
    """Proxy of C++ Stomp::RadialCorrelation class"""
    __swig_setmethods__ = {}
    for _s in [AngularCorrelation]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialCorrelation, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCorrelation]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialCorrelation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::RadialCorrelation self, double radius_min, double radius_max, double bins_per_decade) -> RadialCorrelation
        __init__(Stomp::RadialCorrelation self, uint32_t n_bins, double radius_min, double radius_max) -> RadialCorrelation
        """
        this = _stomp.new_RadialCorrelation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RadialCorrelation
    __del__ = lambda self : None;
    def InitializeRegions(self, *args):
        """InitializeRegions(RadialCorrelation self, int16_t n_regions)"""
        return _stomp.RadialCorrelation_InitializeRegions(self, *args)

    def ClearRegions(self):
        """ClearRegions(RadialCorrelation self)"""
        return _stomp.RadialCorrelation_ClearRegions(self)

    def NRegion(self):
        """NRegion(RadialCorrelation self) -> int16_t"""
        return _stomp.RadialCorrelation_NRegion(self)

    def FindAutoCorrelation(self, *args):
        """
        FindAutoCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1, bool use_weighted_randoms=False)
        FindAutoCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1)
        FindAutoCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy)
        """
        return _stomp.RadialCorrelation_FindAutoCorrelation(self, *args)

    def FindCrossCorrelation(self, *args):
        """
        FindCrossCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1, 
            bool use_weighted_randoms=False)
        FindCrossCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1)
        FindCrossCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w)
        """
        return _stomp.RadialCorrelation_FindCrossCorrelation(self, *args)

    def FindAutoCorrelationWithRegions(self, *args):
        """
        FindAutoCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1, uint16_t n_regions=0, 
            bool use_weighted_randoms=False)
        FindAutoCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1, uint16_t n_regions=0)
        FindAutoCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1)
        FindAutoCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy)
        """
        return _stomp.RadialCorrelation_FindAutoCorrelationWithRegions(self, *args)

    def FindCrossCorrelationWithRegions(self, *args):
        """
        FindCrossCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1, 
            uint16_t n_regions=0, bool use_weighted_randoms=False)
        FindCrossCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1, 
            uint16_t n_regions=0)
        FindCrossCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1)
        FindCrossCorrelationWithRegions(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w)
        """
        return _stomp.RadialCorrelation_FindCrossCorrelationWithRegions(self, *args)

    def FindPairAutoCorrelation(self, *args):
        """
        FindPairAutoCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1, bool use_weighted_randoms=False)
        FindPairAutoCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy, uint8_t random_iterations=1)
        FindPairAutoCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy)
        """
        return _stomp.RadialCorrelation_FindPairAutoCorrelation(self, *args)

    def FindPairCrossCorrelation(self, *args):
        """
        FindPairCrossCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1, 
            bool use_weighted_randoms=False)
        FindPairCrossCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w, uint8_t random_iterations=1)
        FindPairCrossCorrelation(RadialCorrelation self, Map stomp_map, CosmoVector galaxy_z, WAngularVector galaxy_w)
        """
        return _stomp.RadialCorrelation_FindPairCrossCorrelation(self, *args)

    def Write(self, *args):
        """Write(RadialCorrelation self, std::string const & output_file_name) -> bool"""
        return _stomp.RadialCorrelation_Write(self, *args)

    def Covariance(self, *args):
        """Covariance(RadialCorrelation self, uint8_t bin_idx_a, uint8_t bin_idx_b) -> double"""
        return _stomp.RadialCorrelation_Covariance(self, *args)

    def WriteCovariance(self, *args):
        """WriteCovariance(RadialCorrelation self, std::string const & output_file_name) -> bool"""
        return _stomp.RadialCorrelation_WriteCovariance(self, *args)

    def UseOnlyPairs(self):
        """UseOnlyPairs(RadialCorrelation self)"""
        return _stomp.RadialCorrelation_UseOnlyPairs(self)

    def RadiusMin(self, resolution=1):
        """
        RadiusMin(RadialCorrelation self, uint32_t resolution=1) -> double
        RadiusMin(RadialCorrelation self) -> double
        """
        return _stomp.RadialCorrelation_RadiusMin(self, resolution)

    def RadiusMax(self, resolution=1):
        """
        RadiusMax(RadialCorrelation self, uint32_t resolution=1) -> double
        RadiusMax(RadialCorrelation self) -> double
        """
        return _stomp.RadialCorrelation_RadiusMax(self, resolution)

    def Begin(self, resolution=1):
        """
        Begin(RadialCorrelation self, uint32_t resolution=1) -> Stomp::RadialIterator
        Begin(RadialCorrelation self) -> Stomp::RadialIterator
        """
        return _stomp.RadialCorrelation_Begin(self, resolution)

    def End(self, resolution=1):
        """
        End(RadialCorrelation self, uint32_t resolution=1) -> Stomp::RadialIterator
        End(RadialCorrelation self) -> Stomp::RadialIterator
        """
        return _stomp.RadialCorrelation_End(self, resolution)

    def BinIterator(self, bin_idx=0):
        """
        BinIterator(RadialCorrelation self, uint8_t bin_idx=0) -> Stomp::RadialIterator
        BinIterator(RadialCorrelation self) -> Stomp::RadialIterator
        """
        return _stomp.RadialCorrelation_BinIterator(self, bin_idx)

    def NBins(self):
        """NBins(RadialCorrelation self) -> uint32_t"""
        return _stomp.RadialCorrelation_NBins(self)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(self):
        """_begin_Bins(RadialCorrelation self) -> std::vector< Stomp::RadialBin,std::allocator< Stomp::RadialBin > >::const_iterator *"""
        return _stomp.RadialCorrelation__begin_Bins(self)

    def _deref_Bins(self, *args):
        """_deref_Bins(RadialCorrelation self, std::vector< Stomp::RadialBin,std::allocator< Stomp::RadialBin > >::const_iterator const * iter) -> RadialBin"""
        return _stomp.RadialCorrelation__deref_Bins(self, *args)

RadialCorrelation_swigregister = _stomp.RadialCorrelation_swigregister
RadialCorrelation_swigregister(RadialCorrelation)

class Pixel(_object):
    """Proxy of C++ Stomp::Pixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::Pixel self) -> Pixel
        __init__(Stomp::Pixel self, uint32_t const resolution, uint32_t const pixnum, double const weight=0.0) -> Pixel
        __init__(Stomp::Pixel self, uint32_t const resolution, uint32_t const pixnum) -> Pixel
        __init__(Stomp::Pixel self, AngularCoordinate ang, uint32_t const resolution, double const weight=0.0) -> Pixel
        __init__(Stomp::Pixel self, AngularCoordinate ang, uint32_t const resolution) -> Pixel
        __init__(Stomp::Pixel self, uint32_t const x, uint32_t const y, uint32_t const resolution, double const weight=0.0) -> Pixel
        __init__(Stomp::Pixel self, uint32_t const x, uint32_t const y, uint32_t const resolution) -> Pixel
        """
        this = _stomp.new_Pixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Pixel
    __del__ = lambda self : None;
    def __lt__(self, *args):
        """__lt__(Pixel self, Pixel pix) -> bool"""
        return _stomp.Pixel___lt__(self, *args)

    def __eq__(self, *args):
        """__eq__(Pixel self, Pixel pix) -> bool"""
        return _stomp.Pixel___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(Pixel self, Pixel pix) -> bool"""
        return _stomp.Pixel___ne__(self, *args)

    def SetPixnumFromAng(self, *args):
        """SetPixnumFromAng(Pixel self, AngularCoordinate ang)"""
        return _stomp.Pixel_SetPixnumFromAng(self, *args)

    def SetResolution(self, *args):
        """SetResolution(Pixel self, uint32_t resolution)"""
        return _stomp.Pixel_SetResolution(self, *args)

    def SetLevel(self, *args):
        """SetLevel(Pixel self, uint8_t level)"""
        return _stomp.Pixel_SetLevel(self, *args)

    def SetPixnumFromXY(self, *args):
        """SetPixnumFromXY(Pixel self, uint32_t x, uint32_t y)"""
        return _stomp.Pixel_SetPixnumFromXY(self, *args)

    def SetWeight(self, *args):
        """SetWeight(Pixel self, double weight)"""
        return _stomp.Pixel_SetWeight(self, *args)

    def Level(self):
        """Level(Pixel self) -> uint8_t"""
        return _stomp.Pixel_Level(self)

    def Resolution(self):
        """Resolution(Pixel self) -> uint32_t"""
        return _stomp.Pixel_Resolution(self)

    def PixelX(self):
        """PixelX(Pixel self) -> uint32_t"""
        return _stomp.Pixel_PixelX(self)

    def PixelY(self):
        """PixelY(Pixel self) -> uint32_t"""
        return _stomp.Pixel_PixelY(self)

    def Weight(self):
        """Weight(Pixel self) -> double"""
        return _stomp.Pixel_Weight(self)

    def ReverseWeight(self):
        """ReverseWeight(Pixel self)"""
        return _stomp.Pixel_ReverseWeight(self)

    def InvertWeight(self):
        """InvertWeight(Pixel self)"""
        return _stomp.Pixel_InvertWeight(self)

    def SetToSuperPix(self, *args):
        """SetToSuperPix(Pixel self, uint32_t lo_resolution) -> bool"""
        return _stomp.Pixel_SetToSuperPix(self, *args)

    def SetToLevel(self, *args):
        """SetToLevel(Pixel self, uint8_t lo_level) -> bool"""
        return _stomp.Pixel_SetToLevel(self, *args)

    def SubPix(self, *args):
        """
        SubPix(Pixel self, uint32_t hi_resolution, PixelVector pix)
        SubPix(Pixel self, uint32_t hi_resolution, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
        """
        return _stomp.Pixel_SubPix(self, *args)

    def FirstCohort(self):
        """FirstCohort(Pixel self) -> bool"""
        return _stomp.Pixel_FirstCohort(self)

    def Area(*args):
        """
        Area() -> double
        Area(uint32_t resolution) -> double
        """
        return _stomp.Pixel_Area(*args)

    if _newclass:Area = staticmethod(Area)
    __swig_getmethods__["Area"] = lambda x: Area
    def Superpixnum(self):
        """Superpixnum(Pixel self) -> uint32_t"""
        return _stomp.Pixel_Superpixnum(self)

    def HPixnum(self):
        """HPixnum(Pixel self) -> uint32_t"""
        return _stomp.Pixel_HPixnum(self)

    def Pixnum(self):
        """Pixnum(Pixel self) -> uint32_t"""
        return _stomp.Pixel_Pixnum(self)

    def Contains(self, *args):
        """
        Contains(Pixel self, uint32_t pixel_resolution, uint32_t pixel_x, uint32_t pixel_y) -> bool
        Contains(Pixel self, Pixel pix) -> bool
        Contains(Pixel self, AngularCoordinate ang) -> bool
        """
        return _stomp.Pixel_Contains(self, *args)

    def WithinBounds(self, *args):
        """WithinBounds(Pixel self, double lon_min, double lon_max, double lat_min, double lat_max, Stomp::AngularCoordinate::Sphere sphere) -> bool"""
        return _stomp.Pixel_WithinBounds(self, *args)

    def IntersectsBounds(self, *args):
        """IntersectsBounds(Pixel self, double lon_min, double lon_max, double lat_min, double lat_max, Stomp::AngularCoordinate::Sphere sphere) -> bool"""
        return _stomp.Pixel_IntersectsBounds(self, *args)

    def WithinRadius(self, *args):
        """
        WithinRadius(Pixel self, double theta_max, PixelVector pix, bool check_full_pixel=False)
        WithinRadius(Pixel self, double theta_max, PixelVector pix)
        """
        return _stomp.Pixel_WithinRadius(self, *args)

    def WithinAnnulus(*args):
        """
        WithinAnnulus(double theta_min, double theta_max, PixelVector pix, bool check_full_pixel=False)
        WithinAnnulus(double theta_min, double theta_max, PixelVector pix)
        WithinAnnulus(AngularBin theta, PixelVector pix, bool check_full_pixel=False)
        WithinAnnulus(AngularBin theta, PixelVector pix)
        WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, PixelVector pix, bool check_full_pixel=False)
        WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, PixelVector pix)
        """
        return _stomp.Pixel_WithinAnnulus(*args)

    if _newclass:WithinAnnulus = staticmethod(WithinAnnulus)
    __swig_getmethods__["WithinAnnulus"] = lambda x: WithinAnnulus
    def BoundingRadius(self, *args):
        """
        BoundingRadius(Pixel self, double theta_max, PixelVector pix)
        BoundingRadius(Pixel self, AngularCoordinate ang, double theta_max, PixelVector pix)
        """
        return _stomp.Pixel_BoundingRadius(self, *args)

    def XYBounds(*args):
        """
        XYBounds(double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max, 
            bool add_buffer=False)
        XYBounds(double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
        XYBounds(double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, uint32_t & y_max, 
            bool add_buffer=False)
        XYBounds(double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, uint32_t & y_max)
        XYBounds(AngularCoordinate ang, double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, 
            uint32_t & y_max, bool add_buffer=False)
        XYBounds(AngularCoordinate ang, double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, 
            uint32_t & y_max)
        XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, 
            uint32_t & y_max, bool add_buffer=False)
        XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, 
            uint32_t & y_max)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, uint32_t & x_min, uint32_t & x_max, 
            uint32_t & y_min, uint32_t & y_max, bool add_buffer=False)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, uint32_t & x_min, uint32_t & x_max, 
            uint32_t & y_min, uint32_t & y_max)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, IndexVector x_min, IndexVector x_max, 
            uint32_t & y_min, uint32_t & y_max, bool add_buffer=False)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, IndexVector x_min, IndexVector x_max, 
            uint32_t & y_min, uint32_t & y_max)
        """
        return _stomp.Pixel_XYBounds(*args)

    if _newclass:XYBounds = staticmethod(XYBounds)
    __swig_getmethods__["XYBounds"] = lambda x: XYBounds
    def EtaStep(self, *args):
        """EtaStep(Pixel self, double theta) -> uint8_t"""
        return _stomp.Pixel_EtaStep(self, *args)

    def NearEdgeDistance(self, *args):
        """NearEdgeDistance(Pixel self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_NearEdgeDistance(self, *args)

    def FarEdgeDistance(self, *args):
        """FarEdgeDistance(Pixel self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_FarEdgeDistance(self, *args)

    def NearCornerDistance(self, *args):
        """NearCornerDistance(Pixel self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_NearCornerDistance(self, *args)

    def FarCornerDistance(self, *args):
        """FarCornerDistance(Pixel self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_FarCornerDistance(self, *args)

    def EdgeDistances(self, *args):
        """EdgeDistances(Pixel self, AngularCoordinate ang, double & near_edge_distance, double & far_edge_distance) -> bool"""
        return _stomp.Pixel_EdgeDistances(self, *args)

    def IsWithinRadius(self, *args):
        """
        IsWithinRadius(Pixel self, AngularCoordinate ang, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinRadius(Pixel self, AngularCoordinate ang, double theta_max) -> bool
        IsWithinRadius(Pixel self, Pixel pix, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinRadius(Pixel self, Pixel pix, double theta_max) -> bool
        """
        return _stomp.Pixel_IsWithinRadius(self, *args)

    def IsWithinAnnulus(self, *args):
        """
        IsWithinAnnulus(Pixel self, AngularCoordinate ang, double theta_min, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(Pixel self, AngularCoordinate ang, double theta_min, double theta_max) -> bool
        IsWithinAnnulus(Pixel self, Pixel pix, double theta_min, double theta_max, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(Pixel self, Pixel pix, double theta_min, double theta_max) -> bool
        IsWithinAnnulus(Pixel self, AngularCoordinate ang, AngularBin theta, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(Pixel self, AngularCoordinate ang, AngularBin theta) -> bool
        IsWithinAnnulus(Pixel self, Pixel pix, AngularBin theta, bool check_full_pixel=False) -> bool
        IsWithinAnnulus(Pixel self, Pixel pix, AngularBin theta) -> bool
        """
        return _stomp.Pixel_IsWithinAnnulus(self, *args)

    def IntersectsAnnulus(self, *args):
        """
        IntersectsAnnulus(Pixel self, AngularCoordinate ang, double theta_min, double theta_max) -> int8_t
        IntersectsAnnulus(Pixel self, Pixel pix, double theta_min, double theta_max) -> int8_t
        IntersectsAnnulus(Pixel self, AngularCoordinate ang, AngularBin theta) -> int8_t
        IntersectsAnnulus(Pixel self, Pixel pix, AngularBin theta) -> int8_t
        """
        return _stomp.Pixel_IntersectsAnnulus(self, *args)

    def Stripe(self, *args):
        """
        Stripe(Pixel self, uint32_t resolution=HPixResolution) -> uint32_t
        Stripe(Pixel self) -> uint32_t
        """
        return _stomp.Pixel_Stripe(self, *args)

    def RA(self):
        """RA(Pixel self) -> double"""
        return _stomp.Pixel_RA(self)

    def DEC(self):
        """DEC(Pixel self) -> double"""
        return _stomp.Pixel_DEC(self)

    def GalLon(self):
        """GalLon(Pixel self) -> double"""
        return _stomp.Pixel_GalLon(self)

    def GalLat(self):
        """GalLat(Pixel self) -> double"""
        return _stomp.Pixel_GalLat(self)

    def Ang(self, *args):
        """
        Ang(Pixel self, AngularCoordinate ang)
        Ang(Pixel self) -> AngularCoordinate
        """
        return _stomp.Pixel_Ang(self, *args)

    def Lambda(self):
        """Lambda(Pixel self) -> double"""
        return _stomp.Pixel_Lambda(self)

    def Eta(self):
        """Eta(Pixel self) -> double"""
        return _stomp.Pixel_Eta(self)

    def UnitSphereX(self):
        """UnitSphereX(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereZ(self)

    def LambdaMin(self):
        """LambdaMin(Pixel self) -> double"""
        return _stomp.Pixel_LambdaMin(self)

    def LambdaMax(self):
        """LambdaMax(Pixel self) -> double"""
        return _stomp.Pixel_LambdaMax(self)

    def EtaMin(self):
        """EtaMin(Pixel self) -> double"""
        return _stomp.Pixel_EtaMin(self)

    def EtaMax(self):
        """EtaMax(Pixel self) -> double"""
        return _stomp.Pixel_EtaMax(self)

    def EtaMaxContinuous(self):
        """EtaMaxContinuous(Pixel self) -> double"""
        return _stomp.Pixel_EtaMaxContinuous(self)

    def SurveyContinuous(self):
        """SurveyContinuous(Pixel self) -> bool"""
        return _stomp.Pixel_SurveyContinuous(self)

    def DECMin(self):
        """DECMin(Pixel self) -> double"""
        return _stomp.Pixel_DECMin(self)

    def DECMax(self):
        """DECMax(Pixel self) -> double"""
        return _stomp.Pixel_DECMax(self)

    def RAMin(self):
        """RAMin(Pixel self) -> double"""
        return _stomp.Pixel_RAMin(self)

    def RAMax(self):
        """RAMax(Pixel self) -> double"""
        return _stomp.Pixel_RAMax(self)

    def RAMaxContinuous(self):
        """RAMaxContinuous(Pixel self) -> double"""
        return _stomp.Pixel_RAMaxContinuous(self)

    def EquatorialContinuous(self):
        """EquatorialContinuous(Pixel self) -> bool"""
        return _stomp.Pixel_EquatorialContinuous(self)

    def GalLatMin(self):
        """GalLatMin(Pixel self) -> double"""
        return _stomp.Pixel_GalLatMin(self)

    def GalLatMax(self):
        """GalLatMax(Pixel self) -> double"""
        return _stomp.Pixel_GalLatMax(self)

    def GalLonMin(self):
        """GalLonMin(Pixel self) -> double"""
        return _stomp.Pixel_GalLonMin(self)

    def GalLonMax(self):
        """GalLonMax(Pixel self) -> double"""
        return _stomp.Pixel_GalLonMax(self)

    def GalLonMaxContinuous(self):
        """GalLonMaxContinuous(Pixel self) -> double"""
        return _stomp.Pixel_GalLonMaxContinuous(self)

    def GalacticContinuous(self):
        """GalacticContinuous(Pixel self) -> bool"""
        return _stomp.Pixel_GalacticContinuous(self)

    def ContinuousBounds(self, *args):
        """ContinuousBounds(Pixel self, Stomp::AngularCoordinate::Sphere sphere) -> bool"""
        return _stomp.Pixel_ContinuousBounds(self, *args)

    def UnitSphereX_UL(self):
        """UnitSphereX_UL(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereX_UL(self)

    def UnitSphereY_UL(self):
        """UnitSphereY_UL(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereY_UL(self)

    def UnitSphereZ_UL(self):
        """UnitSphereZ_UL(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereZ_UL(self)

    def UnitSphereX_UR(self):
        """UnitSphereX_UR(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereX_UR(self)

    def UnitSphereY_UR(self):
        """UnitSphereY_UR(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereY_UR(self)

    def UnitSphereZ_UR(self):
        """UnitSphereZ_UR(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereZ_UR(self)

    def UnitSphereX_LL(self):
        """UnitSphereX_LL(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereX_LL(self)

    def UnitSphereY_LL(self):
        """UnitSphereY_LL(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereY_LL(self)

    def UnitSphereZ_LL(self):
        """UnitSphereZ_LL(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereZ_LL(self)

    def UnitSphereX_LR(self):
        """UnitSphereX_LR(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereX_LR(self)

    def UnitSphereY_LR(self):
        """UnitSphereY_LR(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereY_LR(self)

    def UnitSphereZ_LR(self):
        """UnitSphereZ_LR(Pixel self) -> double"""
        return _stomp.Pixel_UnitSphereZ_LR(self)

    def Iterate(self, wrap_pixel=True):
        """
        Iterate(Pixel self, bool wrap_pixel=True)
        Iterate(Pixel self)
        """
        return _stomp.Pixel_Iterate(self, wrap_pixel)

    def PixelX0(self):
        """PixelX0(Pixel self) -> uint32_t"""
        return _stomp.Pixel_PixelX0(self)

    def PixelY0(self):
        """PixelY0(Pixel self) -> uint32_t"""
        return _stomp.Pixel_PixelY0(self)

    def PixelX1(self):
        """PixelX1(Pixel self) -> uint32_t"""
        return _stomp.Pixel_PixelX1(self)

    def PixelY1(self):
        """PixelY1(Pixel self) -> uint32_t"""
        return _stomp.Pixel_PixelY1(self)

    def GenerateRandomPoints(self, *args):
        """
        GenerateRandomPoints(Pixel self, AngularVector ang, uint32_t n_point=1)
        GenerateRandomPoints(Pixel self, AngularVector ang)
        """
        return _stomp.Pixel_GenerateRandomPoints(self, *args)

    def ResolutionToLevel(*args):
        """ResolutionToLevel(uint32_t const resolution) -> uint8_t"""
        return _stomp.Pixel_ResolutionToLevel(*args)

    if _newclass:ResolutionToLevel = staticmethod(ResolutionToLevel)
    __swig_getmethods__["ResolutionToLevel"] = lambda x: ResolutionToLevel
    def LevelToResolution(*args):
        """LevelToResolution(uint8_t const level) -> uint32_t"""
        return _stomp.Pixel_LevelToResolution(*args)

    if _newclass:LevelToResolution = staticmethod(LevelToResolution)
    __swig_getmethods__["LevelToResolution"] = lambda x: LevelToResolution
    def Ang2Pix(*args):
        """Ang2Pix(uint32_t const resolution, AngularCoordinate ang, uint32_t & pixnum)"""
        return _stomp.Pixel_Ang2Pix(*args)

    if _newclass:Ang2Pix = staticmethod(Ang2Pix)
    __swig_getmethods__["Ang2Pix"] = lambda x: Ang2Pix
    def Pix2Ang(*args):
        """Pix2Ang(uint32_t resolution, uint32_t pixnum, AngularCoordinate ang)"""
        return _stomp.Pixel_Pix2Ang(*args)

    if _newclass:Pix2Ang = staticmethod(Pix2Ang)
    __swig_getmethods__["Pix2Ang"] = lambda x: Pix2Ang
    def Pix2HPix(*args):
        """Pix2HPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t & output_hpixnum, uint32_t & output_superpixnum)"""
        return _stomp.Pixel_Pix2HPix(*args)

    if _newclass:Pix2HPix = staticmethod(Pix2HPix)
    __swig_getmethods__["Pix2HPix"] = lambda x: Pix2HPix
    def HPix2Pix(*args):
        """HPix2Pix(uint32_t input_resolution, uint32_t input_hpixnum, uint32_t input_superpixnum, uint32_t & output_pixnum)"""
        return _stomp.Pixel_HPix2Pix(*args)

    if _newclass:HPix2Pix = staticmethod(HPix2Pix)
    __swig_getmethods__["HPix2Pix"] = lambda x: HPix2Pix
    def SuperPix(*args):
        """
        SuperPix(uint32_t lo_resolution) -> uint32_t
        SuperPix(uint32_t hi_resolution, uint32_t hi_pixnum, uint32_t lo_resolution, uint32_t & lo_pixnum)
        """
        return _stomp.Pixel_SuperPix(*args)

    if _newclass:SuperPix = staticmethod(SuperPix)
    __swig_getmethods__["SuperPix"] = lambda x: SuperPix
    def SubPixels(*args):
        """
        SubPixels(uint32_t lo_resolution, uint32_t hi_pixnum, uint32_t hi_resolution, uint32_t & x_min, 
            uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
        """
        return _stomp.Pixel_SubPixels(*args)

    if _newclass:SubPixels = staticmethod(SubPixels)
    __swig_getmethods__["SubPixels"] = lambda x: SubPixels
    def NextSubPix(*args):
        """
        NextSubPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t & sub_pixnum1, uint32_t & sub_pixnum2, 
            uint32_t & sub_pixnum3, uint32_t & sub_pixnum4)
        """
        return _stomp.Pixel_NextSubPix(*args)

    if _newclass:NextSubPix = staticmethod(NextSubPix)
    __swig_getmethods__["NextSubPix"] = lambda x: NextSubPix
    def AreaIndex(*args):
        """
        AreaIndex(uint32_t resolution, double lammin, double lammax, double etamin, double etamax, 
            uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
        """
        return _stomp.Pixel_AreaIndex(*args)

    if _newclass:AreaIndex = staticmethod(AreaIndex)
    __swig_getmethods__["AreaIndex"] = lambda x: AreaIndex
    def PixelBound(*args):
        """
        PixelBound(uint32_t resolution, uint32_t pixnum, double & lammin, double & lammax, double & etamin, 
            double & etamax)
        """
        return _stomp.Pixel_PixelBound(*args)

    if _newclass:PixelBound = staticmethod(PixelBound)
    __swig_getmethods__["PixelBound"] = lambda x: PixelBound
    def CohortPix(*args):
        """
        CohortPix(Pixel pix_a, Pixel pix_b, Pixel pix_c)
        CohortPix(uint32_t resolution, uint32_t hpixnum, uint32_t & pixnum1, uint32_t & pixnum2, uint32_t & pixnum3)
        """
        return _stomp.Pixel_CohortPix(*args)

    if _newclass:CohortPix = staticmethod(CohortPix)
    __swig_getmethods__["CohortPix"] = lambda x: CohortPix
    def PixelArea(*args):
        """PixelArea(uint32_t resolution) -> double"""
        return _stomp.Pixel_PixelArea(*args)

    if _newclass:PixelArea = staticmethod(PixelArea)
    __swig_getmethods__["PixelArea"] = lambda x: PixelArea
    def Pix2EtaStep(*args):
        """Pix2EtaStep(uint32_t resolution, uint32_t pixnum, double theta) -> uint8_t"""
        return _stomp.Pixel_Pix2EtaStep(*args)

    if _newclass:Pix2EtaStep = staticmethod(Pix2EtaStep)
    __swig_getmethods__["Pix2EtaStep"] = lambda x: Pix2EtaStep
    def Ang2HPix(*args):
        """Ang2HPix(uint32_t resolution, AngularCoordinate ang, uint32_t & hpixnum, uint32_t & superpixnum)"""
        return _stomp.Pixel_Ang2HPix(*args)

    if _newclass:Ang2HPix = staticmethod(Ang2HPix)
    __swig_getmethods__["Ang2HPix"] = lambda x: Ang2HPix
    def HPix2Ang(*args):
        """HPix2Ang(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, AngularCoordinate ang)"""
        return _stomp.Pixel_HPix2Ang(*args)

    if _newclass:HPix2Ang = staticmethod(HPix2Ang)
    __swig_getmethods__["HPix2Ang"] = lambda x: HPix2Ang
    def XY2HPix(*args):
        """XY2HPix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t & hpixnum, uint32_t & superpixnum)"""
        return _stomp.Pixel_XY2HPix(*args)

    if _newclass:XY2HPix = staticmethod(XY2HPix)
    __swig_getmethods__["XY2HPix"] = lambda x: XY2HPix
    def HPix2XY(*args):
        """HPix2XY(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, uint32_t & x, uint32_t & y)"""
        return _stomp.Pixel_HPix2XY(*args)

    if _newclass:HPix2XY = staticmethod(HPix2XY)
    __swig_getmethods__["HPix2XY"] = lambda x: HPix2XY
    def SuperHPix(*args):
        """SuperHPix(uint32_t hi_resolution, uint32_t hi_hpixnum, uint32_t lo_resolution, uint32_t & lo_hpixnum)"""
        return _stomp.Pixel_SuperHPix(*args)

    if _newclass:SuperHPix = staticmethod(SuperHPix)
    __swig_getmethods__["SuperHPix"] = lambda x: SuperHPix
    def NextSubHPix(*args):
        """
        NextSubHPix(uint32_t resolution, uint32_t hpixnum, uint32_t & hpixnum1, uint32_t & hpixnum2, 
            uint32_t & hpixnum3, uint32_t & hpixnum4)
        """
        return _stomp.Pixel_NextSubHPix(*args)

    if _newclass:NextSubHPix = staticmethod(NextSubHPix)
    __swig_getmethods__["NextSubHPix"] = lambda x: NextSubHPix
    def SubHPix(*args):
        """
        SubHPix(uint32_t lo_resolution, uint32_t hi_hpixnum, uint32_t hi_superpixnum, uint32_t hi_resolution, 
            uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
        """
        return _stomp.Pixel_SubHPix(*args)

    if _newclass:SubHPix = staticmethod(SubHPix)
    __swig_getmethods__["SubHPix"] = lambda x: SubHPix
    def HPixelBound(*args):
        """
        HPixelBound(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, double & lammin, double & lammax, 
            double & etamin, double & etamax)
        """
        return _stomp.Pixel_HPixelBound(*args)

    if _newclass:HPixelBound = staticmethod(HPixelBound)
    __swig_getmethods__["HPixelBound"] = lambda x: HPixelBound
    def CohortHPix(*args):
        """
        CohortHPix(uint32_t resolution, uint32_t hpixnum, uint32_t & hpixnum1, uint32_t & hpixnum2, 
            uint32_t & hpixnum3)
        """
        return _stomp.Pixel_CohortHPix(*args)

    if _newclass:CohortHPix = staticmethod(CohortHPix)
    __swig_getmethods__["CohortHPix"] = lambda x: CohortHPix
    def HPixelArea(*args):
        """HPixelArea(uint32_t resolution) -> double"""
        return _stomp.Pixel_HPixelArea(*args)

    if _newclass:HPixelArea = staticmethod(HPixelArea)
    __swig_getmethods__["HPixelArea"] = lambda x: HPixelArea
    def HPix2EtaStep(*args):
        """HPix2EtaStep(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, double theta) -> uint8_t"""
        return _stomp.Pixel_HPix2EtaStep(*args)

    if _newclass:HPix2EtaStep = staticmethod(HPix2EtaStep)
    __swig_getmethods__["HPix2EtaStep"] = lambda x: HPix2EtaStep
    def XY2Pix(*args):
        """XY2Pix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t & pixnum)"""
        return _stomp.Pixel_XY2Pix(*args)

    if _newclass:XY2Pix = staticmethod(XY2Pix)
    __swig_getmethods__["XY2Pix"] = lambda x: XY2Pix
    def Pix2XY(*args):
        """Pix2XY(uint32_t resolution, uint32_t pixnum, uint32_t & x, uint32_t & y)"""
        return _stomp.Pixel_Pix2XY(*args)

    if _newclass:Pix2XY = staticmethod(Pix2XY)
    __swig_getmethods__["Pix2XY"] = lambda x: Pix2XY
    def LocalOrder(*args):
        """LocalOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_LocalOrder(*args)

    if _newclass:LocalOrder = staticmethod(LocalOrder)
    __swig_getmethods__["LocalOrder"] = lambda x: LocalOrder
    def SuperPixelBasedOrder(*args):
        """SuperPixelBasedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_SuperPixelBasedOrder(*args)

    if _newclass:SuperPixelBasedOrder = staticmethod(SuperPixelBasedOrder)
    __swig_getmethods__["SuperPixelBasedOrder"] = lambda x: SuperPixelBasedOrder
    def SuperPixelOrder(*args):
        """SuperPixelOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_SuperPixelOrder(*args)

    if _newclass:SuperPixelOrder = staticmethod(SuperPixelOrder)
    __swig_getmethods__["SuperPixelOrder"] = lambda x: SuperPixelOrder
    def WeightedOrder(*args):
        """WeightedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightedOrder(*args)

    if _newclass:WeightedOrder = staticmethod(WeightedOrder)
    __swig_getmethods__["WeightedOrder"] = lambda x: WeightedOrder
    def WeightMatch(*args):
        """WeightMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightMatch(*args)

    if _newclass:WeightMatch = staticmethod(WeightMatch)
    __swig_getmethods__["WeightMatch"] = lambda x: WeightMatch
    def WeightedPixelMatch(*args):
        """WeightedPixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightedPixelMatch(*args)

    if _newclass:WeightedPixelMatch = staticmethod(WeightedPixelMatch)
    __swig_getmethods__["WeightedPixelMatch"] = lambda x: WeightedPixelMatch
    def PixelMatch(*args):
        """PixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_PixelMatch(*args)

    if _newclass:PixelMatch = staticmethod(PixelMatch)
    __swig_getmethods__["PixelMatch"] = lambda x: PixelMatch
    def ResolveSuperPixel(*args):
        """
        ResolveSuperPixel(PixelVector pix, bool ignore_weight=False)
        ResolveSuperPixel(PixelVector pix)
        """
        return _stomp.Pixel_ResolveSuperPixel(*args)

    if _newclass:ResolveSuperPixel = staticmethod(ResolveSuperPixel)
    __swig_getmethods__["ResolveSuperPixel"] = lambda x: ResolveSuperPixel
    def ResolvePixel(*args):
        """
        ResolvePixel(PixelVector pix, bool ignore_weight=False)
        ResolvePixel(PixelVector pix)
        """
        return _stomp.Pixel_ResolvePixel(*args)

    if _newclass:ResolvePixel = staticmethod(ResolvePixel)
    __swig_getmethods__["ResolvePixel"] = lambda x: ResolvePixel
    def FindUniquePixels(*args):
        """FindUniquePixels(PixelVector input_pix, PixelVector unique_pix)"""
        return _stomp.Pixel_FindUniquePixels(*args)

    if _newclass:FindUniquePixels = staticmethod(FindUniquePixels)
    __swig_getmethods__["FindUniquePixels"] = lambda x: FindUniquePixels
Pixel_swigregister = _stomp.Pixel_swigregister
Pixel_swigregister(Pixel)

def Pixel_Area(*args):
  """
    Area() -> double
    Pixel_Area(uint32_t resolution) -> double
    """
  return _stomp.Pixel_Area(*args)

def Pixel_WithinAnnulus(*args):
  """
    WithinAnnulus(double theta_min, double theta_max, PixelVector pix, bool check_full_pixel=False)
    WithinAnnulus(double theta_min, double theta_max, PixelVector pix)
    WithinAnnulus(AngularBin theta, PixelVector pix, bool check_full_pixel=False)
    WithinAnnulus(AngularBin theta, PixelVector pix)
    WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, PixelVector pix, bool check_full_pixel=False)
    Pixel_WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, PixelVector pix)
    """
  return _stomp.Pixel_WithinAnnulus(*args)

def Pixel_XYBounds(*args):
  """
    XYBounds(double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max, 
        bool add_buffer=False)
    XYBounds(double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
    XYBounds(double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, uint32_t & y_max, 
        bool add_buffer=False)
    XYBounds(double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, uint32_t & y_max)
    XYBounds(AngularCoordinate ang, double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, 
        uint32_t & y_max, bool add_buffer=False)
    XYBounds(AngularCoordinate ang, double theta, uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, 
        uint32_t & y_max)
    XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, 
        uint32_t & y_max, bool add_buffer=False)
    XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, IndexVector x_max, uint32_t & y_min, 
        uint32_t & y_max)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, uint32_t & x_min, uint32_t & x_max, 
        uint32_t & y_min, uint32_t & y_max, bool add_buffer=False)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, uint32_t & x_min, uint32_t & x_max, 
        uint32_t & y_min, uint32_t & y_max)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, IndexVector x_min, IndexVector x_max, 
        uint32_t & y_min, uint32_t & y_max, bool add_buffer=False)
    Pixel_XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, IndexVector x_min, IndexVector x_max, 
        uint32_t & y_min, uint32_t & y_max)
    """
  return _stomp.Pixel_XYBounds(*args)

def Pixel_ResolutionToLevel(*args):
  """Pixel_ResolutionToLevel(uint32_t const resolution) -> uint8_t"""
  return _stomp.Pixel_ResolutionToLevel(*args)

def Pixel_LevelToResolution(*args):
  """Pixel_LevelToResolution(uint8_t const level) -> uint32_t"""
  return _stomp.Pixel_LevelToResolution(*args)

def Pixel_Ang2Pix(*args):
  """Pixel_Ang2Pix(uint32_t const resolution, AngularCoordinate ang, uint32_t & pixnum)"""
  return _stomp.Pixel_Ang2Pix(*args)

def Pixel_Pix2Ang(*args):
  """Pixel_Pix2Ang(uint32_t resolution, uint32_t pixnum, AngularCoordinate ang)"""
  return _stomp.Pixel_Pix2Ang(*args)

def Pixel_Pix2HPix(*args):
  """Pixel_Pix2HPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t & output_hpixnum, uint32_t & output_superpixnum)"""
  return _stomp.Pixel_Pix2HPix(*args)

def Pixel_HPix2Pix(*args):
  """Pixel_HPix2Pix(uint32_t input_resolution, uint32_t input_hpixnum, uint32_t input_superpixnum, uint32_t & output_pixnum)"""
  return _stomp.Pixel_HPix2Pix(*args)

def Pixel_SuperPix(*args):
  """
    SuperPix(uint32_t lo_resolution) -> uint32_t
    Pixel_SuperPix(uint32_t hi_resolution, uint32_t hi_pixnum, uint32_t lo_resolution, uint32_t & lo_pixnum)
    """
  return _stomp.Pixel_SuperPix(*args)

def Pixel_SubPixels(*args):
  """
    Pixel_SubPixels(uint32_t lo_resolution, uint32_t hi_pixnum, uint32_t hi_resolution, uint32_t & x_min, 
        uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
    """
  return _stomp.Pixel_SubPixels(*args)

def Pixel_NextSubPix(*args):
  """
    Pixel_NextSubPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t & sub_pixnum1, uint32_t & sub_pixnum2, 
        uint32_t & sub_pixnum3, uint32_t & sub_pixnum4)
    """
  return _stomp.Pixel_NextSubPix(*args)

def Pixel_AreaIndex(*args):
  """
    Pixel_AreaIndex(uint32_t resolution, double lammin, double lammax, double etamin, double etamax, 
        uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
    """
  return _stomp.Pixel_AreaIndex(*args)

def Pixel_PixelBound(*args):
  """
    Pixel_PixelBound(uint32_t resolution, uint32_t pixnum, double & lammin, double & lammax, double & etamin, 
        double & etamax)
    """
  return _stomp.Pixel_PixelBound(*args)

def Pixel_CohortPix(*args):
  """
    CohortPix(Pixel pix_a, Pixel pix_b, Pixel pix_c)
    Pixel_CohortPix(uint32_t resolution, uint32_t hpixnum, uint32_t & pixnum1, uint32_t & pixnum2, uint32_t & pixnum3)
    """
  return _stomp.Pixel_CohortPix(*args)

def Pixel_PixelArea(*args):
  """Pixel_PixelArea(uint32_t resolution) -> double"""
  return _stomp.Pixel_PixelArea(*args)

def Pixel_Pix2EtaStep(*args):
  """Pixel_Pix2EtaStep(uint32_t resolution, uint32_t pixnum, double theta) -> uint8_t"""
  return _stomp.Pixel_Pix2EtaStep(*args)

def Pixel_Ang2HPix(*args):
  """Pixel_Ang2HPix(uint32_t resolution, AngularCoordinate ang, uint32_t & hpixnum, uint32_t & superpixnum)"""
  return _stomp.Pixel_Ang2HPix(*args)

def Pixel_HPix2Ang(*args):
  """Pixel_HPix2Ang(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, AngularCoordinate ang)"""
  return _stomp.Pixel_HPix2Ang(*args)

def Pixel_XY2HPix(*args):
  """Pixel_XY2HPix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t & hpixnum, uint32_t & superpixnum)"""
  return _stomp.Pixel_XY2HPix(*args)

def Pixel_HPix2XY(*args):
  """Pixel_HPix2XY(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, uint32_t & x, uint32_t & y)"""
  return _stomp.Pixel_HPix2XY(*args)

def Pixel_SuperHPix(*args):
  """Pixel_SuperHPix(uint32_t hi_resolution, uint32_t hi_hpixnum, uint32_t lo_resolution, uint32_t & lo_hpixnum)"""
  return _stomp.Pixel_SuperHPix(*args)

def Pixel_NextSubHPix(*args):
  """
    Pixel_NextSubHPix(uint32_t resolution, uint32_t hpixnum, uint32_t & hpixnum1, uint32_t & hpixnum2, 
        uint32_t & hpixnum3, uint32_t & hpixnum4)
    """
  return _stomp.Pixel_NextSubHPix(*args)

def Pixel_SubHPix(*args):
  """
    Pixel_SubHPix(uint32_t lo_resolution, uint32_t hi_hpixnum, uint32_t hi_superpixnum, uint32_t hi_resolution, 
        uint32_t & x_min, uint32_t & x_max, uint32_t & y_min, uint32_t & y_max)
    """
  return _stomp.Pixel_SubHPix(*args)

def Pixel_HPixelBound(*args):
  """
    Pixel_HPixelBound(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, double & lammin, double & lammax, 
        double & etamin, double & etamax)
    """
  return _stomp.Pixel_HPixelBound(*args)

def Pixel_CohortHPix(*args):
  """
    Pixel_CohortHPix(uint32_t resolution, uint32_t hpixnum, uint32_t & hpixnum1, uint32_t & hpixnum2, 
        uint32_t & hpixnum3)
    """
  return _stomp.Pixel_CohortHPix(*args)

def Pixel_HPixelArea(*args):
  """Pixel_HPixelArea(uint32_t resolution) -> double"""
  return _stomp.Pixel_HPixelArea(*args)

def Pixel_HPix2EtaStep(*args):
  """Pixel_HPix2EtaStep(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, double theta) -> uint8_t"""
  return _stomp.Pixel_HPix2EtaStep(*args)

def Pixel_XY2Pix(*args):
  """Pixel_XY2Pix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t & pixnum)"""
  return _stomp.Pixel_XY2Pix(*args)

def Pixel_Pix2XY(*args):
  """Pixel_Pix2XY(uint32_t resolution, uint32_t pixnum, uint32_t & x, uint32_t & y)"""
  return _stomp.Pixel_Pix2XY(*args)

def Pixel_LocalOrder(*args):
  """Pixel_LocalOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_LocalOrder(*args)

def Pixel_SuperPixelBasedOrder(*args):
  """Pixel_SuperPixelBasedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_SuperPixelBasedOrder(*args)

def Pixel_SuperPixelOrder(*args):
  """Pixel_SuperPixelOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_SuperPixelOrder(*args)

def Pixel_WeightedOrder(*args):
  """Pixel_WeightedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightedOrder(*args)

def Pixel_WeightMatch(*args):
  """Pixel_WeightMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightMatch(*args)

def Pixel_WeightedPixelMatch(*args):
  """Pixel_WeightedPixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightedPixelMatch(*args)

def Pixel_PixelMatch(*args):
  """Pixel_PixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_PixelMatch(*args)

def Pixel_ResolveSuperPixel(*args):
  """
    ResolveSuperPixel(PixelVector pix, bool ignore_weight=False)
    Pixel_ResolveSuperPixel(PixelVector pix)
    """
  return _stomp.Pixel_ResolveSuperPixel(*args)

def Pixel_ResolvePixel(*args):
  """
    ResolvePixel(PixelVector pix, bool ignore_weight=False)
    Pixel_ResolvePixel(PixelVector pix)
    """
  return _stomp.Pixel_ResolvePixel(*args)

def Pixel_FindUniquePixels(*args):
  """Pixel_FindUniquePixels(PixelVector input_pix, PixelVector unique_pix)"""
  return _stomp.Pixel_FindUniquePixels(*args)

class PixelOrdering(_object):
    """Proxy of C++ Stomp::PixelOrdering class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelOrdering, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelOrdering, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(PixelOrdering self, Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.PixelOrdering___call__(self, *args)

    def __init__(self): 
        """__init__(Stomp::PixelOrdering self) -> PixelOrdering"""
        this = _stomp.new_PixelOrdering()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_PixelOrdering
    __del__ = lambda self : None;
PixelOrdering_swigregister = _stomp.PixelOrdering_swigregister
PixelOrdering_swigregister(PixelOrdering)

class ScalarPixel(Pixel):
    """Proxy of C++ Stomp::ScalarPixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarPixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarPixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::ScalarPixel self) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const resolution, uint32_t const pixnum, double const weight=0.0, double const intensity=0.0, 
            uint32_t const n_points=0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const resolution, uint32_t const pixnum, double const weight=0.0, double const intensity=0.0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const resolution, uint32_t const pixnum, double const weight=0.0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const resolution, uint32_t const pixnum) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, AngularCoordinate ang, uint32_t const resolution, double const weight=0.0, double const intensity=0.0, 
            uint32_t const n_points=0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, AngularCoordinate ang, uint32_t const resolution, double const weight=0.0, double const intensity=0.0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, AngularCoordinate ang, uint32_t const resolution, double const weight=0.0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, AngularCoordinate ang, uint32_t const resolution) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const x, uint32_t const y, uint32_t const resolution, double const weight=0.0, 
            double const intensity=0.0, uint32_t const n_points=0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const x, uint32_t const y, uint32_t const resolution, double const weight=0.0, 
            double const intensity=0.0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const x, uint32_t const y, uint32_t const resolution, double const weight=0.0) -> ScalarPixel
        __init__(Stomp::ScalarPixel self, uint32_t const x, uint32_t const y, uint32_t const resolution) -> ScalarPixel
        """
        this = _stomp.new_ScalarPixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_ScalarPixel
    __del__ = lambda self : None;
    def SetIntensity(self, *args):
        """SetIntensity(ScalarPixel self, double const intensity)"""
        return _stomp.ScalarPixel_SetIntensity(self, *args)

    def SetNPoints(self, *args):
        """SetNPoints(ScalarPixel self, uint32_t const n_point)"""
        return _stomp.ScalarPixel_SetNPoints(self, *args)

    def Intensity(self):
        """Intensity(ScalarPixel self) -> double"""
        return _stomp.ScalarPixel_Intensity(self)

    def NPoints(self):
        """NPoints(ScalarPixel self) -> uint32_t"""
        return _stomp.ScalarPixel_NPoints(self)

    def MeanIntensity(self):
        """MeanIntensity(ScalarPixel self) -> double"""
        return _stomp.ScalarPixel_MeanIntensity(self)

    def AddToIntensity(self, *args):
        """
        AddToIntensity(ScalarPixel self, double const intensity, uint32_t const n_point=1)
        AddToIntensity(ScalarPixel self, double const intensity)
        """
        return _stomp.ScalarPixel_AddToIntensity(self, *args)

    def ScaleIntensity(self, *args):
        """ScaleIntensity(ScalarPixel self, double scale_factor)"""
        return _stomp.ScalarPixel_ScaleIntensity(self, *args)

    def NormalizeIntensity(self):
        """NormalizeIntensity(ScalarPixel self)"""
        return _stomp.ScalarPixel_NormalizeIntensity(self)

    def ConvertToOverDensity(self, *args):
        """ConvertToOverDensity(ScalarPixel self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertToOverDensity(self, *args)

    def ConvertToFractionalOverDensity(self, *args):
        """ConvertToFractionalOverDensity(ScalarPixel self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertToFractionalOverDensity(self, *args)

    def ConvertFromOverDensity(self, *args):
        """ConvertFromOverDensity(ScalarPixel self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertFromOverDensity(self, *args)

    def ConvertFromFractionalOverDensity(self, *args):
        """ConvertFromFractionalOverDensity(ScalarPixel self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertFromFractionalOverDensity(self, *args)

    def UnitSphereX(self):
        """UnitSphereX(ScalarPixel self) -> double"""
        return _stomp.ScalarPixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(ScalarPixel self) -> double"""
        return _stomp.ScalarPixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(ScalarPixel self) -> double"""
        return _stomp.ScalarPixel_UnitSphereZ(self)

    def _WithinAnnulus(self, *args):
        """_WithinAnnulus(ScalarPixel self, AngularBin theta, ScalarVector pix)"""
        return _stomp.ScalarPixel__WithinAnnulus(self, *args)

    def IsOverDensity(self):
        """IsOverDensity(ScalarPixel self) -> bool"""
        return _stomp.ScalarPixel_IsOverDensity(self)

ScalarPixel_swigregister = _stomp.ScalarPixel_swigregister
ScalarPixel_swigregister(ScalarPixel)

class section(_object):
    """Proxy of C++ Stomp::section class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, section, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, section, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min_stripe"] = _stomp.section_min_stripe_set
    __swig_getmethods__["min_stripe"] = _stomp.section_min_stripe_get
    if _newclass:min_stripe = _swig_property(_stomp.section_min_stripe_get, _stomp.section_min_stripe_set)
    __swig_setmethods__["max_stripe"] = _stomp.section_max_stripe_set
    __swig_getmethods__["max_stripe"] = _stomp.section_max_stripe_get
    if _newclass:max_stripe = _swig_property(_stomp.section_max_stripe_get, _stomp.section_max_stripe_set)
    def __init__(self): 
        """__init__(Stomp::section self) -> section"""
        this = _stomp.new_section()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_section
    __del__ = lambda self : None;
section_swigregister = _stomp.section_swigregister
section_swigregister(section)

class RegionBound(_object):
    """Proxy of C++ Stomp::RegionBound class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionBound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegionBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::RegionBound self) -> RegionBound
        __init__(Stomp::RegionBound self, GeometricBound bound) -> RegionBound
        """
        this = _stomp.new_RegionBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RegionBound
    __del__ = lambda self : None;
    def SetGeometricBound(self, *args):
        """SetGeometricBound(RegionBound self, GeometricBound bound)"""
        return _stomp.RegionBound_SetGeometricBound(self, *args)

    def SetNRegion(self, *args):
        """SetNRegion(RegionBound self, uint16_t n_region)"""
        return _stomp.RegionBound_SetNRegion(self, *args)

    def NRegion(self):
        """NRegion(RegionBound self) -> uint16_t"""
        return _stomp.RegionBound_NRegion(self)

    def CheckPixel(self, *args):
        """CheckPixel(RegionBound self, Pixel pix) -> bool"""
        return _stomp.RegionBound_CheckPixel(self, *args)

    def ScorePixel(self, *args):
        """ScorePixel(RegionBound self, Pixel pix) -> double"""
        return _stomp.RegionBound_ScorePixel(self, *args)

    def AddPixel(self, *args):
        """AddPixel(RegionBound self, Pixel pix) -> bool"""
        return _stomp.RegionBound_AddPixel(self, *args)

    def RemovePixel(self, *args):
        """RemovePixel(RegionBound self, Pixel pix) -> bool"""
        return _stomp.RegionBound_RemovePixel(self, *args)

    def ClearPixels(self):
        """ClearPixels(RegionBound self)"""
        return _stomp.RegionBound_ClearPixels(self)

    def Coverage(self, *args):
        """Coverage(RegionBound self, PixelVector pix)"""
        return _stomp.RegionBound_Coverage(self, *args)

    def CoveragePixels(self):
        """CoveragePixels(RegionBound self) -> uint32_t"""
        return _stomp.RegionBound_CoveragePixels(self)

    def CoverageArea(self):
        """CoverageArea(RegionBound self) -> double"""
        return _stomp.RegionBound_CoverageArea(self)

    def BoundArea(self):
        """BoundArea(RegionBound self) -> double"""
        return _stomp.RegionBound_BoundArea(self)

RegionBound_swigregister = _stomp.RegionBound_swigregister
RegionBound_swigregister(RegionBound)

class RegionMap(_object):
    """Proxy of C++ Stomp::RegionMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegionMap, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(Stomp::RegionMap self) -> RegionMap"""
        this = _stomp.new_RegionMap()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RegionMap
    __del__ = lambda self : None;
    def InitializeRegions(self, *args):
        """
        InitializeRegions(RegionMap self, BaseMap base_map, uint16_t n_region, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(RegionMap self, BaseMap base_map, uint16_t n_region) -> uint16_t
        InitializeRegions(RegionMap self, BaseMap base_map, Stomp::RegionBoundVector & region_bounds, uint16_t n_region, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(RegionMap self, BaseMap base_map, Stomp::RegionBoundVector & region_bounds, uint16_t n_region) -> uint16_t
        InitializeRegions(RegionMap self, BaseMap base_map, BaseMap source_map) -> bool
        """
        return _stomp.RegionMap_InitializeRegions(self, *args)

    def _FindRegionResolution(self, *args):
        """_FindRegionResolution(RegionMap self, BaseMap base_map, uint16_t n_region, uint32_t region_resolution)"""
        return _stomp.RegionMap__FindRegionResolution(self, *args)

    def _FindUniqueStripes(self, *args):
        """_FindUniqueStripes(RegionMap self, PixelVector coverage_pix, IndexVector unique_stripes)"""
        return _stomp.RegionMap__FindUniqueStripes(self, *args)

    def _FindSections(self, *args):
        """_FindSections(RegionMap self, IndexVector unique_stripes, double base_map_area, uint16_t n_region, Stomp::SectionVector & sectionVec)"""
        return _stomp.RegionMap__FindSections(self, *args)

    def _Regionate(self, *args):
        """
        _Regionate(RegionMap self, PixelVector coverage_pix, Stomp::SectionVector & sectionVec, uint16_t n_region, uint16_t starting_region_index=0)
        _Regionate(RegionMap self, PixelVector coverage_pix, Stomp::SectionVector & sectionVec, uint16_t n_region)
        """
        return _stomp.RegionMap__Regionate(self, *args)

    def _VerifyRegionation(self, *args):
        """_VerifyRegionation(RegionMap self, uint16_t n_region)"""
        return _stomp.RegionMap__VerifyRegionation(self, *args)

    def FindRegion(self, *args):
        """
        FindRegion(RegionMap self, AngularCoordinate ang) -> int16_t
        FindRegion(RegionMap self, Pixel pix) -> int16_t
        """
        return _stomp.RegionMap_FindRegion(self, *args)

    def ClearRegions(self):
        """ClearRegions(RegionMap self)"""
        return _stomp.RegionMap_ClearRegions(self)

    def Region(self, *args):
        """Region(RegionMap self, uint32_t region_idx) -> int16_t"""
        return _stomp.RegionMap_Region(self, *args)

    def RegionArea(self, *args):
        """
        RegionArea(RegionMap self, int16_t region, PixelVector pix)
        RegionArea(RegionMap self, int16_t region) -> double
        """
        return _stomp.RegionMap_RegionArea(self, *args)

    def NRegion(self):
        """NRegion(RegionMap self) -> uint16_t"""
        return _stomp.RegionMap_NRegion(self)

    def Resolution(self):
        """Resolution(RegionMap self) -> uint32_t"""
        return _stomp.RegionMap_Resolution(self)

    def Initialized(self):
        """Initialized(RegionMap self) -> bool"""
        return _stomp.RegionMap_Initialized(self)

    def Begin(self):
        """Begin(RegionMap self) -> Stomp::RegionIterator"""
        return _stomp.RegionMap_Begin(self)

    def End(self):
        """End(RegionMap self) -> Stomp::RegionIterator"""
        return _stomp.RegionMap_End(self)

RegionMap_swigregister = _stomp.RegionMap_swigregister
RegionMap_swigregister(RegionMap)

class BaseMap(_object):
    """Proxy of C++ Stomp::BaseMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseMap, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(Stomp::BaseMap self) -> BaseMap"""
        this = _stomp.new_BaseMap()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_BaseMap
    __del__ = lambda self : None;
    def Coverage(self, *args):
        """
        Coverage(BaseMap self, PixelVector superpix, uint32_t resolution=HPixResolution, bool calculate_fraction=True)
        Coverage(BaseMap self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(BaseMap self, PixelVector superpix)
        """
        return _stomp.BaseMap_Coverage(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(BaseMap self, Pixel pix) -> double"""
        return _stomp.BaseMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(BaseMap self, Pixel pix) -> int8_t"""
        return _stomp.BaseMap_FindUnmaskedStatus(self, *args)

    def Empty(self):
        """Empty(BaseMap self) -> bool"""
        return _stomp.BaseMap_Empty(self)

    def Clear(self):
        """Clear(BaseMap self)"""
        return _stomp.BaseMap_Clear(self)

    def Size(self):
        """Size(BaseMap self) -> uint32_t"""
        return _stomp.BaseMap_Size(self)

    def Area(self):
        """Area(BaseMap self) -> double"""
        return _stomp.BaseMap_Area(self)

    def MinResolution(self):
        """MinResolution(BaseMap self) -> uint32_t"""
        return _stomp.BaseMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(BaseMap self) -> uint32_t"""
        return _stomp.BaseMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(BaseMap self) -> uint8_t"""
        return _stomp.BaseMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(BaseMap self) -> uint8_t"""
        return _stomp.BaseMap_MaxLevel(self)

    def InitializeRegions(self, *args):
        """
        InitializeRegions(BaseMap self, uint16_t n_regions, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(BaseMap self, uint16_t n_regions) -> uint16_t
        InitializeRegions(BaseMap self, Stomp::RegionBoundVector & region_bounds, uint16_t n_region, uint32_t region_resolution=0) -> uint16_t
        InitializeRegions(BaseMap self, Stomp::RegionBoundVector & region_bounds, uint16_t n_region) -> uint16_t
        InitializeRegions(BaseMap self, BaseMap base_map) -> bool
        """
        return _stomp.BaseMap_InitializeRegions(self, *args)

    def FindRegion(self, *args):
        """
        FindRegion(BaseMap self, AngularCoordinate ang) -> int16_t
        FindRegion(BaseMap self, Pixel pix) -> int16_t
        """
        return _stomp.BaseMap_FindRegion(self, *args)

    def ClearRegions(self):
        """ClearRegions(BaseMap self)"""
        return _stomp.BaseMap_ClearRegions(self)

    def Region(self, *args):
        """Region(BaseMap self, uint32_t region_idx) -> int16_t"""
        return _stomp.BaseMap_Region(self, *args)

    def RegionArea(self, *args):
        """
        RegionArea(BaseMap self, int16_t region, PixelVector pix)
        RegionArea(BaseMap self, int16_t region) -> double
        """
        return _stomp.BaseMap_RegionArea(self, *args)

    def NRegion(self):
        """NRegion(BaseMap self) -> uint16_t"""
        return _stomp.BaseMap_NRegion(self)

    def RegionResolution(self):
        """RegionResolution(BaseMap self) -> uint32_t"""
        return _stomp.BaseMap_RegionResolution(self)

    def RegionsInitialized(self):
        """RegionsInitialized(BaseMap self) -> bool"""
        return _stomp.BaseMap_RegionsInitialized(self)

    def RegionBegin(self):
        """RegionBegin(BaseMap self) -> Stomp::RegionIterator"""
        return _stomp.BaseMap_RegionBegin(self)

    def RegionEnd(self):
        """RegionEnd(BaseMap self) -> Stomp::RegionIterator"""
        return _stomp.BaseMap_RegionEnd(self)

BaseMap_swigregister = _stomp.BaseMap_swigregister
BaseMap_swigregister(BaseMap)

class SubMap(_object):
    """Proxy of C++ Stomp::SubMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SubMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(Stomp::SubMap self, uint32_t superpixnum) -> SubMap"""
        this = _stomp.new_SubMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_SubMap
    __del__ = lambda self : None;
    def AddPixel(self, *args):
        """AddPixel(SubMap self, Pixel pix)"""
        return _stomp.SubMap_AddPixel(self, *args)

    def Resolve(self, force_resolve=False):
        """
        Resolve(SubMap self, bool force_resolve=False)
        Resolve(SubMap self)
        """
        return _stomp.SubMap_Resolve(self, force_resolve)

    def SetMinimumWeight(self, *args):
        """SetMinimumWeight(SubMap self, double minimum_weight)"""
        return _stomp.SubMap_SetMinimumWeight(self, *args)

    def SetMaximumWeight(self, *args):
        """SetMaximumWeight(SubMap self, double maximum_weight)"""
        return _stomp.SubMap_SetMaximumWeight(self, *args)

    def SetMaximumResolution(self, *args):
        """SetMaximumResolution(SubMap self, uint32_t maximum_resolution, bool average_weights)"""
        return _stomp.SubMap_SetMaximumResolution(self, *args)

    def FindLocation(self, *args):
        """FindLocation(SubMap self, AngularCoordinate ang, double & weight) -> bool"""
        return _stomp.SubMap_FindLocation(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(SubMap self, Pixel pix) -> double"""
        return _stomp.SubMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(SubMap self, Pixel pix) -> int8_t"""
        return _stomp.SubMap_FindUnmaskedStatus(self, *args)

    def FindAverageWeight(self, *args):
        """FindAverageWeight(SubMap self, Pixel pix) -> double"""
        return _stomp.SubMap_FindAverageWeight(self, *args)

    def FindMatchingPixels(self, *args):
        """
        FindMatchingPixels(SubMap self, Pixel pix, PixelVector match_pix, bool use_local_weights=False)
        FindMatchingPixels(SubMap self, Pixel pix, PixelVector match_pix)
        """
        return _stomp.SubMap_FindMatchingPixels(self, *args)

    def AverageWeight(self):
        """AverageWeight(SubMap self) -> double"""
        return _stomp.SubMap_AverageWeight(self)

    def Soften(self, *args):
        """Soften(SubMap self, PixelVector softened_pix, uint32_t maximum_resolution, bool average_weights)"""
        return _stomp.SubMap_Soften(self, *args)

    def Add(self, *args):
        """Add(SubMap self, Map stomp_map, bool drop_single) -> bool"""
        return _stomp.SubMap_Add(self, *args)

    def Multiply(self, *args):
        """Multiply(SubMap self, Map stomp_map, bool drop_single) -> bool"""
        return _stomp.SubMap_Multiply(self, *args)

    def Exclude(self, *args):
        """Exclude(SubMap self, Map stomp_map) -> bool"""
        return _stomp.SubMap_Exclude(self, *args)

    def ScaleWeight(self, *args):
        """ScaleWeight(SubMap self, double const weight_scale)"""
        return _stomp.SubMap_ScaleWeight(self, *args)

    def AddConstantWeight(self, *args):
        """AddConstantWeight(SubMap self, double const add_weight)"""
        return _stomp.SubMap_AddConstantWeight(self, *args)

    def InvertWeight(self):
        """InvertWeight(SubMap self)"""
        return _stomp.SubMap_InvertWeight(self)

    def Pixels(self, *args):
        """Pixels(SubMap self, PixelVector pix)"""
        return _stomp.SubMap_Pixels(self, *args)

    def Clear(self):
        """Clear(SubMap self)"""
        return _stomp.SubMap_Clear(self)

    def Superpixnum(self):
        """Superpixnum(SubMap self) -> uint32_t"""
        return _stomp.SubMap_Superpixnum(self)

    def Begin(self):
        """Begin(SubMap self) -> Stomp::PixelIterator"""
        return _stomp.SubMap_Begin(self)

    def End(self):
        """End(SubMap self) -> Stomp::PixelIterator"""
        return _stomp.SubMap_End(self)

    def Area(self):
        """Area(SubMap self) -> double"""
        return _stomp.SubMap_Area(self)

    def Initialized(self):
        """Initialized(SubMap self) -> bool"""
        return _stomp.SubMap_Initialized(self)

    def Unsorted(self):
        """Unsorted(SubMap self) -> bool"""
        return _stomp.SubMap_Unsorted(self)

    def SetUnsorted(self):
        """SetUnsorted(SubMap self)"""
        return _stomp.SubMap_SetUnsorted(self)

    def MinResolution(self):
        """MinResolution(SubMap self) -> uint32_t"""
        return _stomp.SubMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(SubMap self) -> uint32_t"""
        return _stomp.SubMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(SubMap self) -> uint8_t"""
        return _stomp.SubMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(SubMap self) -> uint8_t"""
        return _stomp.SubMap_MaxLevel(self)

    def MinWeight(self):
        """MinWeight(SubMap self) -> double"""
        return _stomp.SubMap_MinWeight(self)

    def MaxWeight(self):
        """MaxWeight(SubMap self) -> double"""
        return _stomp.SubMap_MaxWeight(self)

    def LambdaMin(self):
        """LambdaMin(SubMap self) -> double"""
        return _stomp.SubMap_LambdaMin(self)

    def LambdaMax(self):
        """LambdaMax(SubMap self) -> double"""
        return _stomp.SubMap_LambdaMax(self)

    def EtaMin(self):
        """EtaMin(SubMap self) -> double"""
        return _stomp.SubMap_EtaMin(self)

    def EtaMax(self):
        """EtaMax(SubMap self) -> double"""
        return _stomp.SubMap_EtaMax(self)

    def ZMin(self):
        """ZMin(SubMap self) -> double"""
        return _stomp.SubMap_ZMin(self)

    def ZMax(self):
        """ZMax(SubMap self) -> double"""
        return _stomp.SubMap_ZMax(self)

    def Size(self):
        """Size(SubMap self) -> uint32_t"""
        return _stomp.SubMap_Size(self)

    def PixelCount(self, *args):
        """PixelCount(SubMap self, uint32_t resolution) -> uint32_t"""
        return _stomp.SubMap_PixelCount(self, *args)

SubMap_swigregister = _stomp.SubMap_swigregister
SubMap_swigregister(SubMap)

class Map(BaseMap):
    """Proxy of C++ Stomp::Map class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Map, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Map, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::Map self) -> Map
        __init__(Stomp::Map self, PixelVector pix, bool force_resolve=True) -> Map
        __init__(Stomp::Map self, PixelVector pix) -> Map
        __init__(Stomp::Map self, std::string const & InputFile, bool const hpixel_format=True, bool const weighted_map=True) -> Map
        __init__(Stomp::Map self, std::string const & InputFile, bool const hpixel_format=True) -> Map
        __init__(Stomp::Map self, std::string const & InputFile) -> Map
        __init__(Stomp::Map self, GeometricBound bound, double weight=1.0, uint32_t maximum_resolution=MaxPixelResolution, 
            bool verbose=False) -> Map
        __init__(Stomp::Map self, GeometricBound bound, double weight=1.0, uint32_t maximum_resolution=MaxPixelResolution) -> Map
        __init__(Stomp::Map self, GeometricBound bound, double weight=1.0) -> Map
        __init__(Stomp::Map self, GeometricBound bound) -> Map
        """
        this = _stomp.new_Map(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Map
    __del__ = lambda self : None;
    def Initialize(self, *args):
        """
        Initialize(Map self) -> bool
        Initialize(Map self, PixelVector pix, bool force_resolve=True) -> bool
        Initialize(Map self, PixelVector pix) -> bool
        """
        return _stomp.Map_Initialize(self, *args)

    def AddPixel(self, *args):
        """AddPixel(Map self, Pixel pix)"""
        return _stomp.Map_AddPixel(self, *args)

    def FindLocation(self, *args):
        """FindLocation(Map self, AngularCoordinate ang, double & weight) -> bool"""
        return _stomp.Map_FindLocation(self, *args)

    def FindLocationWeight(self, *args):
        """FindLocationWeight(Map self, AngularCoordinate ang) -> double"""
        return _stomp.Map_FindLocationWeight(self, *args)

    def FindUnmaskedStatus(self, *args):
        """
        FindUnmaskedStatus(Map self, Pixel pix) -> int8_t
        FindUnmaskedStatus(Map self, PixelVector pix, std::vector< int8_t,std::allocator< int8_t > > & unmasked_status)
        FindUnmaskedStatus(Map self, Map stomp_map) -> int8_t
        """
        return _stomp.Map_FindUnmaskedStatus(self, *args)

    def FindAverageWeight(self, *args):
        """
        FindAverageWeight(Map self, Pixel pix) -> double
        FindAverageWeight(Map self, PixelVector pix, DoubleVector average_weight)
        FindAverageWeight(Map self, PixelVector pix)
        """
        return _stomp.Map_FindAverageWeight(self, *args)

    def AverageWeight(self):
        """AverageWeight(Map self) -> double"""
        return _stomp.Map_AverageWeight(self)

    def FindMatchingPixels(self, *args):
        """
        FindMatchingPixels(Map self, Pixel pix, PixelVector match_pix, bool use_local_weights=False)
        FindMatchingPixels(Map self, Pixel pix, PixelVector match_pix)
        FindMatchingPixels(Map self, PixelVector pix, PixelVector match_pix, bool use_local_weights=False)
        FindMatchingPixels(Map self, PixelVector pix, PixelVector match_pix)
        """
        return _stomp.Map_FindMatchingPixels(self, *args)

    def Coverage(self, *args):
        """
        Coverage(Map self, PixelVector superpix, uint32_t resolution=HPixResolution, bool calculate_fraction=True)
        Coverage(Map self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(Map self, PixelVector superpix)
        """
        return _stomp.Map_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(Map self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.Map_Covering(self, *args)

    def Soften(self, *args):
        """
        Soften(Map self, Map stomp_map, uint32_t maximum_resolution, bool average_weights=False)
        Soften(Map self, Map stomp_map, uint32_t maximum_resolution)
        Soften(Map self, uint32_t maximum_resolution, bool average_weights=False)
        Soften(Map self, uint32_t maximum_resolution)
        """
        return _stomp.Map_Soften(self, *args)

    def SetMinimumWeight(self, *args):
        """SetMinimumWeight(Map self, double min_weight)"""
        return _stomp.Map_SetMinimumWeight(self, *args)

    def SetMaximumWeight(self, *args):
        """SetMaximumWeight(Map self, double max_weight)"""
        return _stomp.Map_SetMaximumWeight(self, *args)

    def RegionOnlyMap(self, *args):
        """RegionOnlyMap(Map self, int16_t region_index, Map stomp_map) -> bool"""
        return _stomp.Map_RegionOnlyMap(self, *args)

    def RegionExcludedMap(self, *args):
        """RegionExcludedMap(Map self, int16_t region_index, Map stomp_map) -> bool"""
        return _stomp.Map_RegionExcludedMap(self, *args)

    def GenerateSingleRandomPoint(self, *args):
        """
        GenerateSingleRandomPoint(Map self, WeightedAngularCoordinate ang, bool return_local_weight=False, bool use_weighted_sampling=False)
        GenerateSingleRandomPoint(Map self, WeightedAngularCoordinate ang, bool return_local_weight=False)
        GenerateSingleRandomPoint(Map self, WeightedAngularCoordinate ang)
        """
        return _stomp.Map_GenerateSingleRandomPoint(self, *args)

    def GenerateRandomPoints(self, *args):
        """
        GenerateRandomPoints(Map self, AngularVector ang, uint32_t n_point=1, bool use_weighted_sampling=False)
        GenerateRandomPoints(Map self, AngularVector ang, uint32_t n_point=1)
        GenerateRandomPoints(Map self, AngularVector ang)
        GenerateRandomPoints(Map self, WAngularVector ang, WAngularVector input_ang, bool use_weighted_sampling=False)
        GenerateRandomPoints(Map self, WAngularVector ang, WAngularVector input_ang)
        GenerateRandomPoints(Map self, WAngularVector ang, DoubleVector weights, bool use_weighted_sampling=False)
        GenerateRandomPoints(Map self, WAngularVector ang, DoubleVector weights)
        GenerateRandomPoints(Map self, CosmoVector ang, CosmoVector input_ang, bool use_weighted_sampling=False)
        GenerateRandomPoints(Map self, CosmoVector ang, CosmoVector input_ang)
        GenerateRandomPoints(Map self, uint32_t n_point, Stomp::AngularCoordinate::Sphere systemid, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomPoints(Map self, uint32_t n_point, Stomp::AngularCoordinate::Sphere systemid) -> PyObject
        GenerateRandomPoints(Map self, uint32_t n_point, std::string const & system, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomPoints(Map self, uint32_t n_point, std::string const & system) -> PyObject *
        """
        return _stomp.Map_GenerateRandomPoints(self, *args)

    def GenerateRandomEq(self, *args):
        """
        GenerateRandomEq(Map self, uint32_t n_point, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomEq(Map self, uint32_t n_point) -> PyObject *
        """
        return _stomp.Map_GenerateRandomEq(self, *args)

    def GenerateRandomSurvey(self, *args):
        """
        GenerateRandomSurvey(Map self, uint32_t n_point, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomSurvey(Map self, uint32_t n_point) -> PyObject *
        """
        return _stomp.Map_GenerateRandomSurvey(self, *args)

    def GenerateRandomGal(self, *args):
        """
        GenerateRandomGal(Map self, uint32_t n_point, bool use_weighted_sampling=False) -> PyObject
        GenerateRandomGal(Map self, uint32_t n_point) -> PyObject *
        """
        return _stomp.Map_GenerateRandomGal(self, *args)

    def GenerateRandomQuadrantPointsSurvey(self, *args):
        """
        GenerateRandomQuadrantPointsSurvey(Map self, double lambda_center, double eta_center, double R, uint32_t n_point, int quadrant=-1) -> PyObject
        GenerateRandomQuadrantPointsSurvey(Map self, double lambda_center, double eta_center, double R, uint32_t n_point) -> PyObject *
        """
        return _stomp.Map_GenerateRandomQuadrantPointsSurvey(self, *args)

    __swig_setmethods__["INSIDE_MAP"] = _stomp.Map_INSIDE_MAP_set
    __swig_getmethods__["INSIDE_MAP"] = _stomp.Map_INSIDE_MAP_get
    if _newclass:INSIDE_MAP = _swig_property(_stomp.Map_INSIDE_MAP_get, _stomp.Map_INSIDE_MAP_set)
    __swig_setmethods__["FIRST_QUADRANT_OK"] = _stomp.Map_FIRST_QUADRANT_OK_set
    __swig_getmethods__["FIRST_QUADRANT_OK"] = _stomp.Map_FIRST_QUADRANT_OK_get
    if _newclass:FIRST_QUADRANT_OK = _swig_property(_stomp.Map_FIRST_QUADRANT_OK_get, _stomp.Map_FIRST_QUADRANT_OK_set)
    __swig_setmethods__["SECOND_QUADRANT_OK"] = _stomp.Map_SECOND_QUADRANT_OK_set
    __swig_getmethods__["SECOND_QUADRANT_OK"] = _stomp.Map_SECOND_QUADRANT_OK_get
    if _newclass:SECOND_QUADRANT_OK = _swig_property(_stomp.Map_SECOND_QUADRANT_OK_get, _stomp.Map_SECOND_QUADRANT_OK_set)
    __swig_setmethods__["THIRD_QUADRANT_OK"] = _stomp.Map_THIRD_QUADRANT_OK_set
    __swig_getmethods__["THIRD_QUADRANT_OK"] = _stomp.Map_THIRD_QUADRANT_OK_get
    if _newclass:THIRD_QUADRANT_OK = _swig_property(_stomp.Map_THIRD_QUADRANT_OK_get, _stomp.Map_THIRD_QUADRANT_OK_set)
    __swig_setmethods__["FOURTH_QUADRANT_OK"] = _stomp.Map_FOURTH_QUADRANT_OK_set
    __swig_getmethods__["FOURTH_QUADRANT_OK"] = _stomp.Map_FOURTH_QUADRANT_OK_get
    if _newclass:FOURTH_QUADRANT_OK = _swig_property(_stomp.Map_FOURTH_QUADRANT_OK_get, _stomp.Map_FOURTH_QUADRANT_OK_set)
    def QuadrantsContainedMC(self, *args):
        """QuadrantsContainedMC(Map self, AngularCoordinate ang, double radius, Stomp::AngularCoordinate::Sphere coord_system) -> int"""
        return _stomp.Map_QuadrantsContainedMC(self, *args)

    def QuadrantContainedMC(self, *args):
        """QuadrantContainedMC(Map self, AngularCoordinate ang, double radius, int quadrant) -> bool"""
        return _stomp.Map_QuadrantContainedMC(self, *args)

    def Contains(self, *args):
        """
        Contains(Map self, AngularCoordinate ang) -> bool
        Contains(Map self, Pixel pix) -> bool
        Contains(Map self, Map stomp_map) -> bool
        Contains(Map self, PyObject * x1obj, PyObject * x2obj, std::string const & system, PyObject * radobj=None) -> PyObject
        Contains(Map self, PyObject * x1obj, PyObject * x2obj, std::string const & system) -> PyObject
        Contains(Map self, GeometricBound bound, double area_resolution=0.5, double precision=0.01) -> bool
        Contains(Map self, GeometricBound bound, double area_resolution=0.5) -> bool
        Contains(Map self, GeometricBound bound) -> bool
        """
        return _stomp.Map_Contains(self, *args)

    def FindUnmaskedFraction(self, *args):
        """
        FindUnmaskedFraction(Map self, Pixel pix) -> double
        FindUnmaskedFraction(Map self, PixelVector pix, DoubleVector unmasked_fraction)
        FindUnmaskedFraction(Map self, PixelVector pix)
        FindUnmaskedFraction(Map self, Map stomp_map) -> double
        FindUnmaskedFraction(Map self, GeometricBound bound, double area_resolution=0.5, double precision=0.01) -> double
        FindUnmaskedFraction(Map self, GeometricBound bound, double area_resolution=0.5) -> double
        FindUnmaskedFraction(Map self, GeometricBound bound) -> double
        """
        return _stomp.Map_FindUnmaskedFraction(self, *args)

    def Write(self, *args):
        """
        Write(Map self, std::string const & OutputFile, bool hpixel_format=True, bool weighted_map=True) -> bool
        Write(Map self, std::string const & OutputFile, bool hpixel_format=True) -> bool
        Write(Map self, std::string const & OutputFile) -> bool
        """
        return _stomp.Map_Write(self, *args)

    def Read(self, *args):
        """
        Read(Map self, std::string const & InputFile, bool const hpixel_format=True, bool const weighted_map=True) -> bool
        Read(Map self, std::string const & InputFile, bool const hpixel_format=True) -> bool
        Read(Map self, std::string const & InputFile) -> bool
        """
        return _stomp.Map_Read(self, *args)

    def PixelizeBound(self, *args):
        """
        PixelizeBound(Map self, GeometricBound bound, double weight=1.0, uint32_t maximum_resolution=MaxPixelResolution) -> bool
        PixelizeBound(Map self, GeometricBound bound, double weight=1.0) -> bool
        PixelizeBound(Map self, GeometricBound bound) -> bool
        """
        return _stomp.Map_PixelizeBound(self, *args)

    def _FindStartingResolutionLevel(self, *args):
        """_FindStartingResolutionLevel(Map self, double bound_area) -> uint8_t"""
        return _stomp.Map__FindStartingResolutionLevel(self, *args)

    def _FindXYBounds(self, *args):
        """
        _FindXYBounds(Map self, uint8_t const resolution_level, GeometricBound bound, uint32_t & x_min, uint32_t & x_max, 
            uint32_t & y_min, uint32_t & y_max) -> bool
        """
        return _stomp.Map__FindXYBounds(self, *args)

    def ScaleWeight(self, *args):
        """ScaleWeight(Map self, double const weight_scale)"""
        return _stomp.Map_ScaleWeight(self, *args)

    def AddConstantWeight(self, *args):
        """AddConstantWeight(Map self, double const add_weight)"""
        return _stomp.Map_AddConstantWeight(self, *args)

    def InvertWeight(self):
        """InvertWeight(Map self)"""
        return _stomp.Map_InvertWeight(self)

    def IngestMap(self, *args):
        """
        IngestMap(Map self, PixelVector pix, bool destroy_copy=True) -> bool
        IngestMap(Map self, PixelVector pix) -> bool
        IngestMap(Map self, Map stomp_map, bool destroy_copy=True) -> bool
        IngestMap(Map self, Map stomp_map) -> bool
        """
        return _stomp.Map_IngestMap(self, *args)

    def IntersectMap(self, *args):
        """
        IntersectMap(Map self, PixelVector pix) -> bool
        IntersectMap(Map self, Map stomp_map) -> bool
        """
        return _stomp.Map_IntersectMap(self, *args)

    def ExcludeMap(self, *args):
        """
        ExcludeMap(Map self, PixelVector pix, bool destroy_copy=True) -> bool
        ExcludeMap(Map self, PixelVector pix) -> bool
        ExcludeMap(Map self, Map stomp_map, bool destroy_copy=True) -> bool
        ExcludeMap(Map self, Map stomp_map) -> bool
        """
        return _stomp.Map_ExcludeMap(self, *args)

    def AddMap(self, *args):
        """
        AddMap(Map self, PixelVector pix, bool drop_single=True) -> bool
        AddMap(Map self, PixelVector pix) -> bool
        AddMap(Map self, Map stomp_map, bool drop_single=True) -> bool
        AddMap(Map self, Map stomp_map) -> bool
        """
        return _stomp.Map_AddMap(self, *args)

    def MultiplyMap(self, *args):
        """
        MultiplyMap(Map self, PixelVector pix, bool drop_single=True) -> bool
        MultiplyMap(Map self, PixelVector pix) -> bool
        MultiplyMap(Map self, Map stomp_map, bool drop_single=True) -> bool
        MultiplyMap(Map self, Map stomp_map) -> bool
        """
        return _stomp.Map_MultiplyMap(self, *args)

    def ImprintMap(self, *args):
        """
        ImprintMap(Map self, PixelVector pix) -> bool
        ImprintMap(Map self, Map stomp_map) -> bool
        """
        return _stomp.Map_ImprintMap(self, *args)

    def Pixels(self, *args):
        """
        Pixels(Map self, PixelVector pix, uint32_t superpixnum=MaxSuperpixnum)
        Pixels(Map self, PixelVector pix)
        """
        return _stomp.Map_Pixels(self, *args)

    def Begin(self):
        """Begin(Map self) -> Stomp::MapIterator"""
        return _stomp.Map_Begin(self)

    def End(self):
        """End(Map self) -> Stomp::MapIterator"""
        return _stomp.Map_End(self)

    def Iterate(self, *args):
        """Iterate(Map self, Stomp::MapIterator * iter)"""
        return _stomp.Map_Iterate(self, *args)

    def Clear(self, *args):
        """
        Clear(Map self)
        Clear(Map self, uint32_t superpixnum)
        """
        return _stomp.Map_Clear(self, *args)

    def ContainsSuperpixel(self, *args):
        """ContainsSuperpixel(Map self, uint32_t superpixnum) -> bool"""
        return _stomp.Map_ContainsSuperpixel(self, *args)

    def Area(self, *args):
        """
        Area(Map self) -> double
        Area(Map self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_Area(self, *args)

    def MinResolution(self, *args):
        """
        MinResolution(Map self) -> uint32_t
        MinResolution(Map self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_MinResolution(self, *args)

    def MaxResolution(self, *args):
        """
        MaxResolution(Map self) -> uint32_t
        MaxResolution(Map self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_MaxResolution(self, *args)

    def MinLevel(self, *args):
        """
        MinLevel(Map self) -> uint8_t
        MinLevel(Map self, uint32_t superpixnum) -> uint8_t
        """
        return _stomp.Map_MinLevel(self, *args)

    def MaxLevel(self, *args):
        """
        MaxLevel(Map self) -> uint8_t
        MaxLevel(Map self, uint32_t superpixnum) -> uint8_t
        """
        return _stomp.Map_MaxLevel(self, *args)

    def MinWeight(self, *args):
        """
        MinWeight(Map self) -> double
        MinWeight(Map self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_MinWeight(self, *args)

    def MaxWeight(self, *args):
        """
        MaxWeight(Map self) -> double
        MaxWeight(Map self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_MaxWeight(self, *args)

    def Size(self, *args):
        """
        Size(Map self) -> uint32_t
        Size(Map self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_Size(self, *args)

    def Empty(self):
        """Empty(Map self) -> bool"""
        return _stomp.Map_Empty(self)

    def PixelCount(self, *args):
        """PixelCount(Map self, uint32_t resolution) -> uint32_t"""
        return _stomp.Map_PixelCount(self, *args)

Map_swigregister = _stomp.Map_swigregister
Map_swigregister(Map)

class ScalarMap(BaseMap):
    """Proxy of C++ Stomp::ScalarMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarMap, name)
    __repr__ = _swig_repr
    ScalarField = _stomp.ScalarMap_ScalarField
    DensityField = _stomp.ScalarMap_DensityField
    SampledField = _stomp.ScalarMap_SampledField
    def __init__(self, *args): 
        """
        __init__(Stomp::ScalarMap self) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001, bool use_map_weight_as_intensity=False, 
            bool use_map_weight_as_weight=False) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001, bool use_map_weight_as_intensity=False) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, uint32_t resolution) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarMap scalar_map, uint32_t resolution, double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarMap scalar_map, uint32_t resolution) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarMap scalar_map, uint32_t input_resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type, 
            double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarMap scalar_map, uint32_t input_resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarVector pix, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarVector pix, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField) -> ScalarMap
        __init__(Stomp::ScalarMap self, ScalarVector pix) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, AngularCoordinate center, double theta_max, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001, 
            double theta_min=-1.0) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, AngularCoordinate center, double theta_max, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, AngularCoordinate center, double theta_max, uint32_t resolution, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField) -> ScalarMap
        __init__(Stomp::ScalarMap self, Map stomp_map, AngularCoordinate center, double theta_max, uint32_t resolution) -> ScalarMap
        """
        this = _stomp.new_ScalarMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_ScalarMap
    __del__ = lambda self : None;
    def Read(self, *args):
        """
        Read(ScalarMap self, std::string const & InputFile, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField, 
            double min_unmasked_fraction=0.0000001) -> bool
        Read(ScalarMap self, std::string const & InputFile, Stomp::ScalarMap::ScalarMapType scalar_map_type=ScalarField) -> bool
        Read(ScalarMap self, std::string const & InputFile) -> bool
        """
        return _stomp.ScalarMap_Read(self, *args)

    def Write(self, *args):
        """Write(ScalarMap self, std::string const & OutputFile) -> bool"""
        return _stomp.ScalarMap_Write(self, *args)

    def SetResolution(self, *args):
        """SetResolution(ScalarMap self, uint32_t resolution)"""
        return _stomp.ScalarMap_SetResolution(self, *args)

    def InitializeFromMap(self, *args):
        """
        InitializeFromMap(ScalarMap self, Map stomp_map, uint32_t resolution=0, bool use_map_weight_as_intensity=False)
        InitializeFromMap(ScalarMap self, Map stomp_map, uint32_t resolution=0)
        InitializeFromMap(ScalarMap self, Map stomp_map)
        """
        return _stomp.ScalarMap_InitializeFromMap(self, *args)

    def InitializeFromScalarMap(self, *args):
        """
        InitializeFromScalarMap(ScalarMap self, ScalarMap scalar_map, uint32_t resolution=0)
        InitializeFromScalarMap(ScalarMap self, ScalarMap scalar_map)
        """
        return _stomp.ScalarMap_InitializeFromScalarMap(self, *args)

    def InitializeFromScalarPixels(self, *args):
        """
        InitializeFromScalarPixels(ScalarMap self, ScalarVector pix, Stomp::ScalarMap::ScalarMapType map_type=ScalarField)
        InitializeFromScalarPixels(ScalarMap self, ScalarVector pix)
        """
        return _stomp.ScalarMap_InitializeFromScalarPixels(self, *args)

    def AddToMap(self, *args):
        """
        AddToMap(ScalarMap self, AngularCoordinate ang, double object_weight=1.0) -> bool
        AddToMap(ScalarMap self, AngularCoordinate ang) -> bool
        AddToMap(ScalarMap self, WeightedAngularCoordinate ang) -> bool
        AddToMap(ScalarMap self, Pixel pix) -> bool
        """
        return _stomp.ScalarMap_AddToMap(self, *args)

    def Coverage(self, *args):
        """
        Coverage(ScalarMap self, PixelVector superpix, uint32_t resolution=HPixResolution, bool calculate_fraction=True)
        Coverage(ScalarMap self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(ScalarMap self, PixelVector superpix)
        """
        return _stomp.ScalarMap_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(ScalarMap self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.ScalarMap_Covering(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(ScalarMap self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(ScalarMap self, Pixel pix) -> int8_t"""
        return _stomp.ScalarMap_FindUnmaskedStatus(self, *args)

    def Resample(self, *args):
        """Resample(ScalarMap self, ScalarPixel pix)"""
        return _stomp.ScalarMap_Resample(self, *args)

    def FindIntensity(self, *args):
        """FindIntensity(ScalarMap self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindIntensity(self, *args)

    def FindDensity(self, *args):
        """FindDensity(ScalarMap self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindDensity(self, *args)

    def FindPointDensity(self, *args):
        """FindPointDensity(ScalarMap self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindPointDensity(self, *args)

    def FindLocalArea(self, *args):
        """
        FindLocalArea(ScalarMap self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalArea(ScalarMap self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalArea(self, *args)

    def FindLocalIntensity(self, *args):
        """
        FindLocalIntensity(ScalarMap self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalIntensity(ScalarMap self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalIntensity(self, *args)

    def FindLocalAverageIntensity(self, *args):
        """
        FindLocalAverageIntensity(ScalarMap self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalAverageIntensity(ScalarMap self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalAverageIntensity(self, *args)

    def FindLocalDensity(self, *args):
        """
        FindLocalDensity(ScalarMap self, AngularCoordinate ang, double theta_max, double theta_min=-1.0) -> double
        FindLocalDensity(ScalarMap self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalDensity(self, *args)

    def FindLocalPointDensity(self, *args):
        """
        FindLocalPointDensity(ScalarMap self, AngularCoordinate ang, double theta_max, double theta_min=0.0) -> double
        FindLocalPointDensity(ScalarMap self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalPointDensity(self, *args)

    def CalculateMeanIntensity(self):
        """CalculateMeanIntensity(ScalarMap self)"""
        return _stomp.ScalarMap_CalculateMeanIntensity(self)

    def ConvertToOverDensity(self):
        """ConvertToOverDensity(ScalarMap self)"""
        return _stomp.ScalarMap_ConvertToOverDensity(self)

    def ConvertFromOverDensity(self):
        """ConvertFromOverDensity(ScalarMap self)"""
        return _stomp.ScalarMap_ConvertFromOverDensity(self)

    def UseLocalMeanIntensity(self, *args):
        """UseLocalMeanIntensity(ScalarMap self, bool use_local_mean) -> bool"""
        return _stomp.ScalarMap_UseLocalMeanIntensity(self, *args)

    def UsingLocalMeanIntensity(self):
        """UsingLocalMeanIntensity(ScalarMap self) -> bool"""
        return _stomp.ScalarMap_UsingLocalMeanIntensity(self)

    def ImprintMap(self, *args):
        """
        ImprintMap(ScalarMap self, Map stomp_map, bool use_mean_local_intensity=False) -> bool
        ImprintMap(ScalarMap self, Map stomp_map) -> bool
        """
        return _stomp.ScalarMap_ImprintMap(self, *args)

    def AutoCorrelate(self, *args):
        """
        AutoCorrelate(ScalarMap self, Stomp::ThetaIterator theta_iter)
        AutoCorrelate(ScalarMap self, AngularCorrelation wtheta)
        """
        return _stomp.ScalarMap_AutoCorrelate(self, *args)

    def AutoCorrelateWithRegions(self, *args):
        """
        AutoCorrelateWithRegions(ScalarMap self, AngularCorrelation wtheta)
        AutoCorrelateWithRegions(ScalarMap self, Stomp::ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_AutoCorrelateWithRegions(self, *args)

    def CrossCorrelate(self, *args):
        """
        CrossCorrelate(ScalarMap self, ScalarMap scalar_map, AngularCorrelation wtheta)
        CrossCorrelate(ScalarMap self, ScalarMap scalar_map, Stomp::ThetaIterator theta_iter)
        CrossCorrelate(ScalarMap self, WAngularVector ang_vect, AngularCorrelation wtheta)
        CrossCorrelate(ScalarMap self, WAngularVector ang_vect, Stomp::ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_CrossCorrelate(self, *args)

    def CrossCorrelateWithRegions(self, *args):
        """
        CrossCorrelateWithRegions(ScalarMap self, ScalarMap scalar_map, AngularCorrelation wtheta)
        CrossCorrelateWithRegions(ScalarMap self, ScalarMap scalar_map, Stomp::ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_CrossCorrelateWithRegions(self, *args)

    def Variance(self):
        """Variance(ScalarMap self) -> double"""
        return _stomp.ScalarMap_Variance(self)

    def Covariance(self, *args):
        """Covariance(ScalarMap self, ScalarMap scalar_map) -> double"""
        return _stomp.ScalarMap_Covariance(self, *args)

    def VarianceWithErrors(self, *args):
        """VarianceWithErrors(ScalarMap self, double & variance, double & variance_error)"""
        return _stomp.ScalarMap_VarianceWithErrors(self, *args)

    def CovarianceWithErrors(self, *args):
        """CovarianceWithErrors(ScalarMap self, ScalarMap scalar_map, double & covariance, double & covariance_error)"""
        return _stomp.ScalarMap_CovarianceWithErrors(self, *args)

    def Resolution(self):
        """Resolution(ScalarMap self) -> uint32_t"""
        return _stomp.ScalarMap_Resolution(self)

    def Intensity(self):
        """Intensity(ScalarMap self) -> double"""
        return _stomp.ScalarMap_Intensity(self)

    def NPoints(self):
        """NPoints(ScalarMap self) -> int"""
        return _stomp.ScalarMap_NPoints(self)

    def Density(self):
        """Density(ScalarMap self) -> double"""
        return _stomp.ScalarMap_Density(self)

    def PointDensity(self):
        """PointDensity(ScalarMap self) -> double"""
        return _stomp.ScalarMap_PointDensity(self)

    def ScalarPixels(self, *args):
        """ScalarPixels(ScalarMap self, ScalarVector s_pix)"""
        return _stomp.ScalarMap_ScalarPixels(self, *args)

    def Begin(self):
        """Begin(ScalarMap self) -> Stomp::ScalarIterator"""
        return _stomp.ScalarMap_Begin(self)

    def End(self):
        """End(ScalarMap self) -> Stomp::ScalarIterator"""
        return _stomp.ScalarMap_End(self)

    def MeanIntensity(self):
        """MeanIntensity(ScalarMap self) -> double"""
        return _stomp.ScalarMap_MeanIntensity(self)

    def IsOverDensityMap(self):
        """IsOverDensityMap(ScalarMap self) -> bool"""
        return _stomp.ScalarMap_IsOverDensityMap(self)

    def MapType(self):
        """MapType(ScalarMap self) -> Stomp::ScalarMap::ScalarMapType"""
        return _stomp.ScalarMap_MapType(self)

    def Area(self):
        """Area(ScalarMap self) -> double"""
        return _stomp.ScalarMap_Area(self)

    def Size(self):
        """Size(ScalarMap self) -> uint32_t"""
        return _stomp.ScalarMap_Size(self)

    def MinResolution(self):
        """MinResolution(ScalarMap self) -> uint32_t"""
        return _stomp.ScalarMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(ScalarMap self) -> uint32_t"""
        return _stomp.ScalarMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(ScalarMap self) -> uint8_t"""
        return _stomp.ScalarMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(ScalarMap self) -> uint8_t"""
        return _stomp.ScalarMap_MaxLevel(self)

    def Empty(self):
        """Empty(ScalarMap self) -> bool"""
        return _stomp.ScalarMap_Empty(self)

    def Clear(self):
        """Clear(ScalarMap self)"""
        return _stomp.ScalarMap_Clear(self)

ScalarMap_swigregister = _stomp.ScalarMap_swigregister
ScalarMap_swigregister(ScalarMap)

class GeometricBound(_object):
    """Proxy of C++ Stomp::GeometricBound class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricBound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricBound, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(Stomp::GeometricBound self) -> GeometricBound"""
        this = _stomp.new_GeometricBound()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_GeometricBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(GeometricBound self, AngularCoordinate ang) -> bool"""
        return _stomp.GeometricBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(GeometricBound self) -> bool"""
        return _stomp.GeometricBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(GeometricBound self) -> bool"""
        return _stomp.GeometricBound_FindArea(self)

    def CheckPixel(self, *args):
        """CheckPixel(GeometricBound self, Pixel pix) -> bool"""
        return _stomp.GeometricBound_CheckPixel(self, *args)

    def ScorePixel(self, *args):
        """ScorePixel(GeometricBound self, Pixel pix) -> double"""
        return _stomp.GeometricBound_ScorePixel(self, *args)

    def SetArea(self, *args):
        """SetArea(GeometricBound self, double input_area)"""
        return _stomp.GeometricBound_SetArea(self, *args)

    def SetAngularBounds(self, *args):
        """SetAngularBounds(GeometricBound self, double lammin, double lammax, double etamin, double etamax)"""
        return _stomp.GeometricBound_SetAngularBounds(self, *args)

    def SetContinuousBounds(self, *args):
        """SetContinuousBounds(GeometricBound self, bool continuous_bounds)"""
        return _stomp.GeometricBound_SetContinuousBounds(self, *args)

    def Area(self):
        """Area(GeometricBound self) -> double"""
        return _stomp.GeometricBound_Area(self)

    def LambdaMin(self):
        """LambdaMin(GeometricBound self) -> double"""
        return _stomp.GeometricBound_LambdaMin(self)

    def LambdaMax(self):
        """LambdaMax(GeometricBound self) -> double"""
        return _stomp.GeometricBound_LambdaMax(self)

    def EtaMin(self):
        """EtaMin(GeometricBound self) -> double"""
        return _stomp.GeometricBound_EtaMin(self)

    def EtaMax(self):
        """EtaMax(GeometricBound self) -> double"""
        return _stomp.GeometricBound_EtaMax(self)

    def ContinuousBounds(self):
        """ContinuousBounds(GeometricBound self) -> bool"""
        return _stomp.GeometricBound_ContinuousBounds(self)

    def GenerateRandomPoint(self, *args):
        """GenerateRandomPoint(GeometricBound self, AngularCoordinate ang)"""
        return _stomp.GeometricBound_GenerateRandomPoint(self, *args)

    def GenerateRandomPoints(self, *args):
        """GenerateRandomPoints(GeometricBound self, AngularVector angVec, uint32_t n_rand)"""
        return _stomp.GeometricBound_GenerateRandomPoints(self, *args)

GeometricBound_swigregister = _stomp.GeometricBound_swigregister
GeometricBound_swigregister(GeometricBound)

class CircleBound(GeometricBound):
    """Proxy of C++ Stomp::CircleBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircleBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircleBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(Stomp::CircleBound self, AngularCoordinate center_point, double radius) -> CircleBound"""
        this = _stomp.new_CircleBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_CircleBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(CircleBound self, AngularCoordinate ang) -> bool"""
        return _stomp.CircleBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(CircleBound self) -> bool"""
        return _stomp.CircleBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(CircleBound self) -> bool"""
        return _stomp.CircleBound_FindArea(self)

CircleBound_swigregister = _stomp.CircleBound_swigregister
CircleBound_swigregister(CircleBound)

class AnnulusBound(GeometricBound):
    """Proxy of C++ Stomp::AnnulusBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnulusBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AnnulusBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::AnnulusBound self, AngularCoordinate center_point, double min_radius, double max_radius) -> AnnulusBound
        __init__(Stomp::AnnulusBound self, AngularCoordinate center_point, AngularBin angular_bin) -> AnnulusBound
        """
        this = _stomp.new_AnnulusBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AnnulusBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(AnnulusBound self, AngularCoordinate ang) -> bool"""
        return _stomp.AnnulusBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(AnnulusBound self) -> bool"""
        return _stomp.AnnulusBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(AnnulusBound self) -> bool"""
        return _stomp.AnnulusBound_FindArea(self)

AnnulusBound_swigregister = _stomp.AnnulusBound_swigregister
AnnulusBound_swigregister(AnnulusBound)

class WedgeBound(GeometricBound):
    """Proxy of C++ Stomp::WedgeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WedgeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WedgeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::WedgeBound self, AngularCoordinate center_point, double radius, double position_angle_min, double position_angle_max, 
            Stomp::AngularCoordinate::Sphere sphere=Survey) -> WedgeBound
        __init__(Stomp::WedgeBound self, AngularCoordinate center_point, double radius, double position_angle_min, double position_angle_max) -> WedgeBound
        """
        this = _stomp.new_WedgeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_WedgeBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(WedgeBound self, AngularCoordinate ang) -> bool"""
        return _stomp.WedgeBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(WedgeBound self) -> bool"""
        return _stomp.WedgeBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(WedgeBound self) -> bool"""
        return _stomp.WedgeBound_FindArea(self)

WedgeBound_swigregister = _stomp.WedgeBound_swigregister
WedgeBound_swigregister(WedgeBound)

class PolygonBound(GeometricBound):
    """Proxy of C++ Stomp::PolygonBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(Stomp::PolygonBound self, AngularVector ang) -> PolygonBound"""
        this = _stomp.new_PolygonBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_PolygonBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(PolygonBound self, AngularCoordinate ang) -> bool"""
        return _stomp.PolygonBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(PolygonBound self) -> bool"""
        return _stomp.PolygonBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(PolygonBound self) -> bool"""
        return _stomp.PolygonBound_FindArea(self)

PolygonBound_swigregister = _stomp.PolygonBound_swigregister
PolygonBound_swigregister(PolygonBound)

class LongitudeBound(GeometricBound):
    """Proxy of C++ Stomp::LongitudeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongitudeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongitudeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(Stomp::LongitudeBound self, double min_longitude, double max_longitude, Stomp::AngularCoordinate::Sphere sphere) -> LongitudeBound"""
        this = _stomp.new_LongitudeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LongitudeBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(LongitudeBound self, AngularCoordinate ang) -> bool"""
        return _stomp.LongitudeBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(LongitudeBound self) -> bool"""
        return _stomp.LongitudeBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(LongitudeBound self) -> bool"""
        return _stomp.LongitudeBound_FindArea(self)

    def LongitudeMin(self):
        """LongitudeMin(LongitudeBound self) -> double"""
        return _stomp.LongitudeBound_LongitudeMin(self)

    def LongitudeMax(self):
        """LongitudeMax(LongitudeBound self) -> double"""
        return _stomp.LongitudeBound_LongitudeMax(self)

    def Sphere(self):
        """Sphere(LongitudeBound self) -> Stomp::AngularCoordinate::Sphere"""
        return _stomp.LongitudeBound_Sphere(self)

LongitudeBound_swigregister = _stomp.LongitudeBound_swigregister
LongitudeBound_swigregister(LongitudeBound)

class LatitudeBound(GeometricBound):
    """Proxy of C++ Stomp::LatitudeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatitudeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatitudeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(Stomp::LatitudeBound self, double min_latitude, double max_latitude, Stomp::AngularCoordinate::Sphere sphere) -> LatitudeBound"""
        this = _stomp.new_LatitudeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LatitudeBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(LatitudeBound self, AngularCoordinate ang) -> bool"""
        return _stomp.LatitudeBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(LatitudeBound self) -> bool"""
        return _stomp.LatitudeBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(LatitudeBound self) -> bool"""
        return _stomp.LatitudeBound_FindArea(self)

    def LatitudeMin(self):
        """LatitudeMin(LatitudeBound self) -> double"""
        return _stomp.LatitudeBound_LatitudeMin(self)

    def LatitudeMax(self):
        """LatitudeMax(LatitudeBound self) -> double"""
        return _stomp.LatitudeBound_LatitudeMax(self)

    def Sphere(self):
        """Sphere(LatitudeBound self) -> Stomp::AngularCoordinate::Sphere"""
        return _stomp.LatitudeBound_Sphere(self)

LatitudeBound_swigregister = _stomp.LatitudeBound_swigregister
LatitudeBound_swigregister(LatitudeBound)

class LatLonBound(GeometricBound):
    """Proxy of C++ Stomp::LatLonBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatLonBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatLonBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::LatLonBound self, double min_latitude, double max_latitude, double min_longitude, double max_longitude, 
            Stomp::AngularCoordinate::Sphere sphere) -> LatLonBound
        """
        this = _stomp.new_LatLonBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LatLonBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(LatLonBound self, AngularCoordinate ang) -> bool"""
        return _stomp.LatLonBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(LatLonBound self) -> bool"""
        return _stomp.LatLonBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(LatLonBound self) -> bool"""
        return _stomp.LatLonBound_FindArea(self)

    def LongitudeMin(self):
        """LongitudeMin(LatLonBound self) -> double"""
        return _stomp.LatLonBound_LongitudeMin(self)

    def LongitudeMax(self):
        """LongitudeMax(LatLonBound self) -> double"""
        return _stomp.LatLonBound_LongitudeMax(self)

    def LatitudeMin(self):
        """LatitudeMin(LatLonBound self) -> double"""
        return _stomp.LatLonBound_LatitudeMin(self)

    def LatitudeMax(self):
        """LatitudeMax(LatLonBound self) -> double"""
        return _stomp.LatLonBound_LatitudeMax(self)

    def Sphere(self):
        """Sphere(LatLonBound self) -> Stomp::AngularCoordinate::Sphere"""
        return _stomp.LatLonBound_Sphere(self)

LatLonBound_swigregister = _stomp.LatLonBound_swigregister
LatLonBound_swigregister(LatLonBound)

class Cosmology(_object):
    """Proxy of C++ Stomp::Cosmology class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cosmology, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Cosmology, name)
    __repr__ = _swig_repr
    __swig_setmethods__["omega_m"] = _stomp.Cosmology_omega_m_set
    __swig_getmethods__["omega_m"] = _stomp.Cosmology_omega_m_get
    if _newclass:omega_m = _swig_property(_stomp.Cosmology_omega_m_get, _stomp.Cosmology_omega_m_set)
    __swig_setmethods__["h"] = _stomp.Cosmology_h_set
    __swig_getmethods__["h"] = _stomp.Cosmology_h_get
    if _newclass:h = _swig_property(_stomp.Cosmology_h_get, _stomp.Cosmology_h_set)
    __swig_setmethods__["a_"] = _stomp.Cosmology_a__set
    __swig_getmethods__["a_"] = _stomp.Cosmology_a__get
    if _newclass:a_ = _swig_property(_stomp.Cosmology_a__get, _stomp.Cosmology_a__set)
    __swig_setmethods__["b_"] = _stomp.Cosmology_b__set
    __swig_getmethods__["b_"] = _stomp.Cosmology_b__get
    if _newclass:b_ = _swig_property(_stomp.Cosmology_b__get, _stomp.Cosmology_b__set)
    def OmegaM():
        """OmegaM() -> double"""
        return _stomp.Cosmology_OmegaM()

    if _newclass:OmegaM = staticmethod(OmegaM)
    __swig_getmethods__["OmegaM"] = lambda x: OmegaM
    def HubbleConstant():
        """HubbleConstant() -> double"""
        return _stomp.Cosmology_HubbleConstant()

    if _newclass:HubbleConstant = staticmethod(HubbleConstant)
    __swig_getmethods__["HubbleConstant"] = lambda x: HubbleConstant
    def HubbleDistance():
        """HubbleDistance() -> double"""
        return _stomp.Cosmology_HubbleDistance()

    if _newclass:HubbleDistance = staticmethod(HubbleDistance)
    __swig_getmethods__["HubbleDistance"] = lambda x: HubbleDistance
    def OmegaL():
        """OmegaL() -> double"""
        return _stomp.Cosmology_OmegaL()

    if _newclass:OmegaL = staticmethod(OmegaL)
    __swig_getmethods__["OmegaL"] = lambda x: OmegaL
    def SetOmegaM(*args):
        """SetOmegaM(double omega_m)"""
        return _stomp.Cosmology_SetOmegaM(*args)

    if _newclass:SetOmegaM = staticmethod(SetOmegaM)
    __swig_getmethods__["SetOmegaM"] = lambda x: SetOmegaM
    def SetHubbleConstant(*args):
        """SetHubbleConstant(double hubble)"""
        return _stomp.Cosmology_SetHubbleConstant(*args)

    if _newclass:SetHubbleConstant = staticmethod(SetHubbleConstant)
    __swig_getmethods__["SetHubbleConstant"] = lambda x: SetHubbleConstant
    def SetOmegaL(*args):
        """SetOmegaL(double omega_lambda)"""
        return _stomp.Cosmology_SetOmegaL(*args)

    if _newclass:SetOmegaL = staticmethod(SetOmegaL)
    __swig_getmethods__["SetOmegaL"] = lambda x: SetOmegaL
    def ComovingDistance(*args):
        """ComovingDistance(double z) -> double"""
        return _stomp.Cosmology_ComovingDistance(*args)

    if _newclass:ComovingDistance = staticmethod(ComovingDistance)
    __swig_getmethods__["ComovingDistance"] = lambda x: ComovingDistance
    def AngularDiameterDistance(*args):
        """AngularDiameterDistance(double z) -> double"""
        return _stomp.Cosmology_AngularDiameterDistance(*args)

    if _newclass:AngularDiameterDistance = staticmethod(AngularDiameterDistance)
    __swig_getmethods__["AngularDiameterDistance"] = lambda x: AngularDiameterDistance
    def LuminosityDistance(*args):
        """LuminosityDistance(double z) -> double"""
        return _stomp.Cosmology_LuminosityDistance(*args)

    if _newclass:LuminosityDistance = staticmethod(LuminosityDistance)
    __swig_getmethods__["LuminosityDistance"] = lambda x: LuminosityDistance
    def ProjectedDistance(*args):
        """ProjectedDistance(double z, double theta) -> double"""
        return _stomp.Cosmology_ProjectedDistance(*args)

    if _newclass:ProjectedDistance = staticmethod(ProjectedDistance)
    __swig_getmethods__["ProjectedDistance"] = lambda x: ProjectedDistance
    def ProjectedAngle(*args):
        """ProjectedAngle(double z, double radius) -> double"""
        return _stomp.Cosmology_ProjectedAngle(*args)

    if _newclass:ProjectedAngle = staticmethod(ProjectedAngle)
    __swig_getmethods__["ProjectedAngle"] = lambda x: ProjectedAngle
    def __init__(self): 
        """__init__(Stomp::Cosmology self) -> Cosmology"""
        this = _stomp.new_Cosmology()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Cosmology
    __del__ = lambda self : None;
Cosmology_swigregister = _stomp.Cosmology_swigregister
Cosmology_swigregister(Cosmology)
Cosmology.AA_ = _stomp.cvar.Cosmology_AA_
Cosmology.BB_ = _stomp.cvar.Cosmology_BB_

def Cosmology_OmegaM():
  """Cosmology_OmegaM() -> double"""
  return _stomp.Cosmology_OmegaM()

def Cosmology_HubbleConstant():
  """Cosmology_HubbleConstant() -> double"""
  return _stomp.Cosmology_HubbleConstant()

def Cosmology_HubbleDistance():
  """Cosmology_HubbleDistance() -> double"""
  return _stomp.Cosmology_HubbleDistance()

def Cosmology_OmegaL():
  """Cosmology_OmegaL() -> double"""
  return _stomp.Cosmology_OmegaL()

def Cosmology_SetOmegaM(*args):
  """Cosmology_SetOmegaM(double omega_m)"""
  return _stomp.Cosmology_SetOmegaM(*args)

def Cosmology_SetHubbleConstant(*args):
  """Cosmology_SetHubbleConstant(double hubble)"""
  return _stomp.Cosmology_SetHubbleConstant(*args)

def Cosmology_SetOmegaL(*args):
  """Cosmology_SetOmegaL(double omega_lambda)"""
  return _stomp.Cosmology_SetOmegaL(*args)

def Cosmology_ComovingDistance(*args):
  """Cosmology_ComovingDistance(double z) -> double"""
  return _stomp.Cosmology_ComovingDistance(*args)

def Cosmology_AngularDiameterDistance(*args):
  """Cosmology_AngularDiameterDistance(double z) -> double"""
  return _stomp.Cosmology_AngularDiameterDistance(*args)

def Cosmology_LuminosityDistance(*args):
  """Cosmology_LuminosityDistance(double z) -> double"""
  return _stomp.Cosmology_LuminosityDistance(*args)

def Cosmology_ProjectedDistance(*args):
  """Cosmology_ProjectedDistance(double z, double theta) -> double"""
  return _stomp.Cosmology_ProjectedDistance(*args)

def Cosmology_ProjectedAngle(*args):
  """Cosmology_ProjectedAngle(double z, double radius) -> double"""
  return _stomp.Cosmology_ProjectedAngle(*args)

class StompWatch(_object):
    """Proxy of C++ Stomp::StompWatch class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StompWatch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StompWatch, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(Stomp::StompWatch self) -> StompWatch"""
        this = _stomp.new_StompWatch()
        try: self.this.append(this)
        except: self.this = this
    def StartTimer(self):
        """StartTimer(StompWatch self)"""
        return _stomp.StompWatch_StartTimer(self)

    def StopTimer(self):
        """StopTimer(StompWatch self)"""
        return _stomp.StompWatch_StopTimer(self)

    def ElapsedTime(self):
        """ElapsedTime(StompWatch self) -> double"""
        return _stomp.StompWatch_ElapsedTime(self)

    __swig_destroy__ = _stomp.delete_StompWatch
    __del__ = lambda self : None;
StompWatch_swigregister = _stomp.StompWatch_swigregister
StompWatch_swigregister(StompWatch)

class HistogramBin(_object):
    """Proxy of C++ Stomp::HistogramBin class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HistogramBin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HistogramBin, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::HistogramBin self) -> HistogramBin
        __init__(Stomp::HistogramBin self, double bin_min, double bin_max) -> HistogramBin
        """
        this = _stomp.new_HistogramBin(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_HistogramBin
    __del__ = lambda self : None;
    def SetBounds(self, *args):
        """SetBounds(HistogramBin self, double bin_min, double bin_max)"""
        return _stomp.HistogramBin_SetBounds(self, *args)

    def AddToBin(self, *args):
        """
        AddToBin(HistogramBin self, double bin_value, double weight=1.0) -> bool
        AddToBin(HistogramBin self, double bin_value) -> bool
        """
        return _stomp.HistogramBin_AddToBin(self, *args)

    def BinMinimum(self):
        """BinMinimum(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinMinimum(self)

    def BinMaximum(self):
        """BinMaximum(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinMaximum(self)

    def BinCenter(self):
        """BinCenter(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinCenter(self)

    def BinLogCenter(self):
        """BinLogCenter(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinLogCenter(self)

    def BinWeightedCenter(self):
        """BinWeightedCenter(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinWeightedCenter(self)

    def BinAveragedCenter(self):
        """BinAveragedCenter(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinAveragedCenter(self)

    def WithinBin(self, *args):
        """WithinBin(HistogramBin self, double bin_value) -> bool"""
        return _stomp.HistogramBin_WithinBin(self, *args)

    def BinWeight(self):
        """BinWeight(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinWeight(self)

    def BinItems(self):
        """BinItems(HistogramBin self) -> uint32_t"""
        return _stomp.HistogramBin_BinItems(self)

    def BinMeanWeight(self):
        """BinMeanWeight(HistogramBin self) -> double"""
        return _stomp.HistogramBin_BinMeanWeight(self)

HistogramBin_swigregister = _stomp.HistogramBin_swigregister
HistogramBin_swigregister(HistogramBin)

class Histogram(_object):
    """Proxy of C++ Stomp::Histogram class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Histogram, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Histogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::Histogram self) -> Histogram
        __init__(Stomp::Histogram self, double hist_min, double hist_max, uint16_t n_bins, bool log_binning=False) -> Histogram
        __init__(Stomp::Histogram self, double hist_min, double hist_max, uint16_t n_bins) -> Histogram
        """
        this = _stomp.new_Histogram(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Histogram
    __del__ = lambda self : None;
    def SetBounds(self, *args):
        """SetBounds(Histogram self, double bin_min, double bin_max)"""
        return _stomp.Histogram_SetBounds(self, *args)

    def SetNBins(self, *args):
        """SetNBins(Histogram self, uint16_t n_bins)"""
        return _stomp.Histogram_SetNBins(self, *args)

    def SetLogBinning(self, *args):
        """SetLogBinning(Histogram self, bool log_binning) -> bool"""
        return _stomp.Histogram_SetLogBinning(self, *args)

    def AssignBins(self):
        """AssignBins(Histogram self) -> bool"""
        return _stomp.Histogram_AssignBins(self)

    def AddToBin(self, *args):
        """
        AddToBin(Histogram self, double bin_value, double weight=1.0) -> bool
        AddToBin(Histogram self, double bin_value) -> bool
        """
        return _stomp.Histogram_AddToBin(self, *args)

    def Begin(self):
        """Begin(Histogram self) -> Stomp::BinIterator"""
        return _stomp.Histogram_Begin(self)

    def End(self):
        """End(Histogram self) -> Stomp::BinIterator"""
        return _stomp.Histogram_End(self)

    def BoundMin(self):
        """BoundMin(Histogram self) -> double"""
        return _stomp.Histogram_BoundMin(self)

    def BoundMax(self):
        """BoundMax(Histogram self) -> double"""
        return _stomp.Histogram_BoundMax(self)

    def NBins(self):
        """NBins(Histogram self) -> uint16_t"""
        return _stomp.Histogram_NBins(self)

    def LogBinning(self):
        """LogBinning(Histogram self) -> bool"""
        return _stomp.Histogram_LogBinning(self)

    def TotalItems(self):
        """TotalItems(Histogram self) -> uint32_t"""
        return _stomp.Histogram_TotalItems(self)

    def TotalWeight(self):
        """TotalWeight(Histogram self) -> double"""
        return _stomp.Histogram_TotalWeight(self)

    def MeanItemWeight(self):
        """MeanItemWeight(Histogram self) -> double"""
        return _stomp.Histogram_MeanItemWeight(self)

    def MeanBinValue(self):
        """MeanBinValue(Histogram self) -> double"""
        return _stomp.Histogram_MeanBinValue(self)

    def MeanWeightedBinValue(self):
        """MeanWeightedBinValue(Histogram self) -> double"""
        return _stomp.Histogram_MeanWeightedBinValue(self)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(self):
        """_begin_Bins(Histogram self) -> std::vector< Stomp::HistogramBin,std::allocator< Stomp::HistogramBin > >::const_iterator *"""
        return _stomp.Histogram__begin_Bins(self)

    def _deref_Bins(self, *args):
        """_deref_Bins(Histogram self, std::vector< Stomp::HistogramBin,std::allocator< Stomp::HistogramBin > >::const_iterator const * iter) -> HistogramBin"""
        return _stomp.Histogram__deref_Bins(self, *args)

Histogram_swigregister = _stomp.Histogram_swigregister
Histogram_swigregister(Histogram)


def Tokenize(*args):
  """
    Tokenize(std::string const & str, std::vector< std::string,std::allocator< std::string > > & tokens, 
        std::string const & delimiters)
    """
  return _stomp.Tokenize(*args)
class AngularCoordinate(_object):
    """Proxy of C++ Stomp::AngularCoordinate class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularCoordinate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularCoordinate, name)
    __repr__ = _swig_repr
    Survey = _stomp.AngularCoordinate_Survey
    Equatorial = _stomp.AngularCoordinate_Equatorial
    Galactic = _stomp.AngularCoordinate_Galactic
    def __init__(self, *args): 
        """
        __init__(Stomp::AngularCoordinate self, double theta=0.0, double phi=0.0, Stomp::AngularCoordinate::Sphere sphere=Survey, 
            bool radians=False) -> AngularCoordinate
        __init__(Stomp::AngularCoordinate self, double theta=0.0, double phi=0.0, Stomp::AngularCoordinate::Sphere sphere=Survey) -> AngularCoordinate
        __init__(Stomp::AngularCoordinate self, double theta=0.0, double phi=0.0) -> AngularCoordinate
        __init__(Stomp::AngularCoordinate self, double theta=0.0) -> AngularCoordinate
        __init__(Stomp::AngularCoordinate self) -> AngularCoordinate
        __init__(Stomp::AngularCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z) -> AngularCoordinate
        """
        this = _stomp.new_AngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AngularCoordinate
    __del__ = lambda self : None;
    def SetSurveyCoordinates(self, *args):
        """
        SetSurveyCoordinates(AngularCoordinate self, double _lambda, double eta, bool radians=False)
        SetSurveyCoordinates(AngularCoordinate self, double _lambda, double eta)
        """
        return _stomp.AngularCoordinate_SetSurveyCoordinates(self, *args)

    def SetEquatorialCoordinates(self, *args):
        """
        SetEquatorialCoordinates(AngularCoordinate self, double ra, double dec, bool radians=False)
        SetEquatorialCoordinates(AngularCoordinate self, double ra, double dec)
        """
        return _stomp.AngularCoordinate_SetEquatorialCoordinates(self, *args)

    def SetGalacticCoordinates(self, *args):
        """
        SetGalacticCoordinates(AngularCoordinate self, double gal_lon, double gal_lat, bool radians=False)
        SetGalacticCoordinates(AngularCoordinate self, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_SetGalacticCoordinates(self, *args)

    def SetUnitSphereCoordinates(self, *args):
        """
        SetUnitSphereCoordinates(AngularCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z)
        SetUnitSphereCoordinates(AngularCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, Stomp::AngularCoordinate::Sphere sphere)
        """
        return _stomp.AngularCoordinate_SetUnitSphereCoordinates(self, *args)

    def Set(self, *args):
        """
        Set(AngularCoordinate self, double theta, double phi, Stomp::AngularCoordinate::Sphere sphere, bool radians=False)
        Set(AngularCoordinate self, double theta, double phi, Stomp::AngularCoordinate::Sphere sphere)
        """
        return _stomp.AngularCoordinate_Set(self, *args)

    def Lambda(self):
        """Lambda(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_Lambda(self)

    def Eta(self):
        """Eta(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_Eta(self)

    def LambdaRadians(self):
        """LambdaRadians(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_LambdaRadians(self)

    def EtaRadians(self):
        """EtaRadians(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_EtaRadians(self)

    def RA(self):
        """RA(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_RA(self)

    def DEC(self):
        """DEC(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_DEC(self)

    def RARadians(self):
        """RARadians(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_RARadians(self)

    def DECRadians(self):
        """DECRadians(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_DECRadians(self)

    def GalLon(self):
        """GalLon(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_GalLon(self)

    def GalLat(self):
        """GalLat(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_GalLat(self)

    def GalLonRadians(self):
        """GalLonRadians(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_GalLonRadians(self)

    def GalLatRadians(self):
        """GalLatRadians(AngularCoordinate self) -> double"""
        return _stomp.AngularCoordinate_GalLatRadians(self)

    def UnitSphereX(self, *args):
        """
        UnitSphereX(AngularCoordinate self) -> double
        UnitSphereX(AngularCoordinate self, Stomp::AngularCoordinate::Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereX(self, *args)

    def UnitSphereY(self, *args):
        """
        UnitSphereY(AngularCoordinate self) -> double
        UnitSphereY(AngularCoordinate self, Stomp::AngularCoordinate::Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereY(self, *args)

    def UnitSphereZ(self, *args):
        """
        UnitSphereZ(AngularCoordinate self) -> double
        UnitSphereZ(AngularCoordinate self, Stomp::AngularCoordinate::Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereZ(self, *args)

    def AngularDistance(self, *args):
        """AngularDistance(AngularCoordinate self, AngularCoordinate ang) -> double"""
        return _stomp.AngularCoordinate_AngularDistance(self, *args)

    def DotProduct(self, *args):
        """DotProduct(AngularCoordinate self, AngularCoordinate ang) -> double"""
        return _stomp.AngularCoordinate_DotProduct(self, *args)

    def CrossProduct(self, *args):
        """
        CrossProduct(AngularCoordinate self, AngularCoordinate ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> AngularCoordinate
        CrossProduct(AngularCoordinate self, AngularCoordinate ang) -> AngularCoordinate
        """
        return _stomp.AngularCoordinate_CrossProduct(self, *args)

    def GreatCircle(self, *args):
        """
        GreatCircle(AngularCoordinate self, AngularCoordinate ang, AngularCoordinate great_circle, Stomp::AngularCoordinate::Sphere sphere=Equatorial)
        GreatCircle(AngularCoordinate self, AngularCoordinate ang, AngularCoordinate great_circle)
        """
        return _stomp.AngularCoordinate_GreatCircle(self, *args)

    def PositionAngle(self, *args):
        """
        PositionAngle(AngularCoordinate self, AngularCoordinate ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> double
        PositionAngle(AngularCoordinate self, AngularCoordinate ang) -> double
        PositionAngle(AngularCoordinate self, Pixel pix, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> double
        PositionAngle(AngularCoordinate self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_PositionAngle(self, *args)

    def CosPositionAngle(self, *args):
        """
        CosPositionAngle(AngularCoordinate self, AngularCoordinate ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> double
        CosPositionAngle(AngularCoordinate self, AngularCoordinate ang) -> double
        CosPositionAngle(AngularCoordinate self, Pixel pix, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> double
        CosPositionAngle(AngularCoordinate self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_CosPositionAngle(self, *args)

    def SinPositionAngle(self, *args):
        """
        SinPositionAngle(AngularCoordinate self, AngularCoordinate ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> double
        SinPositionAngle(AngularCoordinate self, AngularCoordinate ang) -> double
        SinPositionAngle(AngularCoordinate self, Pixel pix, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> double
        SinPositionAngle(AngularCoordinate self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_SinPositionAngle(self, *args)

    def Rotate(self, *args):
        """
        Rotate(AngularCoordinate self, AngularCoordinate fixed_ang, double rotation_angle, Stomp::AngularCoordinate::Sphere sphere=Equatorial)
        Rotate(AngularCoordinate self, AngularCoordinate fixed_ang, double rotation_angle)
        Rotate(AngularCoordinate self, AngularCoordinate fixed_ang, double rotation_angle, AngularCoordinate rotated_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial)
        Rotate(AngularCoordinate self, AngularCoordinate fixed_ang, double rotation_angle, AngularCoordinate rotated_ang)
        Rotate(AngularCoordinate self, AngularCoordinate fixed_ang, double rotation_angle, Stomp::AngularCoordinate::Sphere sphere, 
            double & unit_sphere_x, double & unit_sphere_y, double & unit_sphere_z)
        """
        return _stomp.AngularCoordinate_Rotate(self, *args)

    def SurveyToGalactic(*args):
        """
        SurveyToGalactic(double _lambda, double eta, double & gal_lon, double & gal_lat, bool radians=False)
        SurveyToGalactic(double _lambda, double eta, double & gal_lon, double & gal_lat)
        """
        return _stomp.AngularCoordinate_SurveyToGalactic(*args)

    if _newclass:SurveyToGalactic = staticmethod(SurveyToGalactic)
    __swig_getmethods__["SurveyToGalactic"] = lambda x: SurveyToGalactic
    def SurveyToEquatorial(*args):
        """
        SurveyToEquatorial(double _lambda, double eta, double & ra, double & dec, bool radians=False)
        SurveyToEquatorial(double _lambda, double eta, double & ra, double & dec)
        """
        return _stomp.AngularCoordinate_SurveyToEquatorial(*args)

    if _newclass:SurveyToEquatorial = staticmethod(SurveyToEquatorial)
    __swig_getmethods__["SurveyToEquatorial"] = lambda x: SurveyToEquatorial
    def EquatorialToSurvey(*args):
        """
        EquatorialToSurvey(double ra, double dec, double & _lambda, double & eta, bool radians=False)
        EquatorialToSurvey(double ra, double dec, double & _lambda, double & eta)
        """
        return _stomp.AngularCoordinate_EquatorialToSurvey(*args)

    if _newclass:EquatorialToSurvey = staticmethod(EquatorialToSurvey)
    __swig_getmethods__["EquatorialToSurvey"] = lambda x: EquatorialToSurvey
    def EquatorialToGalactic(*args):
        """
        EquatorialToGalactic(double ra, double dec, double & gal_lon, double & gal_lat, bool radians=False)
        EquatorialToGalactic(double ra, double dec, double & gal_lon, double & gal_lat)
        """
        return _stomp.AngularCoordinate_EquatorialToGalactic(*args)

    if _newclass:EquatorialToGalactic = staticmethod(EquatorialToGalactic)
    __swig_getmethods__["EquatorialToGalactic"] = lambda x: EquatorialToGalactic
    def GalacticToSurvey(*args):
        """
        GalacticToSurvey(double gal_lon, double gal_lat, double & _lambda, double & eta, bool radians=False)
        GalacticToSurvey(double gal_lon, double gal_lat, double & _lambda, double & eta)
        """
        return _stomp.AngularCoordinate_GalacticToSurvey(*args)

    if _newclass:GalacticToSurvey = staticmethod(GalacticToSurvey)
    __swig_getmethods__["GalacticToSurvey"] = lambda x: GalacticToSurvey
    def GalacticToEquatorial(*args):
        """
        GalacticToEquatorial(double gal_lon, double gal_lat, double & ra, double & dec, bool radians=False)
        GalacticToEquatorial(double gal_lon, double gal_lat, double & ra, double & dec)
        """
        return _stomp.AngularCoordinate_GalacticToEquatorial(*args)

    if _newclass:GalacticToEquatorial = staticmethod(GalacticToEquatorial)
    __swig_getmethods__["GalacticToEquatorial"] = lambda x: GalacticToEquatorial
    def SurveyToXYZ(*args):
        """
        SurveyToXYZ(double _lambda, double eta, double & x, double & y, double & z, bool radians=False)
        SurveyToXYZ(double _lambda, double eta, double & x, double & y, double & z)
        """
        return _stomp.AngularCoordinate_SurveyToXYZ(*args)

    if _newclass:SurveyToXYZ = staticmethod(SurveyToXYZ)
    __swig_getmethods__["SurveyToXYZ"] = lambda x: SurveyToXYZ
    def EquatorialToXYZ(*args):
        """
        EquatorialToXYZ(double ra, double dec, double & x, double & y, double & z, bool radians=False)
        EquatorialToXYZ(double ra, double dec, double & x, double & y, double & z)
        """
        return _stomp.AngularCoordinate_EquatorialToXYZ(*args)

    if _newclass:EquatorialToXYZ = staticmethod(EquatorialToXYZ)
    __swig_getmethods__["EquatorialToXYZ"] = lambda x: EquatorialToXYZ
    def GalacticToXYZ(*args):
        """
        GalacticToXYZ(double gal_lon, double gal_lat, double & x, double & y, double & z, bool radians=False)
        GalacticToXYZ(double gal_lon, double gal_lat, double & x, double & y, double & z)
        """
        return _stomp.AngularCoordinate_GalacticToXYZ(*args)

    if _newclass:GalacticToXYZ = staticmethod(GalacticToXYZ)
    __swig_getmethods__["GalacticToXYZ"] = lambda x: GalacticToXYZ
    def EtaMultiplier(*args):
        """EtaMultiplier(double lam) -> double"""
        return _stomp.AngularCoordinate_EtaMultiplier(*args)

    if _newclass:EtaMultiplier = staticmethod(EtaMultiplier)
    __swig_getmethods__["EtaMultiplier"] = lambda x: EtaMultiplier
    def RAMultiplier(*args):
        """RAMultiplier(double dec) -> double"""
        return _stomp.AngularCoordinate_RAMultiplier(*args)

    if _newclass:RAMultiplier = staticmethod(RAMultiplier)
    __swig_getmethods__["RAMultiplier"] = lambda x: RAMultiplier
    def GalLonMultiplier(*args):
        """GalLonMultiplier(double glat) -> double"""
        return _stomp.AngularCoordinate_GalLonMultiplier(*args)

    if _newclass:GalLonMultiplier = staticmethod(GalLonMultiplier)
    __swig_getmethods__["GalLonMultiplier"] = lambda x: GalLonMultiplier
    def ToAngularVector(*args):
        """
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang) -> bool
        ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToAngularVector(std::string const & input_file, AngularVector ang) -> bool
        """
        return _stomp.AngularCoordinate_ToAngularVector(*args)

    if _newclass:ToAngularVector = staticmethod(ToAngularVector)
    __swig_getmethods__["ToAngularVector"] = lambda x: ToAngularVector
    def FromAngularVector(*args):
        """
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec) -> bool
        FromAngularVector(AngularVector ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromAngularVector(AngularVector ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromAngularVector(AngularVector ang, std::string const & output_file) -> bool
        """
        return _stomp.AngularCoordinate_FromAngularVector(*args)

    if _newclass:FromAngularVector = staticmethod(FromAngularVector)
    __swig_getmethods__["FromAngularVector"] = lambda x: FromAngularVector
AngularCoordinate_swigregister = _stomp.AngularCoordinate_swigregister
AngularCoordinate_swigregister(AngularCoordinate)

def AngularCoordinate_SurveyToGalactic(*args):
  """
    SurveyToGalactic(double _lambda, double eta, double & gal_lon, double & gal_lat, bool radians=False)
    AngularCoordinate_SurveyToGalactic(double _lambda, double eta, double & gal_lon, double & gal_lat)
    """
  return _stomp.AngularCoordinate_SurveyToGalactic(*args)

def AngularCoordinate_SurveyToEquatorial(*args):
  """
    SurveyToEquatorial(double _lambda, double eta, double & ra, double & dec, bool radians=False)
    AngularCoordinate_SurveyToEquatorial(double _lambda, double eta, double & ra, double & dec)
    """
  return _stomp.AngularCoordinate_SurveyToEquatorial(*args)

def AngularCoordinate_EquatorialToSurvey(*args):
  """
    EquatorialToSurvey(double ra, double dec, double & _lambda, double & eta, bool radians=False)
    AngularCoordinate_EquatorialToSurvey(double ra, double dec, double & _lambda, double & eta)
    """
  return _stomp.AngularCoordinate_EquatorialToSurvey(*args)

def AngularCoordinate_EquatorialToGalactic(*args):
  """
    EquatorialToGalactic(double ra, double dec, double & gal_lon, double & gal_lat, bool radians=False)
    AngularCoordinate_EquatorialToGalactic(double ra, double dec, double & gal_lon, double & gal_lat)
    """
  return _stomp.AngularCoordinate_EquatorialToGalactic(*args)

def AngularCoordinate_GalacticToSurvey(*args):
  """
    GalacticToSurvey(double gal_lon, double gal_lat, double & _lambda, double & eta, bool radians=False)
    AngularCoordinate_GalacticToSurvey(double gal_lon, double gal_lat, double & _lambda, double & eta)
    """
  return _stomp.AngularCoordinate_GalacticToSurvey(*args)

def AngularCoordinate_GalacticToEquatorial(*args):
  """
    GalacticToEquatorial(double gal_lon, double gal_lat, double & ra, double & dec, bool radians=False)
    AngularCoordinate_GalacticToEquatorial(double gal_lon, double gal_lat, double & ra, double & dec)
    """
  return _stomp.AngularCoordinate_GalacticToEquatorial(*args)

def AngularCoordinate_SurveyToXYZ(*args):
  """
    SurveyToXYZ(double _lambda, double eta, double & x, double & y, double & z, bool radians=False)
    AngularCoordinate_SurveyToXYZ(double _lambda, double eta, double & x, double & y, double & z)
    """
  return _stomp.AngularCoordinate_SurveyToXYZ(*args)

def AngularCoordinate_EquatorialToXYZ(*args):
  """
    EquatorialToXYZ(double ra, double dec, double & x, double & y, double & z, bool radians=False)
    AngularCoordinate_EquatorialToXYZ(double ra, double dec, double & x, double & y, double & z)
    """
  return _stomp.AngularCoordinate_EquatorialToXYZ(*args)

def AngularCoordinate_GalacticToXYZ(*args):
  """
    GalacticToXYZ(double gal_lon, double gal_lat, double & x, double & y, double & z, bool radians=False)
    AngularCoordinate_GalacticToXYZ(double gal_lon, double gal_lat, double & x, double & y, double & z)
    """
  return _stomp.AngularCoordinate_GalacticToXYZ(*args)

def AngularCoordinate_EtaMultiplier(*args):
  """AngularCoordinate_EtaMultiplier(double lam) -> double"""
  return _stomp.AngularCoordinate_EtaMultiplier(*args)

def AngularCoordinate_RAMultiplier(*args):
  """AngularCoordinate_RAMultiplier(double dec) -> double"""
  return _stomp.AngularCoordinate_RAMultiplier(*args)

def AngularCoordinate_GalLonMultiplier(*args):
  """AngularCoordinate_GalLonMultiplier(double glat) -> double"""
  return _stomp.AngularCoordinate_GalLonMultiplier(*args)

def AngularCoordinate_ToAngularVector(*args):
  """
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang) -> bool
    ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
    ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToAngularVector(std::string const & input_file, AngularVector ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    AngularCoordinate_ToAngularVector(std::string const & input_file, AngularVector ang) -> bool
    """
  return _stomp.AngularCoordinate_ToAngularVector(*args)

def AngularCoordinate_FromAngularVector(*args):
  """
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec) -> bool
    FromAngularVector(AngularVector ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromAngularVector(AngularVector ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    AngularCoordinate_FromAngularVector(AngularVector ang, std::string const & output_file) -> bool
    """
  return _stomp.AngularCoordinate_FromAngularVector(*args)

class WeightedAngularCoordinate(AngularCoordinate):
    """Proxy of C++ Stomp::WeightedAngularCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [AngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedAngularCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedAngularCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::WeightedAngularCoordinate self) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double theta, double phi, double weight, Stomp::AngularCoordinate::Sphere sphere=Survey, 
            bool radians=False) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double theta, double phi, double weight, Stomp::AngularCoordinate::Sphere sphere=Survey) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double theta, double phi, double weight) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double theta, double phi, double weight, FieldDict fields, Stomp::AngularCoordinate::Sphere sphere=Survey, 
            bool radians=False) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double theta, double phi, double weight, FieldDict fields, Stomp::AngularCoordinate::Sphere sphere=Survey) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double theta, double phi, double weight, FieldDict fields) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, double weight) -> WeightedAngularCoordinate
        __init__(Stomp::WeightedAngularCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, double weight, 
            FieldDict fields) -> WeightedAngularCoordinate
        """
        this = _stomp.new_WeightedAngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_WeightedAngularCoordinate
    __del__ = lambda self : None;
    def SetWeight(self, *args):
        """SetWeight(WeightedAngularCoordinate self, double weight)"""
        return _stomp.WeightedAngularCoordinate_SetWeight(self, *args)

    def Weight(self):
        """Weight(WeightedAngularCoordinate self) -> double"""
        return _stomp.WeightedAngularCoordinate_Weight(self)

    def SetField(self, *args):
        """SetField(WeightedAngularCoordinate self, std::string const & field_name, double weight)"""
        return _stomp.WeightedAngularCoordinate_SetField(self, *args)

    def Field(self, *args):
        """Field(WeightedAngularCoordinate self, std::string const & field_name) -> double"""
        return _stomp.WeightedAngularCoordinate_Field(self, *args)

    def NFields(self):
        """NFields(WeightedAngularCoordinate self) -> uint16_t"""
        return _stomp.WeightedAngularCoordinate_NFields(self)

    def HasFields(self):
        """HasFields(WeightedAngularCoordinate self) -> bool"""
        return _stomp.WeightedAngularCoordinate_HasFields(self)

    def FieldNames(self, *args):
        """FieldNames(WeightedAngularCoordinate self, std::vector< std::string,std::allocator< std::string > > & field_names)"""
        return _stomp.WeightedAngularCoordinate_FieldNames(self, *args)

    def CopyFields(self, *args):
        """CopyFields(WeightedAngularCoordinate self, WeightedAngularCoordinate w_ang)"""
        return _stomp.WeightedAngularCoordinate_CopyFields(self, *args)

    def CopyFieldToWeight(self, *args):
        """CopyFieldToWeight(WeightedAngularCoordinate self, std::string const & field_name)"""
        return _stomp.WeightedAngularCoordinate_CopyFieldToWeight(self, *args)

    def RestoreOriginalWeight(self):
        """RestoreOriginalWeight(WeightedAngularCoordinate self)"""
        return _stomp.WeightedAngularCoordinate_RestoreOriginalWeight(self)

    def ToWAngularVector(*args):
        """
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, WAngularVector w_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, WAngularVector w_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, WAngularVector w_ang) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, WAngularVector w_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, WAngularVector w_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, WAngularVector w_ang) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t weight_column=-1) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, int8_t weight_column=-1) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
            uint8_t theta_column=0) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns) -> bool
        """
        return _stomp.WeightedAngularCoordinate_ToWAngularVector(*args)

    if _newclass:ToWAngularVector = staticmethod(ToWAngularVector)
    __swig_getmethods__["ToWAngularVector"] = lambda x: ToWAngularVector
    def FromWAngularVector(*args):
        """
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec) -> bool
        FromWAngularVector(WAngularVector w_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromWAngularVector(WAngularVector w_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, std::string const & output_file) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, uint8_t weight_column=2) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
            uint8_t theta_column=0) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file) -> bool
        """
        return _stomp.WeightedAngularCoordinate_FromWAngularVector(*args)

    if _newclass:FromWAngularVector = staticmethod(FromWAngularVector)
    __swig_getmethods__["FromWAngularVector"] = lambda x: FromWAngularVector
    def AddField(*args):
        """AddField(WAngularVector w_ang, std::string const & field_name, DoubleVector field_value) -> bool"""
        return _stomp.WeightedAngularCoordinate_AddField(*args)

    if _newclass:AddField = staticmethod(AddField)
    __swig_getmethods__["AddField"] = lambda x: AddField
WeightedAngularCoordinate_swigregister = _stomp.WeightedAngularCoordinate_swigregister
WeightedAngularCoordinate_swigregister(WeightedAngularCoordinate)

def WeightedAngularCoordinate_ToWAngularVector(*args):
  """
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, WAngularVector w_ang, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, WAngularVector w_ang, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, WAngularVector w_ang) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, WAngularVector w_ang, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, WAngularVector w_ang, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, WAngularVector w_ang) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
        int8_t weight_column=-1) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
        uint8_t theta_column=0, uint8_t phi_column=1, int8_t weight_column=-1) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
        uint8_t theta_column=0, uint8_t phi_column=1) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
        uint8_t theta_column=0) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    WeightedAngularCoordinate_ToWAngularVector(std::string const & input_file, WAngularVector w_ang, FieldColumnDict field_columns) -> bool
    """
  return _stomp.WeightedAngularCoordinate_ToWAngularVector(*args)

def WeightedAngularCoordinate_FromWAngularVector(*args):
  """
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec) -> bool
    FromWAngularVector(WAngularVector w_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromWAngularVector(WAngularVector w_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    FromWAngularVector(WAngularVector w_ang, std::string const & output_file) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
        uint8_t theta_column=0, uint8_t phi_column=1, uint8_t weight_column=2) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
        uint8_t theta_column=0, uint8_t phi_column=1) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False, 
        uint8_t theta_column=0) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    WeightedAngularCoordinate_FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, std::string const & output_file) -> bool
    """
  return _stomp.WeightedAngularCoordinate_FromWAngularVector(*args)

def WeightedAngularCoordinate_AddField(*args):
  """WeightedAngularCoordinate_AddField(WAngularVector w_ang, std::string const & field_name, DoubleVector field_value) -> bool"""
  return _stomp.WeightedAngularCoordinate_AddField(*args)

class CosmoCoordinate(WeightedAngularCoordinate):
    """Proxy of C++ Stomp::CosmoCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [WeightedAngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosmoCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [WeightedAngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CosmoCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::CosmoCoordinate self) -> CosmoCoordinate
        __init__(Stomp::CosmoCoordinate self, double theta, double phi, double redshift, double weight, Stomp::AngularCoordinate::Sphere sphere=Survey, 
            bool radians=False) -> CosmoCoordinate
        __init__(Stomp::CosmoCoordinate self, double theta, double phi, double redshift, double weight, Stomp::AngularCoordinate::Sphere sphere=Survey) -> CosmoCoordinate
        __init__(Stomp::CosmoCoordinate self, double theta, double phi, double redshift, double weight) -> CosmoCoordinate
        __init__(Stomp::CosmoCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, double redshift, 
            double weight) -> CosmoCoordinate
        """
        this = _stomp.new_CosmoCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_CosmoCoordinate
    __del__ = lambda self : None;
    def ProjectedRadius(self, *args):
        """ProjectedRadius(CosmoCoordinate self, AngularCoordinate ang) -> double"""
        return _stomp.CosmoCoordinate_ProjectedRadius(self, *args)

    def DotProduct(self, *args):
        """DotProduct(CosmoCoordinate self, CosmoCoordinate ang) -> double"""
        return _stomp.CosmoCoordinate_DotProduct(self, *args)

    def ComovingDistance(self):
        """ComovingDistance(CosmoCoordinate self) -> double"""
        return _stomp.CosmoCoordinate_ComovingDistance(self)

    def AngularDiameterDistance(self):
        """AngularDiameterDistance(CosmoCoordinate self) -> double"""
        return _stomp.CosmoCoordinate_AngularDiameterDistance(self)

    def LuminosityDistance(self):
        """LuminosityDistance(CosmoCoordinate self) -> double"""
        return _stomp.CosmoCoordinate_LuminosityDistance(self)

    def Redshift(self):
        """Redshift(CosmoCoordinate self) -> double"""
        return _stomp.CosmoCoordinate_Redshift(self)

    def SetRedshift(self, *args):
        """SetRedshift(CosmoCoordinate self, double redshift)"""
        return _stomp.CosmoCoordinate_SetRedshift(self, *args)

    def ToCosmoVector(*args):
        """
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, DoubleVector weightVec, 
            CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, DoubleVector weightVec, 
            CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, DoubleVector weightVec, 
            CosmoVector z_ang) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, double weight, 
            CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, double weight, 
            CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, double weight, 
            CosmoVector z_ang) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
            uint8_t redshift_column=2, int8_t weight_column=-1) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
            uint8_t redshift_column=2) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToCosmoVector(std::string const & input_file, CosmoVector z_ang) -> bool
        """
        return _stomp.CosmoCoordinate_ToCosmoVector(*args)

    if _newclass:ToCosmoVector = staticmethod(ToCosmoVector)
    __swig_getmethods__["ToCosmoVector"] = lambda x: ToCosmoVector
    def FromCosmoVector(*args):
        """
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec) -> bool
        FromCosmoVector(CosmoVector z_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromCosmoVector(CosmoVector z_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromCosmoVector(CosmoVector z_ang, std::string const & output_file) -> bool
        """
        return _stomp.CosmoCoordinate_FromCosmoVector(*args)

    if _newclass:FromCosmoVector = staticmethod(FromCosmoVector)
    __swig_getmethods__["FromCosmoVector"] = lambda x: FromCosmoVector
CosmoCoordinate_swigregister = _stomp.CosmoCoordinate_swigregister
CosmoCoordinate_swigregister(CosmoCoordinate)

def CosmoCoordinate_ToCosmoVector(*args):
  """
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, DoubleVector weightVec, 
        CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, DoubleVector weightVec, 
        CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, DoubleVector weightVec, 
        CosmoVector z_ang) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, double weight, 
        CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, double weight, 
        CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, double weight, 
        CosmoVector z_ang) -> bool
    ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
        uint8_t redshift_column=2, int8_t weight_column=-1) -> bool
    ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
        uint8_t redshift_column=2) -> bool
    ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
    ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToCosmoVector(std::string const & input_file, CosmoVector z_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    CosmoCoordinate_ToCosmoVector(std::string const & input_file, CosmoVector z_ang) -> bool
    """
  return _stomp.CosmoCoordinate_ToCosmoVector(*args)

def CosmoCoordinate_FromCosmoVector(*args):
  """
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec) -> bool
    FromCosmoVector(CosmoVector z_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromCosmoVector(CosmoVector z_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    CosmoCoordinate_FromCosmoVector(CosmoVector z_ang, std::string const & output_file) -> bool
    """
  return _stomp.CosmoCoordinate_FromCosmoVector(*args)

class IndexedAngularCoordinate(AngularCoordinate):
    """Proxy of C++ Stomp::IndexedAngularCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [AngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedAngularCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedAngularCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::IndexedAngularCoordinate self) -> IndexedAngularCoordinate
        __init__(Stomp::IndexedAngularCoordinate self, double theta, double phi, uint32_t index, Stomp::AngularCoordinate::Sphere sphere=Survey, 
            bool radians=False) -> IndexedAngularCoordinate
        __init__(Stomp::IndexedAngularCoordinate self, double theta, double phi, uint32_t index, Stomp::AngularCoordinate::Sphere sphere=Survey) -> IndexedAngularCoordinate
        __init__(Stomp::IndexedAngularCoordinate self, double theta, double phi, uint32_t index) -> IndexedAngularCoordinate
        __init__(Stomp::IndexedAngularCoordinate self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, uint32_t index) -> IndexedAngularCoordinate
        """
        this = _stomp.new_IndexedAngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedAngularCoordinate
    __del__ = lambda self : None;
    def SetIndex(self, *args):
        """SetIndex(IndexedAngularCoordinate self, uint32_t index)"""
        return _stomp.IndexedAngularCoordinate_SetIndex(self, *args)

    def Index(self):
        """Index(IndexedAngularCoordinate self) -> uint32_t"""
        return _stomp.IndexedAngularCoordinate_Index(self)

    def ToIAngularVector(*args):
        """
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, IAngularVector i_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, IAngularVector i_ang, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, IAngularVector i_ang) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang) -> bool
        ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t index_column=-1) -> bool
        ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False, uint8_t theta_column=0) -> bool
        ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        ToIAngularVector(std::string const & input_file, IAngularVector i_ang) -> bool
        """
        return _stomp.IndexedAngularCoordinate_ToIAngularVector(*args)

    if _newclass:ToIAngularVector = staticmethod(ToIAngularVector)
    __swig_getmethods__["ToIAngularVector"] = lambda x: ToIAngularVector
    def FromIAngularVector(*args):
        """
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec) -> bool
        FromIAngularVector(IAngularVector i_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool radians=False) -> bool
        FromIAngularVector(IAngularVector i_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        FromIAngularVector(IAngularVector i_ang, std::string const & output_file) -> bool
        """
        return _stomp.IndexedAngularCoordinate_FromIAngularVector(*args)

    if _newclass:FromIAngularVector = staticmethod(FromIAngularVector)
    __swig_getmethods__["FromIAngularVector"] = lambda x: FromIAngularVector
IndexedAngularCoordinate_swigregister = _stomp.IndexedAngularCoordinate_swigregister
IndexedAngularCoordinate_swigregister(IndexedAngularCoordinate)

def IndexedAngularCoordinate_ToIAngularVector(*args):
  """
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, IAngularVector i_ang, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, IAngularVector i_ang, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, IAngularVector i_ang) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang) -> bool
    ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1, 
        int8_t index_column=-1) -> bool
    ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
    ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False, uint8_t theta_column=0) -> bool
    ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    ToIAngularVector(std::string const & input_file, IAngularVector i_ang, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    IndexedAngularCoordinate_ToIAngularVector(std::string const & input_file, IAngularVector i_ang) -> bool
    """
  return _stomp.IndexedAngularCoordinate_ToIAngularVector(*args)

def IndexedAngularCoordinate_FromIAngularVector(*args):
  """
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool radians=False) -> bool
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec) -> bool
    FromIAngularVector(IAngularVector i_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
        bool radians=False) -> bool
    FromIAngularVector(IAngularVector i_ang, std::string const & output_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
    IndexedAngularCoordinate_FromIAngularVector(IAngularVector i_ang, std::string const & output_file) -> bool
    """
  return _stomp.IndexedAngularCoordinate_FromIAngularVector(*args)

class TreePixel(Pixel):
    """Proxy of C++ Stomp::TreePixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TreePixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::TreePixel self) -> TreePixel
        __init__(Stomp::TreePixel self, uint32_t const resolution, uint32_t const pixnum, uint16_t const maximum_points=200) -> TreePixel
        __init__(Stomp::TreePixel self, uint32_t const resolution, uint32_t const pixnum) -> TreePixel
        __init__(Stomp::TreePixel self, AngularCoordinate ang, uint32_t const resolution, uint16_t const maximum_points=200) -> TreePixel
        __init__(Stomp::TreePixel self, AngularCoordinate ang, uint32_t const resolution) -> TreePixel
        __init__(Stomp::TreePixel self, uint32_t const x, uint32_t const y, uint32_t const resolution, uint16_t const maximum_points=200) -> TreePixel
        __init__(Stomp::TreePixel self, uint32_t const x, uint32_t const y, uint32_t const resolution) -> TreePixel
        """
        this = _stomp.new_TreePixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreePixel
    __del__ = lambda self : None;
    def _InitializeSubPixels(self):
        """_InitializeSubPixels(TreePixel self) -> bool"""
        return _stomp.TreePixel__InitializeSubPixels(self)

    def DirectPairCount(self, *args):
        """
        DirectPairCount(TreePixel self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> uint32_t
        DirectPairCount(TreePixel self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        """
        return _stomp.TreePixel_DirectPairCount(self, *args)

    def FindPairs(self, *args):
        """
        FindPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> uint32_t
        FindPairs(TreePixel self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        FindPairs(TreePixel self, AngularCoordinate ang, double theta_min, double theta_max) -> uint32_t
        FindPairs(TreePixel self, AngularCoordinate ang, double theta_max) -> uint32_t
        FindPairs(TreePixel self, AngularVector ang, AngularBin theta, int16_t region=-1)
        FindPairs(TreePixel self, AngularVector ang, AngularBin theta)
        FindPairs(TreePixel self, AngularVector ang, AngularCorrelation wtheta, int16_t region=-1)
        FindPairs(TreePixel self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreePixel_FindPairs(self, *args)

    def DirectWeightedPairs(self, *args):
        """
        DirectWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> double
        DirectWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta) -> double
        DirectWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta, int16_t region=-1) -> double
        DirectWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        DirectWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, std::string const & field_name, int16_t region=-1) -> double
        DirectWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, std::string const & field_name) -> double
        DirectWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta, std::string const & field_name, 
            int16_t region=-1) -> double
        DirectWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta, std::string const & field_name) -> double
        DirectWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, AngularBin theta, 
            std::string const & field_name, int16_t region=-1) -> double
        DirectWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, AngularBin theta, 
            std::string const & field_name) -> double
        """
        return _stomp.TreePixel_DirectWeightedPairs(self, *args)

    def FindWeightedPairs(self, *args):
        """
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, int16_t region=-1) -> double
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta) -> double
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, double theta_max) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta, int16_t region=-1) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, double theta_max) -> double
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularBin theta, int16_t region=-1)
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularBin theta)
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularCorrelation wtheta, int16_t region=-1)
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularBin theta, int16_t region=-1)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularCorrelation wtheta, int16_t region=-1)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, std::string const & field_name, int16_t region=-1) -> double
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, AngularBin theta, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, double theta_min, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, AngularCoordinate ang, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularBin theta, std::string const & field_name, int16_t region=-1)
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularBin theta, std::string const & field_name)
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularCorrelation wtheta, std::string const & field_name, int16_t region=-1)
        FindWeightedPairs(TreePixel self, AngularVector ang, AngularCorrelation wtheta, std::string const & field_name)
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta, std::string const & field_name, 
            int16_t region=-1) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, AngularBin theta, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, double theta_min, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularBin theta, std::string const & field_name, int16_t region=-1)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularBin theta, std::string const & field_name)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularCorrelation wtheta, std::string const & field_name, 
            int16_t region=-1)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, AngularCorrelation wtheta, std::string const & field_name)
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, AngularBin theta, 
            std::string const & field_name, int16_t region=-1) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, AngularBin theta, 
            std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, double theta_min, 
            double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, double theta_max, 
            std::string const & field_name) -> double
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, std::string const & ang_field_name, AngularBin theta, std::string const & field_name, 
            int16_t region=-1)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, std::string const & ang_field_name, AngularBin theta, std::string const & field_name)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, std::string const & ang_field_name, AngularCorrelation wtheta, 
            std::string const & field_name, int16_t region=-1)
        FindWeightedPairs(TreePixel self, WAngularVector w_ang, std::string const & ang_field_name, AngularCorrelation wtheta, 
            std::string const & field_name)
        """
        return _stomp.TreePixel_FindWeightedPairs(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(TreePixel self, AngularCoordinate ang, uint8_t n_neighbors, WAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.TreePixel_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(TreePixel self, AngularCoordinate ang, WeightedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.TreePixel_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(TreePixel self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t & nodes_visited) -> double"""
        return _stomp.TreePixel_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(TreePixel self, AngularCoordinate ang, uint16_t & nodes_visited) -> double"""
        return _stomp.TreePixel_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(TreePixel self, AngularCoordinate ang, double max_distance, WeightedAngularCoordinate match_ang) -> bool"""
        return _stomp.TreePixel_ClosestMatch(self, *args)

    def InitializeCorners(self):
        """InitializeCorners(TreePixel self)"""
        return _stomp.TreePixel_InitializeCorners(self)

    def AddPoint(self, *args):
        """
        AddPoint(TreePixel self, WeightedAngularCoordinate w_ang) -> bool
        AddPoint(TreePixel self, AngularCoordinate ang, double object_weight=1.0) -> bool
        AddPoint(TreePixel self, AngularCoordinate ang) -> bool
        """
        return _stomp.TreePixel_AddPoint(self, *args)

    def NPoints(self, *args):
        """
        NPoints(TreePixel self) -> uint32_t
        NPoints(TreePixel self, Pixel pix) -> uint32_t
        """
        return _stomp.TreePixel_NPoints(self, *args)

    def PixelWeight(self, *args):
        """PixelWeight(TreePixel self, Pixel pix) -> double"""
        return _stomp.TreePixel_PixelWeight(self, *args)

    def Coverage(self, *args):
        """
        Coverage(TreePixel self) -> double
        Coverage(TreePixel self, Pixel pix) -> double
        """
        return _stomp.TreePixel_Coverage(self, *args)

    def Points(self, *args):
        """
        Points(TreePixel self, WAngularVector w_ang)
        Points(TreePixel self, WAngularVector w_ang, Pixel pix)
        """
        return _stomp.TreePixel_Points(self, *args)

    def Nodes(self):
        """Nodes(TreePixel self) -> uint16_t"""
        return _stomp.TreePixel_Nodes(self)

    def AddToWeight(self, *args):
        """AddToWeight(TreePixel self, double weight)"""
        return _stomp.TreePixel_AddToWeight(self, *args)

    def FieldTotal(self, *args):
        """
        FieldTotal(TreePixel self, std::string const & field_name) -> double
        FieldTotal(TreePixel self, std::string const & field_name, Pixel pix) -> double
        """
        return _stomp.TreePixel_FieldTotal(self, *args)

    def AddToField(self, *args):
        """AddToField(TreePixel self, std::string const & field_name, double weight)"""
        return _stomp.TreePixel_AddToField(self, *args)

    def NField(self):
        """NField(TreePixel self) -> uint16_t"""
        return _stomp.TreePixel_NField(self)

    def HasFields(self):
        """HasFields(TreePixel self) -> bool"""
        return _stomp.TreePixel_HasFields(self)

    def FieldNames(self, *args):
        """FieldNames(TreePixel self, std::vector< std::string,std::allocator< std::string > > & field_names)"""
        return _stomp.TreePixel_FieldNames(self, *args)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(TreePixel self, uint16_t maximum_points)"""
        return _stomp.TreePixel_SetPixelCapacity(self, *args)

    def PixelCapacity(self):
        """PixelCapacity(TreePixel self) -> uint16_t"""
        return _stomp.TreePixel_PixelCapacity(self)

    def HasPoints(self):
        """HasPoints(TreePixel self) -> bool"""
        return _stomp.TreePixel_HasPoints(self)

    def HasNodes(self):
        """HasNodes(TreePixel self) -> bool"""
        return _stomp.TreePixel_HasNodes(self)

    def Clear(self):
        """Clear(TreePixel self)"""
        return _stomp.TreePixel_Clear(self)

    def UnitSphereX(self):
        """UnitSphereX(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereZ(self)

    def UnitSphereX_UL(self):
        """UnitSphereX_UL(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereX_UL(self)

    def UnitSphereY_UL(self):
        """UnitSphereY_UL(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereY_UL(self)

    def UnitSphereZ_UL(self):
        """UnitSphereZ_UL(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_UL(self)

    def UnitSphereX_UR(self):
        """UnitSphereX_UR(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereX_UR(self)

    def UnitSphereY_UR(self):
        """UnitSphereY_UR(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereY_UR(self)

    def UnitSphereZ_UR(self):
        """UnitSphereZ_UR(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_UR(self)

    def UnitSphereX_LL(self):
        """UnitSphereX_LL(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereX_LL(self)

    def UnitSphereY_LL(self):
        """UnitSphereY_LL(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereY_LL(self)

    def UnitSphereZ_LL(self):
        """UnitSphereZ_LL(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_LL(self)

    def UnitSphereX_LR(self):
        """UnitSphereX_LR(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereX_LR(self)

    def UnitSphereY_LR(self):
        """UnitSphereY_LR(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereY_LR(self)

    def UnitSphereZ_LR(self):
        """UnitSphereZ_LR(TreePixel self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_LR(self)

    def WithinAnnulus(self, *args):
        """WithinAnnulus(TreePixel self, AngularBin theta, PixelVector pix, bool check_full_pixel)"""
        return _stomp.TreePixel_WithinAnnulus(self, *args)

TreePixel_swigregister = _stomp.TreePixel_swigregister
TreePixel_swigregister(TreePixel)

class NearestNeighborPixel(_object):
    """Proxy of C++ Stomp::NearestNeighborPixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborPixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborPixel, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(NearestNeighborPixel self, Stomp::DistancePixelPair const & x, Stomp::DistancePixelPair const & y) -> int"""
        return _stomp.NearestNeighborPixel___call__(self, *args)

    def __init__(self): 
        """__init__(Stomp::NearestNeighborPixel self) -> NearestNeighborPixel"""
        this = _stomp.new_NearestNeighborPixel()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborPixel
    __del__ = lambda self : None;
NearestNeighborPixel_swigregister = _stomp.NearestNeighborPixel_swigregister
NearestNeighborPixel_swigregister(NearestNeighborPixel)

class NearestNeighborPoint(_object):
    """Proxy of C++ Stomp::NearestNeighborPoint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborPoint, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(NearestNeighborPoint self, Stomp::DistancePointPair const & x, Stomp::DistancePointPair const & y) -> int"""
        return _stomp.NearestNeighborPoint___call__(self, *args)

    def __init__(self): 
        """__init__(Stomp::NearestNeighborPoint self) -> NearestNeighborPoint"""
        this = _stomp.new_NearestNeighborPoint()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborPoint
    __del__ = lambda self : None;
NearestNeighborPoint_swigregister = _stomp.NearestNeighborPoint_swigregister
NearestNeighborPoint_swigregister(NearestNeighborPoint)

class TreeNeighbor(_object):
    """Proxy of C++ Stomp::TreeNeighbor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeNeighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeNeighbor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::TreeNeighbor self, AngularCoordinate reference_ang, uint8_t n_neighbors=1) -> TreeNeighbor
        __init__(Stomp::TreeNeighbor self, AngularCoordinate reference_ang) -> TreeNeighbor
        """
        this = _stomp.new_TreeNeighbor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreeNeighbor
    __del__ = lambda self : None;
    def NearestNeighbors(self, *args):
        """
        NearestNeighbors(TreeNeighbor self, WAngularVector w_ang, bool save_neighbors=True)
        NearestNeighbors(TreeNeighbor self, WAngularVector w_ang)
        """
        return _stomp.TreeNeighbor_NearestNeighbors(self, *args)

    def Neighbors(self):
        """Neighbors(TreeNeighbor self) -> uint8_t"""
        return _stomp.TreeNeighbor_Neighbors(self)

    def MaxNeighbors(self):
        """MaxNeighbors(TreeNeighbor self) -> uint8_t"""
        return _stomp.TreeNeighbor_MaxNeighbors(self)

    def TestPoint(self, *args):
        """TestPoint(TreeNeighbor self, WeightedAngularCoordinate test_ang) -> bool"""
        return _stomp.TreeNeighbor_TestPoint(self, *args)

    def MaxDistance(self):
        """MaxDistance(TreeNeighbor self) -> double"""
        return _stomp.TreeNeighbor_MaxDistance(self)

    def MaxAngularDistance(self):
        """MaxAngularDistance(TreeNeighbor self) -> double"""
        return _stomp.TreeNeighbor_MaxAngularDistance(self)

    def NodesVisited(self):
        """NodesVisited(TreeNeighbor self) -> uint16_t"""
        return _stomp.TreeNeighbor_NodesVisited(self)

    def AddNode(self):
        """AddNode(TreeNeighbor self)"""
        return _stomp.TreeNeighbor_AddNode(self)

TreeNeighbor_swigregister = _stomp.TreeNeighbor_swigregister
TreeNeighbor_swigregister(TreeNeighbor)

class IndexedTreePixel(Pixel):
    """Proxy of C++ Stomp::IndexedTreePixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreePixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreePixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::IndexedTreePixel self) -> IndexedTreePixel
        __init__(Stomp::IndexedTreePixel self, uint32_t const resolution, uint32_t const pixnum, uint16_t const maximum_points=200) -> IndexedTreePixel
        __init__(Stomp::IndexedTreePixel self, uint32_t const resolution, uint32_t const pixnum) -> IndexedTreePixel
        __init__(Stomp::IndexedTreePixel self, AngularCoordinate ang, uint32_t const resolution, uint16_t const maximum_points=200) -> IndexedTreePixel
        __init__(Stomp::IndexedTreePixel self, AngularCoordinate ang, uint32_t const resolution) -> IndexedTreePixel
        __init__(Stomp::IndexedTreePixel self, uint32_t const x, uint32_t const y, uint32_t const resolution, uint16_t const maximum_points=200) -> IndexedTreePixel
        __init__(Stomp::IndexedTreePixel self, uint32_t const x, uint32_t const y, uint32_t const resolution) -> IndexedTreePixel
        """
        this = _stomp.new_IndexedTreePixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreePixel
    __del__ = lambda self : None;
    def FindPairs(self, *args):
        """
        FindPairs(IndexedTreePixel self, AngularCoordinate ang, AngularBin theta, IAngularVector i_angVec)
        FindPairs(IndexedTreePixel self, AngularCoordinate ang, AngularBin theta, IndexVector pair_indices)
        FindPairs(IndexedTreePixel self, AngularCoordinate ang, double theta_min, double theta_max, IAngularVector i_angVec)
        FindPairs(IndexedTreePixel self, AngularCoordinate ang, double theta_min, double theta_max, IndexVector pair_indices)
        FindPairs(IndexedTreePixel self, AngularCoordinate ang, double theta_max, IAngularVector pair_indices)
        FindPairs(IndexedTreePixel self, AngularCoordinate ang, double theta_max, IndexVector pair_indices)
        """
        return _stomp.IndexedTreePixel_FindPairs(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(IndexedTreePixel self, AngularCoordinate ang, uint8_t n_neighbors, IAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.IndexedTreePixel_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(IndexedTreePixel self, AngularCoordinate ang, IndexedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.IndexedTreePixel_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(IndexedTreePixel self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t & nodes_visited) -> double"""
        return _stomp.IndexedTreePixel_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(IndexedTreePixel self, AngularCoordinate ang, uint16_t & nodes_visited) -> double"""
        return _stomp.IndexedTreePixel_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(IndexedTreePixel self, AngularCoordinate ang, double max_distance, IndexedAngularCoordinate match_ang) -> bool"""
        return _stomp.IndexedTreePixel_ClosestMatch(self, *args)

    def InitializeCorners(self):
        """InitializeCorners(IndexedTreePixel self)"""
        return _stomp.IndexedTreePixel_InitializeCorners(self)

    def AddPoint(self, *args):
        """
        AddPoint(IndexedTreePixel self, IndexedAngularCoordinate w_ang) -> bool
        AddPoint(IndexedTreePixel self, AngularCoordinate ang, uint32_t index) -> bool
        """
        return _stomp.IndexedTreePixel_AddPoint(self, *args)

    def NPoints(self, *args):
        """
        NPoints(IndexedTreePixel self) -> uint32_t
        NPoints(IndexedTreePixel self, Pixel pix) -> uint32_t
        """
        return _stomp.IndexedTreePixel_NPoints(self, *args)

    def Indices(self, *args):
        """Indices(IndexedTreePixel self, Pixel pix, IndexVector indices)"""
        return _stomp.IndexedTreePixel_Indices(self, *args)

    def Coverage(self, *args):
        """
        Coverage(IndexedTreePixel self) -> double
        Coverage(IndexedTreePixel self, Pixel pix) -> double
        """
        return _stomp.IndexedTreePixel_Coverage(self, *args)

    def Points(self, *args):
        """
        Points(IndexedTreePixel self, IAngularVector i_ang)
        Points(IndexedTreePixel self, IAngularVector i_ang, Pixel pix)
        """
        return _stomp.IndexedTreePixel_Points(self, *args)

    def Nodes(self):
        """Nodes(IndexedTreePixel self) -> uint16_t"""
        return _stomp.IndexedTreePixel_Nodes(self)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(IndexedTreePixel self, uint16_t maximum_points)"""
        return _stomp.IndexedTreePixel_SetPixelCapacity(self, *args)

    def PixelCapacity(self):
        """PixelCapacity(IndexedTreePixel self) -> uint16_t"""
        return _stomp.IndexedTreePixel_PixelCapacity(self)

    def HasPoints(self):
        """HasPoints(IndexedTreePixel self) -> bool"""
        return _stomp.IndexedTreePixel_HasPoints(self)

    def HasNodes(self):
        """HasNodes(IndexedTreePixel self) -> bool"""
        return _stomp.IndexedTreePixel_HasNodes(self)

    def Clear(self):
        """Clear(IndexedTreePixel self)"""
        return _stomp.IndexedTreePixel_Clear(self)

    def UnitSphereX(self):
        """UnitSphereX(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ(self)

    def UnitSphereX_UL(self):
        """UnitSphereX_UL(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_UL(self)

    def UnitSphereY_UL(self):
        """UnitSphereY_UL(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_UL(self)

    def UnitSphereZ_UL(self):
        """UnitSphereZ_UL(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_UL(self)

    def UnitSphereX_UR(self):
        """UnitSphereX_UR(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_UR(self)

    def UnitSphereY_UR(self):
        """UnitSphereY_UR(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_UR(self)

    def UnitSphereZ_UR(self):
        """UnitSphereZ_UR(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_UR(self)

    def UnitSphereX_LL(self):
        """UnitSphereX_LL(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_LL(self)

    def UnitSphereY_LL(self):
        """UnitSphereY_LL(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_LL(self)

    def UnitSphereZ_LL(self):
        """UnitSphereZ_LL(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_LL(self)

    def UnitSphereX_LR(self):
        """UnitSphereX_LR(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_LR(self)

    def UnitSphereY_LR(self):
        """UnitSphereY_LR(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_LR(self)

    def UnitSphereZ_LR(self):
        """UnitSphereZ_LR(IndexedTreePixel self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_LR(self)

    def WithinAnnulus(self, *args):
        """WithinAnnulus(IndexedTreePixel self, AngularBin theta, PixelVector pix, bool check_full_pixel)"""
        return _stomp.IndexedTreePixel_WithinAnnulus(self, *args)

IndexedTreePixel_swigregister = _stomp.IndexedTreePixel_swigregister
IndexedTreePixel_swigregister(IndexedTreePixel)

class NearestNeighborIndexedPixel(_object):
    """Proxy of C++ Stomp::NearestNeighborIndexedPixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborIndexedPixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborIndexedPixel, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(NearestNeighborIndexedPixel self, Stomp::DistanceIPixelPair const & x, Stomp::DistanceIPixelPair const & y) -> int"""
        return _stomp.NearestNeighborIndexedPixel___call__(self, *args)

    def __init__(self): 
        """__init__(Stomp::NearestNeighborIndexedPixel self) -> NearestNeighborIndexedPixel"""
        this = _stomp.new_NearestNeighborIndexedPixel()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborIndexedPixel
    __del__ = lambda self : None;
NearestNeighborIndexedPixel_swigregister = _stomp.NearestNeighborIndexedPixel_swigregister
NearestNeighborIndexedPixel_swigregister(NearestNeighborIndexedPixel)

class NearestNeighborIndexedPoint(_object):
    """Proxy of C++ Stomp::NearestNeighborIndexedPoint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborIndexedPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborIndexedPoint, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(NearestNeighborIndexedPoint self, Stomp::DistanceIPointPair const & x, Stomp::DistanceIPointPair const & y) -> int"""
        return _stomp.NearestNeighborIndexedPoint___call__(self, *args)

    def __init__(self): 
        """__init__(Stomp::NearestNeighborIndexedPoint self) -> NearestNeighborIndexedPoint"""
        this = _stomp.new_NearestNeighborIndexedPoint()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborIndexedPoint
    __del__ = lambda self : None;
NearestNeighborIndexedPoint_swigregister = _stomp.NearestNeighborIndexedPoint_swigregister
NearestNeighborIndexedPoint_swigregister(NearestNeighborIndexedPoint)

class IndexedTreeNeighbor(_object):
    """Proxy of C++ Stomp::IndexedTreeNeighbor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreeNeighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreeNeighbor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::IndexedTreeNeighbor self, AngularCoordinate reference_ang, uint8_t n_neighbors=1) -> IndexedTreeNeighbor
        __init__(Stomp::IndexedTreeNeighbor self, AngularCoordinate reference_ang) -> IndexedTreeNeighbor
        __init__(Stomp::IndexedTreeNeighbor self, AngularCoordinate reference_ang, uint8_t n_neighbors, double max_distance) -> IndexedTreeNeighbor
        """
        this = _stomp.new_IndexedTreeNeighbor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreeNeighbor
    __del__ = lambda self : None;
    def NearestNeighbors(self, *args):
        """
        NearestNeighbors(IndexedTreeNeighbor self, IAngularVector i_ang, bool save_neighbors=True)
        NearestNeighbors(IndexedTreeNeighbor self, IAngularVector i_ang)
        """
        return _stomp.IndexedTreeNeighbor_NearestNeighbors(self, *args)

    def Neighbors(self):
        """Neighbors(IndexedTreeNeighbor self) -> uint8_t"""
        return _stomp.IndexedTreeNeighbor_Neighbors(self)

    def MaxNeighbors(self):
        """MaxNeighbors(IndexedTreeNeighbor self) -> uint8_t"""
        return _stomp.IndexedTreeNeighbor_MaxNeighbors(self)

    def TestPoint(self, *args):
        """TestPoint(IndexedTreeNeighbor self, IndexedAngularCoordinate test_ang) -> bool"""
        return _stomp.IndexedTreeNeighbor_TestPoint(self, *args)

    def MaxDistance(self):
        """MaxDistance(IndexedTreeNeighbor self) -> double"""
        return _stomp.IndexedTreeNeighbor_MaxDistance(self)

    def MaxAngularDistance(self):
        """MaxAngularDistance(IndexedTreeNeighbor self) -> double"""
        return _stomp.IndexedTreeNeighbor_MaxAngularDistance(self)

    def NodesVisited(self):
        """NodesVisited(IndexedTreeNeighbor self) -> uint16_t"""
        return _stomp.IndexedTreeNeighbor_NodesVisited(self)

    def AddNode(self):
        """AddNode(IndexedTreeNeighbor self)"""
        return _stomp.IndexedTreeNeighbor_AddNode(self)

IndexedTreeNeighbor_swigregister = _stomp.IndexedTreeNeighbor_swigregister
IndexedTreeNeighbor_swigregister(IndexedTreeNeighbor)

class TreeMap(BaseMap):
    """Proxy of C++ Stomp::TreeMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TreeMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::TreeMap self, uint32_t resolution=HPixResolution, uint16_t maximum_points=50) -> TreeMap
        __init__(Stomp::TreeMap self, uint32_t resolution=HPixResolution) -> TreeMap
        __init__(Stomp::TreeMap self) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, int8_t weight_column=-1) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, uint8_t phi_column=1, 
            int8_t weight_column=-1) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, uint8_t phi_column=1) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution, 
            uint16_t maximum_points=50) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns, uint32_t resolution=HPixResolution) -> TreeMap
        __init__(Stomp::TreeMap self, std::string const & input_file, FieldColumnDict field_columns) -> TreeMap
        """
        this = _stomp.new_TreeMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreeMap
    __del__ = lambda self : None;
    def FindPairs(self, *args):
        """
        FindPairs(TreeMap self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        FindPairs(TreeMap self, AngularCoordinate ang, double theta_min, double theta_max) -> uint32_t
        FindPairs(TreeMap self, AngularCoordinate ang, double theta_max) -> uint32_t
        FindPairs(TreeMap self, AngularVector ang, AngularBin theta)
        FindPairs(TreeMap self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreeMap_FindPairs(self, *args)

    def FindWeightedPairs(self, *args):
        """
        FindWeightedPairs(TreeMap self, AngularCoordinate ang, AngularBin theta) -> double
        FindWeightedPairs(TreeMap self, AngularCoordinate ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(TreeMap self, AngularCoordinate ang, double theta_max) -> double
        FindWeightedPairs(TreeMap self, AngularVector ang, AngularBin theta)
        FindWeightedPairs(TreeMap self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, double theta_max) -> double
        FindWeightedPairs(TreeMap self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairs(TreeMap self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairs(TreeMap self, AngularCoordinate ang, AngularBin theta, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, AngularCoordinate ang, double theta_min, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, AngularCoordinate ang, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, AngularVector ang, AngularBin theta, std::string const & field_name)
        FindWeightedPairs(TreeMap self, AngularVector ang, AngularCorrelation wtheta, std::string const & field_name)
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, AngularBin theta, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, double theta_min, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, WAngularVector w_ang, AngularBin theta, std::string const & field_name)
        FindWeightedPairs(TreeMap self, WAngularVector w_ang, AngularCorrelation wtheta, std::string const & field_name)
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, AngularBin theta, 
            std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, double theta_min, 
            double theta_max, std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, WeightedAngularCoordinate w_ang, std::string const & ang_field_name, double theta_max, 
            std::string const & field_name) -> double
        FindWeightedPairs(TreeMap self, WAngularVector w_ang, std::string const & ang_field_name, AngularBin theta, std::string const & field_name)
        FindWeightedPairs(TreeMap self, WAngularVector w_ang, std::string const & ang_field_name, AngularCorrelation wtheta, 
            std::string const & field_name)
        """
        return _stomp.TreeMap_FindWeightedPairs(self, *args)

    def FindPairsWithRegions(self, *args):
        """
        FindPairsWithRegions(TreeMap self, AngularVector ang, AngularBin theta)
        FindPairsWithRegions(TreeMap self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreeMap_FindPairsWithRegions(self, *args)

    def FindWeightedPairsWithRegions(self, *args):
        """
        FindWeightedPairsWithRegions(TreeMap self, AngularVector ang, AngularBin theta)
        FindWeightedPairsWithRegions(TreeMap self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairsWithRegions(TreeMap self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairsWithRegions(TreeMap self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairsWithRegions(TreeMap self, AngularVector ang, AngularBin theta, std::string const & field_name)
        FindWeightedPairsWithRegions(TreeMap self, AngularVector ang, AngularCorrelation wtheta, std::string const & field_name)
        FindWeightedPairsWithRegions(TreeMap self, WAngularVector w_ang, AngularBin theta, std::string const & field_name)
        FindWeightedPairsWithRegions(TreeMap self, WAngularVector w_ang, AngularCorrelation wtheta, std::string const & field_name)
        FindWeightedPairsWithRegions(TreeMap self, WAngularVector w_ang, std::string const & ang_field_name, AngularBin theta, std::string const & field_name)
        FindWeightedPairsWithRegions(TreeMap self, WAngularVector w_ang, std::string const & ang_field_name, AngularCorrelation wtheta, 
            std::string const & field_name)
        """
        return _stomp.TreeMap_FindWeightedPairsWithRegions(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(TreeMap self, AngularCoordinate ang, uint8_t n_neighbors, WAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.TreeMap_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(TreeMap self, AngularCoordinate ang, WeightedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.TreeMap_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(TreeMap self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t & nodes_visited) -> double"""
        return _stomp.TreeMap_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(TreeMap self, AngularCoordinate ang, uint16_t & nodes_visited) -> double"""
        return _stomp.TreeMap_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(TreeMap self, AngularCoordinate ang, double max_distance, WeightedAngularCoordinate match_ang) -> bool"""
        return _stomp.TreeMap_ClosestMatch(self, *args)

    def AddPoint(self, *args):
        """
        AddPoint(TreeMap self, WeightedAngularCoordinate w_ang) -> bool
        AddPoint(TreeMap self, AngularCoordinate ang, double object_weight=1.0) -> bool
        AddPoint(TreeMap self, AngularCoordinate ang) -> bool
        """
        return _stomp.TreeMap_AddPoint(self, *args)

    def Read(self, *args):
        """
        Read(TreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, uint8_t phi_column=1, int8_t weight_column=-1) -> bool
        Read(TreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        Read(TreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0) -> bool
        Read(TreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False) -> bool
        Read(TreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        Read(TreeMap self, std::string const & input_file) -> bool
        Read(TreeMap self, std::string const & input_file, FieldColumnDict field_columns, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, 
            uint8_t phi_column=1, int8_t weight_column=-1) -> bool
        Read(TreeMap self, std::string const & input_file, FieldColumnDict field_columns, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, 
            uint8_t phi_column=1) -> bool
        Read(TreeMap self, std::string const & input_file, FieldColumnDict field_columns, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0) -> bool
        Read(TreeMap self, std::string const & input_file, FieldColumnDict field_columns, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False) -> bool
        Read(TreeMap self, std::string const & input_file, FieldColumnDict field_columns, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        Read(TreeMap self, std::string const & input_file, FieldColumnDict field_columns) -> bool
        """
        return _stomp.TreeMap_Read(self, *args)

    def Coverage(self, *args):
        """
        Coverage(TreeMap self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(TreeMap self, PixelVector superpix)
        """
        return _stomp.TreeMap_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(TreeMap self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.TreeMap_Covering(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(TreeMap self, Pixel pix) -> double"""
        return _stomp.TreeMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(TreeMap self, Pixel pix) -> int8_t"""
        return _stomp.TreeMap_FindUnmaskedStatus(self, *args)

    def NodeMap(self, *args):
        """NodeMap(TreeMap self, Map stomp_map)"""
        return _stomp.TreeMap_NodeMap(self, *args)

    def Resolution(self):
        """Resolution(TreeMap self) -> uint32_t"""
        return _stomp.TreeMap_Resolution(self)

    def PixelCapacity(self):
        """PixelCapacity(TreeMap self) -> uint16_t"""
        return _stomp.TreeMap_PixelCapacity(self)

    def SetResolution(self, *args):
        """SetResolution(TreeMap self, uint32_t resolution)"""
        return _stomp.TreeMap_SetResolution(self, *args)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(TreeMap self, int pixel_capacity)"""
        return _stomp.TreeMap_SetPixelCapacity(self, *args)

    def NPoints(self, *args):
        """
        NPoints(TreeMap self, uint32_t k=MaxPixnum) -> uint32_t
        NPoints(TreeMap self) -> uint32_t
        NPoints(TreeMap self, Pixel pix) -> uint32_t
        """
        return _stomp.TreeMap_NPoints(self, *args)

    def Points(self, *args):
        """
        Points(TreeMap self, WAngularVector w_ang)
        Points(TreeMap self, WAngularVector w_ang, Pixel pix)
        """
        return _stomp.TreeMap_Points(self, *args)

    def Weight(self, *args):
        """
        Weight(TreeMap self, uint32_t k=MaxPixnum) -> double
        Weight(TreeMap self) -> double
        Weight(TreeMap self, Pixel pix) -> double
        """
        return _stomp.TreeMap_Weight(self, *args)

    def FieldTotal(self, *args):
        """
        FieldTotal(TreeMap self, std::string const & field_name, uint32_t k=MaxPixnum) -> double
        FieldTotal(TreeMap self, std::string const & field_name) -> double
        FieldTotal(TreeMap self, std::string const & field_name, Pixel pix) -> double
        """
        return _stomp.TreeMap_FieldTotal(self, *args)

    def NField(self):
        """NField(TreeMap self) -> uint16_t"""
        return _stomp.TreeMap_NField(self)

    def HasFields(self):
        """HasFields(TreeMap self) -> bool"""
        return _stomp.TreeMap_HasFields(self)

    def FieldNames(self, *args):
        """FieldNames(TreeMap self, std::vector< std::string,std::allocator< std::string > > & field_names)"""
        return _stomp.TreeMap_FieldNames(self, *args)

    def BaseNodes(self):
        """BaseNodes(TreeMap self) -> uint16_t"""
        return _stomp.TreeMap_BaseNodes(self)

    def Nodes(self):
        """Nodes(TreeMap self) -> uint16_t"""
        return _stomp.TreeMap_Nodes(self)

    def Size(self):
        """Size(TreeMap self) -> uint32_t"""
        return _stomp.TreeMap_Size(self)

    def Area(self):
        """Area(TreeMap self) -> double"""
        return _stomp.TreeMap_Area(self)

    def CalculateArea(self):
        """CalculateArea(TreeMap self)"""
        return _stomp.TreeMap_CalculateArea(self)

    def MinResolution(self):
        """MinResolution(TreeMap self) -> uint32_t"""
        return _stomp.TreeMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(TreeMap self) -> uint32_t"""
        return _stomp.TreeMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(TreeMap self) -> uint8_t"""
        return _stomp.TreeMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(TreeMap self) -> uint8_t"""
        return _stomp.TreeMap_MaxLevel(self)

    def Empty(self):
        """Empty(TreeMap self) -> bool"""
        return _stomp.TreeMap_Empty(self)

    def Clear(self):
        """Clear(TreeMap self)"""
        return _stomp.TreeMap_Clear(self)

TreeMap_swigregister = _stomp.TreeMap_swigregister
TreeMap_swigregister(TreeMap)

class IndexedTreeMap(BaseMap):
    """Proxy of C++ Stomp::IndexedTreeMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreeMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreeMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Stomp::IndexedTreeMap self, uint32_t resolution=HPixResolution, uint16_t maximum_points=50) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, uint32_t resolution=HPixResolution) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1, int8_t index_column=-1) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0, uint8_t phi_column=1) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False, 
            uint8_t theta_column=0) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial, bool verbose=False) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50, 
            Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution, uint16_t maximum_points=50) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file, uint32_t resolution=HPixResolution) -> IndexedTreeMap
        __init__(Stomp::IndexedTreeMap self, std::string const & input_file) -> IndexedTreeMap
        """
        this = _stomp.new_IndexedTreeMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreeMap
    __del__ = lambda self : None;
    def FindPairs(self, *args):
        """
        FindPairs(IndexedTreeMap self, AngularCoordinate ang, AngularBin theta, IAngularVector i_angVec)
        FindPairs(IndexedTreeMap self, AngularCoordinate ang, AngularBin theta, IndexVector pair_indices)
        FindPairs(IndexedTreeMap self, AngularCoordinate ang, double theta_min, double theta_max, IAngularVector i_angVec)
        FindPairs(IndexedTreeMap self, AngularCoordinate ang, double theta_min, double theta_max, IndexVector pair_indices)
        FindPairs(IndexedTreeMap self, AngularCoordinate ang, double theta_max, IAngularVector pair_indices)
        FindPairs(IndexedTreeMap self, AngularCoordinate ang, double theta_max, IndexVector pair_indices)
        """
        return _stomp.IndexedTreeMap_FindPairs(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(IndexedTreeMap self, AngularCoordinate ang, uint8_t n_neighbors, IAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.IndexedTreeMap_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(IndexedTreeMap self, AngularCoordinate ang, IndexedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.IndexedTreeMap_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(IndexedTreeMap self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t & nodes_visited) -> double"""
        return _stomp.IndexedTreeMap_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(IndexedTreeMap self, AngularCoordinate ang, uint16_t & nodes_visited) -> double"""
        return _stomp.IndexedTreeMap_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(IndexedTreeMap self, AngularCoordinate ang, double max_distance, IndexedAngularCoordinate match_ang) -> bool"""
        return _stomp.IndexedTreeMap_ClosestMatch(self, *args)

    def AddPoint(self, *args):
        """
        AddPoint(IndexedTreeMap self, IndexedAngularCoordinate i_ang) -> bool
        AddPoint(IndexedTreeMap self, AngularCoordinate ang, uint32_t index) -> bool
        """
        return _stomp.IndexedTreeMap_AddPoint(self, *args)

    def Read(self, *args):
        """
        Read(IndexedTreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, uint8_t phi_column=1, int8_t index_column=-1) -> bool
        Read(IndexedTreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0, uint8_t phi_column=1) -> bool
        Read(IndexedTreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False, uint8_t theta_column=0) -> bool
        Read(IndexedTreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial, 
            bool verbose=False) -> bool
        Read(IndexedTreeMap self, std::string const & input_file, Stomp::AngularCoordinate::Sphere sphere=Equatorial) -> bool
        Read(IndexedTreeMap self, std::string const & input_file) -> bool
        """
        return _stomp.IndexedTreeMap_Read(self, *args)

    def Coverage(self, *args):
        """
        Coverage(IndexedTreeMap self, PixelVector superpix, uint32_t resolution=HPixResolution, bool calculate_fraction=True)
        Coverage(IndexedTreeMap self, PixelVector superpix, uint32_t resolution=HPixResolution)
        Coverage(IndexedTreeMap self, PixelVector superpix)
        """
        return _stomp.IndexedTreeMap_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(IndexedTreeMap self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.IndexedTreeMap_Covering(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(IndexedTreeMap self, Pixel pix) -> double"""
        return _stomp.IndexedTreeMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(IndexedTreeMap self, Pixel pix) -> int8_t"""
        return _stomp.IndexedTreeMap_FindUnmaskedStatus(self, *args)

    def NodeMap(self, *args):
        """NodeMap(IndexedTreeMap self, Map stomp_map)"""
        return _stomp.IndexedTreeMap_NodeMap(self, *args)

    def Resolution(self):
        """Resolution(IndexedTreeMap self) -> uint32_t"""
        return _stomp.IndexedTreeMap_Resolution(self)

    def PixelCapacity(self):
        """PixelCapacity(IndexedTreeMap self) -> uint16_t"""
        return _stomp.IndexedTreeMap_PixelCapacity(self)

    def SetResolution(self, *args):
        """SetResolution(IndexedTreeMap self, uint32_t resolution)"""
        return _stomp.IndexedTreeMap_SetResolution(self, *args)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(IndexedTreeMap self, int pixel_capacity)"""
        return _stomp.IndexedTreeMap_SetPixelCapacity(self, *args)

    def NPoints(self, *args):
        """
        NPoints(IndexedTreeMap self, uint32_t k=MaxPixnum) -> uint32_t
        NPoints(IndexedTreeMap self) -> uint32_t
        NPoints(IndexedTreeMap self, Pixel pix) -> uint32_t
        """
        return _stomp.IndexedTreeMap_NPoints(self, *args)

    def Points(self, *args):
        """
        Points(IndexedTreeMap self, IAngularVector i_ang)
        Points(IndexedTreeMap self, IAngularVector i_ang, Pixel pix)
        """
        return _stomp.IndexedTreeMap_Points(self, *args)

    def Indices(self, *args):
        """Indices(IndexedTreeMap self, Pixel pix, IndexVector indices)"""
        return _stomp.IndexedTreeMap_Indices(self, *args)

    def BaseNodes(self):
        """BaseNodes(IndexedTreeMap self) -> uint16_t"""
        return _stomp.IndexedTreeMap_BaseNodes(self)

    def Nodes(self):
        """Nodes(IndexedTreeMap self) -> uint16_t"""
        return _stomp.IndexedTreeMap_Nodes(self)

    def Size(self):
        """Size(IndexedTreeMap self) -> uint32_t"""
        return _stomp.IndexedTreeMap_Size(self)

    def Area(self):
        """Area(IndexedTreeMap self) -> double"""
        return _stomp.IndexedTreeMap_Area(self)

    def CalculateArea(self):
        """CalculateArea(IndexedTreeMap self)"""
        return _stomp.IndexedTreeMap_CalculateArea(self)

    def MinResolution(self):
        """MinResolution(IndexedTreeMap self) -> uint32_t"""
        return _stomp.IndexedTreeMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(IndexedTreeMap self) -> uint32_t"""
        return _stomp.IndexedTreeMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(IndexedTreeMap self) -> uint8_t"""
        return _stomp.IndexedTreeMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(IndexedTreeMap self) -> uint8_t"""
        return _stomp.IndexedTreeMap_MaxLevel(self)

    def Empty(self):
        """Empty(IndexedTreeMap self) -> bool"""
        return _stomp.IndexedTreeMap_Empty(self)

    def Clear(self):
        """Clear(IndexedTreeMap self)"""
        return _stomp.IndexedTreeMap_Clear(self)

IndexedTreeMap_swigregister = _stomp.IndexedTreeMap_swigregister
IndexedTreeMap_swigregister(IndexedTreeMap)

class AngularVector(_object):
    """Proxy of C++ std::vector<(Stomp::AngularCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(AngularVector self) -> SwigPyIterator"""
        return _stomp.AngularVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(AngularVector self) -> bool"""
        return _stomp.AngularVector___nonzero__(self)

    def __bool__(self):
        """__bool__(AngularVector self) -> bool"""
        return _stomp.AngularVector___bool__(self)

    def __len__(self):
        """__len__(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::size_type"""
        return _stomp.AngularVector___len__(self)

    def pop(self):
        """pop(AngularVector self) -> AngularCoordinate"""
        return _stomp.AngularVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i, std::vector< Stomp::AngularCoordinate >::difference_type j) -> AngularVector"""
        return _stomp.AngularVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i, std::vector< Stomp::AngularCoordinate >::difference_type j, 
            AngularVector v=std::vector< Stomp::AngularCoordinate,std::allocator< Stomp::AngularCoordinate > >())
        __setslice__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i, std::vector< Stomp::AngularCoordinate >::difference_type j)
        """
        return _stomp.AngularVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i, std::vector< Stomp::AngularCoordinate >::difference_type j)"""
        return _stomp.AngularVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i)
        __delitem__(AngularVector self, PySliceObject * slice)
        """
        return _stomp.AngularVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(AngularVector self, PySliceObject * slice) -> AngularVector
        __getitem__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i) -> AngularCoordinate
        """
        return _stomp.AngularVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(AngularVector self, PySliceObject * slice, AngularVector v)
        __setitem__(AngularVector self, PySliceObject * slice)
        __setitem__(AngularVector self, std::vector< Stomp::AngularCoordinate >::difference_type i, AngularCoordinate x)
        """
        return _stomp.AngularVector___setitem__(self, *args)

    def append(self, *args):
        """append(AngularVector self, AngularCoordinate x)"""
        return _stomp.AngularVector_append(self, *args)

    def empty(self):
        """empty(AngularVector self) -> bool"""
        return _stomp.AngularVector_empty(self)

    def size(self):
        """size(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::size_type"""
        return _stomp.AngularVector_size(self)

    def clear(self):
        """clear(AngularVector self)"""
        return _stomp.AngularVector_clear(self)

    def swap(self, *args):
        """swap(AngularVector self, AngularVector v)"""
        return _stomp.AngularVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::allocator_type"""
        return _stomp.AngularVector_get_allocator(self)

    def begin(self):
        """begin(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::iterator"""
        return _stomp.AngularVector_begin(self)

    def end(self):
        """end(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::iterator"""
        return _stomp.AngularVector_end(self)

    def rbegin(self):
        """rbegin(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::reverse_iterator"""
        return _stomp.AngularVector_rbegin(self)

    def rend(self):
        """rend(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::reverse_iterator"""
        return _stomp.AngularVector_rend(self)

    def pop_back(self):
        """pop_back(AngularVector self)"""
        return _stomp.AngularVector_pop_back(self)

    def erase(self, *args):
        """
        erase(AngularVector self, std::vector< Stomp::AngularCoordinate >::iterator pos) -> std::vector< Stomp::AngularCoordinate >::iterator
        erase(AngularVector self, std::vector< Stomp::AngularCoordinate >::iterator first, std::vector< Stomp::AngularCoordinate >::iterator last) -> std::vector< Stomp::AngularCoordinate >::iterator
        """
        return _stomp.AngularVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::AngularCoordinate)> self) -> AngularVector
        __init__(std::vector<(Stomp::AngularCoordinate)> self, AngularVector arg2) -> AngularVector
        __init__(std::vector<(Stomp::AngularCoordinate)> self, std::vector< Stomp::AngularCoordinate >::size_type size) -> AngularVector
        __init__(std::vector<(Stomp::AngularCoordinate)> self, std::vector< Stomp::AngularCoordinate >::size_type size, AngularCoordinate value) -> AngularVector
        """
        this = _stomp.new_AngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(AngularVector self, AngularCoordinate x)"""
        return _stomp.AngularVector_push_back(self, *args)

    def front(self):
        """front(AngularVector self) -> AngularCoordinate"""
        return _stomp.AngularVector_front(self)

    def back(self):
        """back(AngularVector self) -> AngularCoordinate"""
        return _stomp.AngularVector_back(self)

    def assign(self, *args):
        """assign(AngularVector self, std::vector< Stomp::AngularCoordinate >::size_type n, AngularCoordinate x)"""
        return _stomp.AngularVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(AngularVector self, std::vector< Stomp::AngularCoordinate >::size_type new_size)
        resize(AngularVector self, std::vector< Stomp::AngularCoordinate >::size_type new_size, AngularCoordinate x)
        """
        return _stomp.AngularVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(AngularVector self, std::vector< Stomp::AngularCoordinate >::iterator pos, AngularCoordinate x) -> std::vector< Stomp::AngularCoordinate >::iterator
        insert(AngularVector self, std::vector< Stomp::AngularCoordinate >::iterator pos, std::vector< Stomp::AngularCoordinate >::size_type n, 
            AngularCoordinate x)
        """
        return _stomp.AngularVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(AngularVector self, std::vector< Stomp::AngularCoordinate >::size_type n)"""
        return _stomp.AngularVector_reserve(self, *args)

    def capacity(self):
        """capacity(AngularVector self) -> std::vector< Stomp::AngularCoordinate >::size_type"""
        return _stomp.AngularVector_capacity(self)

    __swig_destroy__ = _stomp.delete_AngularVector
    __del__ = lambda self : None;
AngularVector_swigregister = _stomp.AngularVector_swigregister
AngularVector_swigregister(AngularVector)

class ThetaVector(_object):
    """Proxy of C++ std::vector<(Stomp::AngularBin)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThetaVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThetaVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(ThetaVector self) -> SwigPyIterator"""
        return _stomp.ThetaVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(ThetaVector self) -> bool"""
        return _stomp.ThetaVector___nonzero__(self)

    def __bool__(self):
        """__bool__(ThetaVector self) -> bool"""
        return _stomp.ThetaVector___bool__(self)

    def __len__(self):
        """__len__(ThetaVector self) -> std::vector< Stomp::AngularBin >::size_type"""
        return _stomp.ThetaVector___len__(self)

    def pop(self):
        """pop(ThetaVector self) -> AngularBin"""
        return _stomp.ThetaVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i, std::vector< Stomp::AngularBin >::difference_type j) -> ThetaVector"""
        return _stomp.ThetaVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i, std::vector< Stomp::AngularBin >::difference_type j, 
            ThetaVector v=std::vector< Stomp::AngularBin,std::allocator< Stomp::AngularBin > >())
        __setslice__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i, std::vector< Stomp::AngularBin >::difference_type j)
        """
        return _stomp.ThetaVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i, std::vector< Stomp::AngularBin >::difference_type j)"""
        return _stomp.ThetaVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i)
        __delitem__(ThetaVector self, PySliceObject * slice)
        """
        return _stomp.ThetaVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(ThetaVector self, PySliceObject * slice) -> ThetaVector
        __getitem__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i) -> AngularBin
        """
        return _stomp.ThetaVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(ThetaVector self, PySliceObject * slice, ThetaVector v)
        __setitem__(ThetaVector self, PySliceObject * slice)
        __setitem__(ThetaVector self, std::vector< Stomp::AngularBin >::difference_type i, AngularBin x)
        """
        return _stomp.ThetaVector___setitem__(self, *args)

    def append(self, *args):
        """append(ThetaVector self, AngularBin x)"""
        return _stomp.ThetaVector_append(self, *args)

    def empty(self):
        """empty(ThetaVector self) -> bool"""
        return _stomp.ThetaVector_empty(self)

    def size(self):
        """size(ThetaVector self) -> std::vector< Stomp::AngularBin >::size_type"""
        return _stomp.ThetaVector_size(self)

    def clear(self):
        """clear(ThetaVector self)"""
        return _stomp.ThetaVector_clear(self)

    def swap(self, *args):
        """swap(ThetaVector self, ThetaVector v)"""
        return _stomp.ThetaVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(ThetaVector self) -> std::vector< Stomp::AngularBin >::allocator_type"""
        return _stomp.ThetaVector_get_allocator(self)

    def begin(self):
        """begin(ThetaVector self) -> std::vector< Stomp::AngularBin >::iterator"""
        return _stomp.ThetaVector_begin(self)

    def end(self):
        """end(ThetaVector self) -> std::vector< Stomp::AngularBin >::iterator"""
        return _stomp.ThetaVector_end(self)

    def rbegin(self):
        """rbegin(ThetaVector self) -> std::vector< Stomp::AngularBin >::reverse_iterator"""
        return _stomp.ThetaVector_rbegin(self)

    def rend(self):
        """rend(ThetaVector self) -> std::vector< Stomp::AngularBin >::reverse_iterator"""
        return _stomp.ThetaVector_rend(self)

    def pop_back(self):
        """pop_back(ThetaVector self)"""
        return _stomp.ThetaVector_pop_back(self)

    def erase(self, *args):
        """
        erase(ThetaVector self, std::vector< Stomp::AngularBin >::iterator pos) -> std::vector< Stomp::AngularBin >::iterator
        erase(ThetaVector self, std::vector< Stomp::AngularBin >::iterator first, std::vector< Stomp::AngularBin >::iterator last) -> std::vector< Stomp::AngularBin >::iterator
        """
        return _stomp.ThetaVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::AngularBin)> self) -> ThetaVector
        __init__(std::vector<(Stomp::AngularBin)> self, ThetaVector arg2) -> ThetaVector
        __init__(std::vector<(Stomp::AngularBin)> self, std::vector< Stomp::AngularBin >::size_type size) -> ThetaVector
        __init__(std::vector<(Stomp::AngularBin)> self, std::vector< Stomp::AngularBin >::size_type size, AngularBin value) -> ThetaVector
        """
        this = _stomp.new_ThetaVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(ThetaVector self, AngularBin x)"""
        return _stomp.ThetaVector_push_back(self, *args)

    def front(self):
        """front(ThetaVector self) -> AngularBin"""
        return _stomp.ThetaVector_front(self)

    def back(self):
        """back(ThetaVector self) -> AngularBin"""
        return _stomp.ThetaVector_back(self)

    def assign(self, *args):
        """assign(ThetaVector self, std::vector< Stomp::AngularBin >::size_type n, AngularBin x)"""
        return _stomp.ThetaVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(ThetaVector self, std::vector< Stomp::AngularBin >::size_type new_size)
        resize(ThetaVector self, std::vector< Stomp::AngularBin >::size_type new_size, AngularBin x)
        """
        return _stomp.ThetaVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(ThetaVector self, std::vector< Stomp::AngularBin >::iterator pos, AngularBin x) -> std::vector< Stomp::AngularBin >::iterator
        insert(ThetaVector self, std::vector< Stomp::AngularBin >::iterator pos, std::vector< Stomp::AngularBin >::size_type n, 
            AngularBin x)
        """
        return _stomp.ThetaVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(ThetaVector self, std::vector< Stomp::AngularBin >::size_type n)"""
        return _stomp.ThetaVector_reserve(self, *args)

    def capacity(self):
        """capacity(ThetaVector self) -> std::vector< Stomp::AngularBin >::size_type"""
        return _stomp.ThetaVector_capacity(self)

    __swig_destroy__ = _stomp.delete_ThetaVector
    __del__ = lambda self : None;
ThetaVector_swigregister = _stomp.ThetaVector_swigregister
ThetaVector_swigregister(ThetaVector)

class RadialVector(_object):
    """Proxy of C++ std::vector<(Stomp::RadialBin)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadialVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(RadialVector self) -> SwigPyIterator"""
        return _stomp.RadialVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(RadialVector self) -> bool"""
        return _stomp.RadialVector___nonzero__(self)

    def __bool__(self):
        """__bool__(RadialVector self) -> bool"""
        return _stomp.RadialVector___bool__(self)

    def __len__(self):
        """__len__(RadialVector self) -> std::vector< Stomp::RadialBin >::size_type"""
        return _stomp.RadialVector___len__(self)

    def pop(self):
        """pop(RadialVector self) -> RadialBin"""
        return _stomp.RadialVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i, std::vector< Stomp::RadialBin >::difference_type j) -> RadialVector"""
        return _stomp.RadialVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i, std::vector< Stomp::RadialBin >::difference_type j, 
            RadialVector v=std::vector< Stomp::RadialBin,std::allocator< Stomp::RadialBin > >())
        __setslice__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i, std::vector< Stomp::RadialBin >::difference_type j)
        """
        return _stomp.RadialVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i, std::vector< Stomp::RadialBin >::difference_type j)"""
        return _stomp.RadialVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i)
        __delitem__(RadialVector self, PySliceObject * slice)
        """
        return _stomp.RadialVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(RadialVector self, PySliceObject * slice) -> RadialVector
        __getitem__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i) -> RadialBin
        """
        return _stomp.RadialVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(RadialVector self, PySliceObject * slice, RadialVector v)
        __setitem__(RadialVector self, PySliceObject * slice)
        __setitem__(RadialVector self, std::vector< Stomp::RadialBin >::difference_type i, RadialBin x)
        """
        return _stomp.RadialVector___setitem__(self, *args)

    def append(self, *args):
        """append(RadialVector self, RadialBin x)"""
        return _stomp.RadialVector_append(self, *args)

    def empty(self):
        """empty(RadialVector self) -> bool"""
        return _stomp.RadialVector_empty(self)

    def size(self):
        """size(RadialVector self) -> std::vector< Stomp::RadialBin >::size_type"""
        return _stomp.RadialVector_size(self)

    def clear(self):
        """clear(RadialVector self)"""
        return _stomp.RadialVector_clear(self)

    def swap(self, *args):
        """swap(RadialVector self, RadialVector v)"""
        return _stomp.RadialVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(RadialVector self) -> std::vector< Stomp::RadialBin >::allocator_type"""
        return _stomp.RadialVector_get_allocator(self)

    def begin(self):
        """begin(RadialVector self) -> std::vector< Stomp::RadialBin >::iterator"""
        return _stomp.RadialVector_begin(self)

    def end(self):
        """end(RadialVector self) -> std::vector< Stomp::RadialBin >::iterator"""
        return _stomp.RadialVector_end(self)

    def rbegin(self):
        """rbegin(RadialVector self) -> std::vector< Stomp::RadialBin >::reverse_iterator"""
        return _stomp.RadialVector_rbegin(self)

    def rend(self):
        """rend(RadialVector self) -> std::vector< Stomp::RadialBin >::reverse_iterator"""
        return _stomp.RadialVector_rend(self)

    def pop_back(self):
        """pop_back(RadialVector self)"""
        return _stomp.RadialVector_pop_back(self)

    def erase(self, *args):
        """
        erase(RadialVector self, std::vector< Stomp::RadialBin >::iterator pos) -> std::vector< Stomp::RadialBin >::iterator
        erase(RadialVector self, std::vector< Stomp::RadialBin >::iterator first, std::vector< Stomp::RadialBin >::iterator last) -> std::vector< Stomp::RadialBin >::iterator
        """
        return _stomp.RadialVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::RadialBin)> self) -> RadialVector
        __init__(std::vector<(Stomp::RadialBin)> self, RadialVector arg2) -> RadialVector
        __init__(std::vector<(Stomp::RadialBin)> self, std::vector< Stomp::RadialBin >::size_type size) -> RadialVector
        __init__(std::vector<(Stomp::RadialBin)> self, std::vector< Stomp::RadialBin >::size_type size, RadialBin value) -> RadialVector
        """
        this = _stomp.new_RadialVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(RadialVector self, RadialBin x)"""
        return _stomp.RadialVector_push_back(self, *args)

    def front(self):
        """front(RadialVector self) -> RadialBin"""
        return _stomp.RadialVector_front(self)

    def back(self):
        """back(RadialVector self) -> RadialBin"""
        return _stomp.RadialVector_back(self)

    def assign(self, *args):
        """assign(RadialVector self, std::vector< Stomp::RadialBin >::size_type n, RadialBin x)"""
        return _stomp.RadialVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(RadialVector self, std::vector< Stomp::RadialBin >::size_type new_size)
        resize(RadialVector self, std::vector< Stomp::RadialBin >::size_type new_size, RadialBin x)
        """
        return _stomp.RadialVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(RadialVector self, std::vector< Stomp::RadialBin >::iterator pos, RadialBin x) -> std::vector< Stomp::RadialBin >::iterator
        insert(RadialVector self, std::vector< Stomp::RadialBin >::iterator pos, std::vector< Stomp::RadialBin >::size_type n, 
            RadialBin x)
        """
        return _stomp.RadialVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(RadialVector self, std::vector< Stomp::RadialBin >::size_type n)"""
        return _stomp.RadialVector_reserve(self, *args)

    def capacity(self):
        """capacity(RadialVector self) -> std::vector< Stomp::RadialBin >::size_type"""
        return _stomp.RadialVector_capacity(self)

    __swig_destroy__ = _stomp.delete_RadialVector
    __del__ = lambda self : None;
RadialVector_swigregister = _stomp.RadialVector_swigregister
RadialVector_swigregister(RadialVector)

class WAngularVector(_object):
    """Proxy of C++ std::vector<(Stomp::WeightedAngularCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WAngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WAngularVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(WAngularVector self) -> SwigPyIterator"""
        return _stomp.WAngularVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(WAngularVector self) -> bool"""
        return _stomp.WAngularVector___nonzero__(self)

    def __bool__(self):
        """__bool__(WAngularVector self) -> bool"""
        return _stomp.WAngularVector___bool__(self)

    def __len__(self):
        """__len__(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::size_type"""
        return _stomp.WAngularVector___len__(self)

    def pop(self):
        """pop(WAngularVector self) -> WeightedAngularCoordinate"""
        return _stomp.WAngularVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i, std::vector< Stomp::WeightedAngularCoordinate >::difference_type j) -> WAngularVector"""
        return _stomp.WAngularVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i, std::vector< Stomp::WeightedAngularCoordinate >::difference_type j, 
            WAngularVector v=std::vector< Stomp::WeightedAngularCoordinate,std::allocator< Stomp::WeightedAngularCoordinate > >())
        __setslice__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i, std::vector< Stomp::WeightedAngularCoordinate >::difference_type j)
        """
        return _stomp.WAngularVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i, std::vector< Stomp::WeightedAngularCoordinate >::difference_type j)"""
        return _stomp.WAngularVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i)
        __delitem__(WAngularVector self, PySliceObject * slice)
        """
        return _stomp.WAngularVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(WAngularVector self, PySliceObject * slice) -> WAngularVector
        __getitem__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i) -> WeightedAngularCoordinate
        """
        return _stomp.WAngularVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(WAngularVector self, PySliceObject * slice, WAngularVector v)
        __setitem__(WAngularVector self, PySliceObject * slice)
        __setitem__(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::difference_type i, WeightedAngularCoordinate x)
        """
        return _stomp.WAngularVector___setitem__(self, *args)

    def append(self, *args):
        """append(WAngularVector self, WeightedAngularCoordinate x)"""
        return _stomp.WAngularVector_append(self, *args)

    def empty(self):
        """empty(WAngularVector self) -> bool"""
        return _stomp.WAngularVector_empty(self)

    def size(self):
        """size(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::size_type"""
        return _stomp.WAngularVector_size(self)

    def clear(self):
        """clear(WAngularVector self)"""
        return _stomp.WAngularVector_clear(self)

    def swap(self, *args):
        """swap(WAngularVector self, WAngularVector v)"""
        return _stomp.WAngularVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::allocator_type"""
        return _stomp.WAngularVector_get_allocator(self)

    def begin(self):
        """begin(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::iterator"""
        return _stomp.WAngularVector_begin(self)

    def end(self):
        """end(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::iterator"""
        return _stomp.WAngularVector_end(self)

    def rbegin(self):
        """rbegin(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::reverse_iterator"""
        return _stomp.WAngularVector_rbegin(self)

    def rend(self):
        """rend(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::reverse_iterator"""
        return _stomp.WAngularVector_rend(self)

    def pop_back(self):
        """pop_back(WAngularVector self)"""
        return _stomp.WAngularVector_pop_back(self)

    def erase(self, *args):
        """
        erase(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::iterator pos) -> std::vector< Stomp::WeightedAngularCoordinate >::iterator
        erase(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::iterator first, std::vector< Stomp::WeightedAngularCoordinate >::iterator last) -> std::vector< Stomp::WeightedAngularCoordinate >::iterator
        """
        return _stomp.WAngularVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::WeightedAngularCoordinate)> self) -> WAngularVector
        __init__(std::vector<(Stomp::WeightedAngularCoordinate)> self, WAngularVector arg2) -> WAngularVector
        __init__(std::vector<(Stomp::WeightedAngularCoordinate)> self, std::vector< Stomp::WeightedAngularCoordinate >::size_type size) -> WAngularVector
        __init__(std::vector<(Stomp::WeightedAngularCoordinate)> self, std::vector< Stomp::WeightedAngularCoordinate >::size_type size, WeightedAngularCoordinate value) -> WAngularVector
        """
        this = _stomp.new_WAngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(WAngularVector self, WeightedAngularCoordinate x)"""
        return _stomp.WAngularVector_push_back(self, *args)

    def front(self):
        """front(WAngularVector self) -> WeightedAngularCoordinate"""
        return _stomp.WAngularVector_front(self)

    def back(self):
        """back(WAngularVector self) -> WeightedAngularCoordinate"""
        return _stomp.WAngularVector_back(self)

    def assign(self, *args):
        """assign(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::size_type n, WeightedAngularCoordinate x)"""
        return _stomp.WAngularVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::size_type new_size)
        resize(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::size_type new_size, WeightedAngularCoordinate x)
        """
        return _stomp.WAngularVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::iterator pos, WeightedAngularCoordinate x) -> std::vector< Stomp::WeightedAngularCoordinate >::iterator
        insert(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::iterator pos, std::vector< Stomp::WeightedAngularCoordinate >::size_type n, 
            WeightedAngularCoordinate x)
        """
        return _stomp.WAngularVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(WAngularVector self, std::vector< Stomp::WeightedAngularCoordinate >::size_type n)"""
        return _stomp.WAngularVector_reserve(self, *args)

    def capacity(self):
        """capacity(WAngularVector self) -> std::vector< Stomp::WeightedAngularCoordinate >::size_type"""
        return _stomp.WAngularVector_capacity(self)

    __swig_destroy__ = _stomp.delete_WAngularVector
    __del__ = lambda self : None;
WAngularVector_swigregister = _stomp.WAngularVector_swigregister
WAngularVector_swigregister(WAngularVector)

class CosmoVector(_object):
    """Proxy of C++ std::vector<(Stomp::CosmoCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosmoVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CosmoVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(CosmoVector self) -> SwigPyIterator"""
        return _stomp.CosmoVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(CosmoVector self) -> bool"""
        return _stomp.CosmoVector___nonzero__(self)

    def __bool__(self):
        """__bool__(CosmoVector self) -> bool"""
        return _stomp.CosmoVector___bool__(self)

    def __len__(self):
        """__len__(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::size_type"""
        return _stomp.CosmoVector___len__(self)

    def pop(self):
        """pop(CosmoVector self) -> CosmoCoordinate"""
        return _stomp.CosmoVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i, std::vector< Stomp::CosmoCoordinate >::difference_type j) -> CosmoVector"""
        return _stomp.CosmoVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i, std::vector< Stomp::CosmoCoordinate >::difference_type j, 
            CosmoVector v=std::vector< Stomp::CosmoCoordinate,std::allocator< Stomp::CosmoCoordinate > >())
        __setslice__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i, std::vector< Stomp::CosmoCoordinate >::difference_type j)
        """
        return _stomp.CosmoVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i, std::vector< Stomp::CosmoCoordinate >::difference_type j)"""
        return _stomp.CosmoVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i)
        __delitem__(CosmoVector self, PySliceObject * slice)
        """
        return _stomp.CosmoVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(CosmoVector self, PySliceObject * slice) -> CosmoVector
        __getitem__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i) -> CosmoCoordinate
        """
        return _stomp.CosmoVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(CosmoVector self, PySliceObject * slice, CosmoVector v)
        __setitem__(CosmoVector self, PySliceObject * slice)
        __setitem__(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::difference_type i, CosmoCoordinate x)
        """
        return _stomp.CosmoVector___setitem__(self, *args)

    def append(self, *args):
        """append(CosmoVector self, CosmoCoordinate x)"""
        return _stomp.CosmoVector_append(self, *args)

    def empty(self):
        """empty(CosmoVector self) -> bool"""
        return _stomp.CosmoVector_empty(self)

    def size(self):
        """size(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::size_type"""
        return _stomp.CosmoVector_size(self)

    def clear(self):
        """clear(CosmoVector self)"""
        return _stomp.CosmoVector_clear(self)

    def swap(self, *args):
        """swap(CosmoVector self, CosmoVector v)"""
        return _stomp.CosmoVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::allocator_type"""
        return _stomp.CosmoVector_get_allocator(self)

    def begin(self):
        """begin(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::iterator"""
        return _stomp.CosmoVector_begin(self)

    def end(self):
        """end(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::iterator"""
        return _stomp.CosmoVector_end(self)

    def rbegin(self):
        """rbegin(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::reverse_iterator"""
        return _stomp.CosmoVector_rbegin(self)

    def rend(self):
        """rend(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::reverse_iterator"""
        return _stomp.CosmoVector_rend(self)

    def pop_back(self):
        """pop_back(CosmoVector self)"""
        return _stomp.CosmoVector_pop_back(self)

    def erase(self, *args):
        """
        erase(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::iterator pos) -> std::vector< Stomp::CosmoCoordinate >::iterator
        erase(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::iterator first, std::vector< Stomp::CosmoCoordinate >::iterator last) -> std::vector< Stomp::CosmoCoordinate >::iterator
        """
        return _stomp.CosmoVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::CosmoCoordinate)> self) -> CosmoVector
        __init__(std::vector<(Stomp::CosmoCoordinate)> self, CosmoVector arg2) -> CosmoVector
        __init__(std::vector<(Stomp::CosmoCoordinate)> self, std::vector< Stomp::CosmoCoordinate >::size_type size) -> CosmoVector
        __init__(std::vector<(Stomp::CosmoCoordinate)> self, std::vector< Stomp::CosmoCoordinate >::size_type size, CosmoCoordinate value) -> CosmoVector
        """
        this = _stomp.new_CosmoVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(CosmoVector self, CosmoCoordinate x)"""
        return _stomp.CosmoVector_push_back(self, *args)

    def front(self):
        """front(CosmoVector self) -> CosmoCoordinate"""
        return _stomp.CosmoVector_front(self)

    def back(self):
        """back(CosmoVector self) -> CosmoCoordinate"""
        return _stomp.CosmoVector_back(self)

    def assign(self, *args):
        """assign(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::size_type n, CosmoCoordinate x)"""
        return _stomp.CosmoVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::size_type new_size)
        resize(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::size_type new_size, CosmoCoordinate x)
        """
        return _stomp.CosmoVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::iterator pos, CosmoCoordinate x) -> std::vector< Stomp::CosmoCoordinate >::iterator
        insert(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::iterator pos, std::vector< Stomp::CosmoCoordinate >::size_type n, 
            CosmoCoordinate x)
        """
        return _stomp.CosmoVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(CosmoVector self, std::vector< Stomp::CosmoCoordinate >::size_type n)"""
        return _stomp.CosmoVector_reserve(self, *args)

    def capacity(self):
        """capacity(CosmoVector self) -> std::vector< Stomp::CosmoCoordinate >::size_type"""
        return _stomp.CosmoVector_capacity(self)

    __swig_destroy__ = _stomp.delete_CosmoVector
    __del__ = lambda self : None;
CosmoVector_swigregister = _stomp.CosmoVector_swigregister
CosmoVector_swigregister(CosmoVector)

class IAngularVector(_object):
    """Proxy of C++ std::vector<(Stomp::IndexedAngularCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAngularVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(IAngularVector self) -> SwigPyIterator"""
        return _stomp.IAngularVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(IAngularVector self) -> bool"""
        return _stomp.IAngularVector___nonzero__(self)

    def __bool__(self):
        """__bool__(IAngularVector self) -> bool"""
        return _stomp.IAngularVector___bool__(self)

    def __len__(self):
        """__len__(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::size_type"""
        return _stomp.IAngularVector___len__(self)

    def pop(self):
        """pop(IAngularVector self) -> IndexedAngularCoordinate"""
        return _stomp.IAngularVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i, std::vector< Stomp::IndexedAngularCoordinate >::difference_type j) -> IAngularVector"""
        return _stomp.IAngularVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i, std::vector< Stomp::IndexedAngularCoordinate >::difference_type j, 
            IAngularVector v=std::vector< Stomp::IndexedAngularCoordinate,std::allocator< Stomp::IndexedAngularCoordinate > >())
        __setslice__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i, std::vector< Stomp::IndexedAngularCoordinate >::difference_type j)
        """
        return _stomp.IAngularVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i, std::vector< Stomp::IndexedAngularCoordinate >::difference_type j)"""
        return _stomp.IAngularVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i)
        __delitem__(IAngularVector self, PySliceObject * slice)
        """
        return _stomp.IAngularVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(IAngularVector self, PySliceObject * slice) -> IAngularVector
        __getitem__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i) -> IndexedAngularCoordinate
        """
        return _stomp.IAngularVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(IAngularVector self, PySliceObject * slice, IAngularVector v)
        __setitem__(IAngularVector self, PySliceObject * slice)
        __setitem__(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::difference_type i, IndexedAngularCoordinate x)
        """
        return _stomp.IAngularVector___setitem__(self, *args)

    def append(self, *args):
        """append(IAngularVector self, IndexedAngularCoordinate x)"""
        return _stomp.IAngularVector_append(self, *args)

    def empty(self):
        """empty(IAngularVector self) -> bool"""
        return _stomp.IAngularVector_empty(self)

    def size(self):
        """size(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::size_type"""
        return _stomp.IAngularVector_size(self)

    def clear(self):
        """clear(IAngularVector self)"""
        return _stomp.IAngularVector_clear(self)

    def swap(self, *args):
        """swap(IAngularVector self, IAngularVector v)"""
        return _stomp.IAngularVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::allocator_type"""
        return _stomp.IAngularVector_get_allocator(self)

    def begin(self):
        """begin(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::iterator"""
        return _stomp.IAngularVector_begin(self)

    def end(self):
        """end(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::iterator"""
        return _stomp.IAngularVector_end(self)

    def rbegin(self):
        """rbegin(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::reverse_iterator"""
        return _stomp.IAngularVector_rbegin(self)

    def rend(self):
        """rend(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::reverse_iterator"""
        return _stomp.IAngularVector_rend(self)

    def pop_back(self):
        """pop_back(IAngularVector self)"""
        return _stomp.IAngularVector_pop_back(self)

    def erase(self, *args):
        """
        erase(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::iterator pos) -> std::vector< Stomp::IndexedAngularCoordinate >::iterator
        erase(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::iterator first, std::vector< Stomp::IndexedAngularCoordinate >::iterator last) -> std::vector< Stomp::IndexedAngularCoordinate >::iterator
        """
        return _stomp.IAngularVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::IndexedAngularCoordinate)> self) -> IAngularVector
        __init__(std::vector<(Stomp::IndexedAngularCoordinate)> self, IAngularVector arg2) -> IAngularVector
        __init__(std::vector<(Stomp::IndexedAngularCoordinate)> self, std::vector< Stomp::IndexedAngularCoordinate >::size_type size) -> IAngularVector
        __init__(std::vector<(Stomp::IndexedAngularCoordinate)> self, std::vector< Stomp::IndexedAngularCoordinate >::size_type size, IndexedAngularCoordinate value) -> IAngularVector
        """
        this = _stomp.new_IAngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(IAngularVector self, IndexedAngularCoordinate x)"""
        return _stomp.IAngularVector_push_back(self, *args)

    def front(self):
        """front(IAngularVector self) -> IndexedAngularCoordinate"""
        return _stomp.IAngularVector_front(self)

    def back(self):
        """back(IAngularVector self) -> IndexedAngularCoordinate"""
        return _stomp.IAngularVector_back(self)

    def assign(self, *args):
        """assign(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::size_type n, IndexedAngularCoordinate x)"""
        return _stomp.IAngularVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::size_type new_size)
        resize(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::size_type new_size, IndexedAngularCoordinate x)
        """
        return _stomp.IAngularVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::iterator pos, IndexedAngularCoordinate x) -> std::vector< Stomp::IndexedAngularCoordinate >::iterator
        insert(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::iterator pos, std::vector< Stomp::IndexedAngularCoordinate >::size_type n, 
            IndexedAngularCoordinate x)
        """
        return _stomp.IAngularVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(IAngularVector self, std::vector< Stomp::IndexedAngularCoordinate >::size_type n)"""
        return _stomp.IAngularVector_reserve(self, *args)

    def capacity(self):
        """capacity(IAngularVector self) -> std::vector< Stomp::IndexedAngularCoordinate >::size_type"""
        return _stomp.IAngularVector_capacity(self)

    __swig_destroy__ = _stomp.delete_IAngularVector
    __del__ = lambda self : None;
IAngularVector_swigregister = _stomp.IAngularVector_swigregister
IAngularVector_swigregister(IAngularVector)

class PixelVector(_object):
    """Proxy of C++ std::vector<(Stomp::Pixel)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(PixelVector self) -> SwigPyIterator"""
        return _stomp.PixelVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(PixelVector self) -> bool"""
        return _stomp.PixelVector___nonzero__(self)

    def __bool__(self):
        """__bool__(PixelVector self) -> bool"""
        return _stomp.PixelVector___bool__(self)

    def __len__(self):
        """__len__(PixelVector self) -> std::vector< Stomp::Pixel >::size_type"""
        return _stomp.PixelVector___len__(self)

    def pop(self):
        """pop(PixelVector self) -> Pixel"""
        return _stomp.PixelVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i, std::vector< Stomp::Pixel >::difference_type j) -> PixelVector"""
        return _stomp.PixelVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i, std::vector< Stomp::Pixel >::difference_type j, 
            PixelVector v=std::vector< Stomp::Pixel,std::allocator< Stomp::Pixel > >())
        __setslice__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i, std::vector< Stomp::Pixel >::difference_type j)
        """
        return _stomp.PixelVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i, std::vector< Stomp::Pixel >::difference_type j)"""
        return _stomp.PixelVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i)
        __delitem__(PixelVector self, PySliceObject * slice)
        """
        return _stomp.PixelVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(PixelVector self, PySliceObject * slice) -> PixelVector
        __getitem__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i) -> Pixel
        """
        return _stomp.PixelVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(PixelVector self, PySliceObject * slice, PixelVector v)
        __setitem__(PixelVector self, PySliceObject * slice)
        __setitem__(PixelVector self, std::vector< Stomp::Pixel >::difference_type i, Pixel x)
        """
        return _stomp.PixelVector___setitem__(self, *args)

    def append(self, *args):
        """append(PixelVector self, Pixel x)"""
        return _stomp.PixelVector_append(self, *args)

    def empty(self):
        """empty(PixelVector self) -> bool"""
        return _stomp.PixelVector_empty(self)

    def size(self):
        """size(PixelVector self) -> std::vector< Stomp::Pixel >::size_type"""
        return _stomp.PixelVector_size(self)

    def clear(self):
        """clear(PixelVector self)"""
        return _stomp.PixelVector_clear(self)

    def swap(self, *args):
        """swap(PixelVector self, PixelVector v)"""
        return _stomp.PixelVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(PixelVector self) -> std::vector< Stomp::Pixel >::allocator_type"""
        return _stomp.PixelVector_get_allocator(self)

    def begin(self):
        """begin(PixelVector self) -> std::vector< Stomp::Pixel >::iterator"""
        return _stomp.PixelVector_begin(self)

    def end(self):
        """end(PixelVector self) -> std::vector< Stomp::Pixel >::iterator"""
        return _stomp.PixelVector_end(self)

    def rbegin(self):
        """rbegin(PixelVector self) -> std::vector< Stomp::Pixel >::reverse_iterator"""
        return _stomp.PixelVector_rbegin(self)

    def rend(self):
        """rend(PixelVector self) -> std::vector< Stomp::Pixel >::reverse_iterator"""
        return _stomp.PixelVector_rend(self)

    def pop_back(self):
        """pop_back(PixelVector self)"""
        return _stomp.PixelVector_pop_back(self)

    def erase(self, *args):
        """
        erase(PixelVector self, std::vector< Stomp::Pixel >::iterator pos) -> std::vector< Stomp::Pixel >::iterator
        erase(PixelVector self, std::vector< Stomp::Pixel >::iterator first, std::vector< Stomp::Pixel >::iterator last) -> std::vector< Stomp::Pixel >::iterator
        """
        return _stomp.PixelVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::Pixel)> self) -> PixelVector
        __init__(std::vector<(Stomp::Pixel)> self, PixelVector arg2) -> PixelVector
        __init__(std::vector<(Stomp::Pixel)> self, std::vector< Stomp::Pixel >::size_type size) -> PixelVector
        __init__(std::vector<(Stomp::Pixel)> self, std::vector< Stomp::Pixel >::size_type size, Pixel value) -> PixelVector
        """
        this = _stomp.new_PixelVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(PixelVector self, Pixel x)"""
        return _stomp.PixelVector_push_back(self, *args)

    def front(self):
        """front(PixelVector self) -> Pixel"""
        return _stomp.PixelVector_front(self)

    def back(self):
        """back(PixelVector self) -> Pixel"""
        return _stomp.PixelVector_back(self)

    def assign(self, *args):
        """assign(PixelVector self, std::vector< Stomp::Pixel >::size_type n, Pixel x)"""
        return _stomp.PixelVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(PixelVector self, std::vector< Stomp::Pixel >::size_type new_size)
        resize(PixelVector self, std::vector< Stomp::Pixel >::size_type new_size, Pixel x)
        """
        return _stomp.PixelVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(PixelVector self, std::vector< Stomp::Pixel >::iterator pos, Pixel x) -> std::vector< Stomp::Pixel >::iterator
        insert(PixelVector self, std::vector< Stomp::Pixel >::iterator pos, std::vector< Stomp::Pixel >::size_type n, 
            Pixel x)
        """
        return _stomp.PixelVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(PixelVector self, std::vector< Stomp::Pixel >::size_type n)"""
        return _stomp.PixelVector_reserve(self, *args)

    def capacity(self):
        """capacity(PixelVector self) -> std::vector< Stomp::Pixel >::size_type"""
        return _stomp.PixelVector_capacity(self)

    __swig_destroy__ = _stomp.delete_PixelVector
    __del__ = lambda self : None;
PixelVector_swigregister = _stomp.PixelVector_swigregister
PixelVector_swigregister(PixelVector)

class ScalarVector(_object):
    """Proxy of C++ std::vector<(Stomp::ScalarPixel)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(ScalarVector self) -> SwigPyIterator"""
        return _stomp.ScalarVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(ScalarVector self) -> bool"""
        return _stomp.ScalarVector___nonzero__(self)

    def __bool__(self):
        """__bool__(ScalarVector self) -> bool"""
        return _stomp.ScalarVector___bool__(self)

    def __len__(self):
        """__len__(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::size_type"""
        return _stomp.ScalarVector___len__(self)

    def pop(self):
        """pop(ScalarVector self) -> ScalarPixel"""
        return _stomp.ScalarVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i, std::vector< Stomp::ScalarPixel >::difference_type j) -> ScalarVector"""
        return _stomp.ScalarVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i, std::vector< Stomp::ScalarPixel >::difference_type j, 
            ScalarVector v=std::vector< Stomp::ScalarPixel,std::allocator< Stomp::ScalarPixel > >())
        __setslice__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i, std::vector< Stomp::ScalarPixel >::difference_type j)
        """
        return _stomp.ScalarVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i, std::vector< Stomp::ScalarPixel >::difference_type j)"""
        return _stomp.ScalarVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i)
        __delitem__(ScalarVector self, PySliceObject * slice)
        """
        return _stomp.ScalarVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(ScalarVector self, PySliceObject * slice) -> ScalarVector
        __getitem__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i) -> ScalarPixel
        """
        return _stomp.ScalarVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(ScalarVector self, PySliceObject * slice, ScalarVector v)
        __setitem__(ScalarVector self, PySliceObject * slice)
        __setitem__(ScalarVector self, std::vector< Stomp::ScalarPixel >::difference_type i, ScalarPixel x)
        """
        return _stomp.ScalarVector___setitem__(self, *args)

    def append(self, *args):
        """append(ScalarVector self, ScalarPixel x)"""
        return _stomp.ScalarVector_append(self, *args)

    def empty(self):
        """empty(ScalarVector self) -> bool"""
        return _stomp.ScalarVector_empty(self)

    def size(self):
        """size(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::size_type"""
        return _stomp.ScalarVector_size(self)

    def clear(self):
        """clear(ScalarVector self)"""
        return _stomp.ScalarVector_clear(self)

    def swap(self, *args):
        """swap(ScalarVector self, ScalarVector v)"""
        return _stomp.ScalarVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::allocator_type"""
        return _stomp.ScalarVector_get_allocator(self)

    def begin(self):
        """begin(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::iterator"""
        return _stomp.ScalarVector_begin(self)

    def end(self):
        """end(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::iterator"""
        return _stomp.ScalarVector_end(self)

    def rbegin(self):
        """rbegin(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::reverse_iterator"""
        return _stomp.ScalarVector_rbegin(self)

    def rend(self):
        """rend(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::reverse_iterator"""
        return _stomp.ScalarVector_rend(self)

    def pop_back(self):
        """pop_back(ScalarVector self)"""
        return _stomp.ScalarVector_pop_back(self)

    def erase(self, *args):
        """
        erase(ScalarVector self, std::vector< Stomp::ScalarPixel >::iterator pos) -> std::vector< Stomp::ScalarPixel >::iterator
        erase(ScalarVector self, std::vector< Stomp::ScalarPixel >::iterator first, std::vector< Stomp::ScalarPixel >::iterator last) -> std::vector< Stomp::ScalarPixel >::iterator
        """
        return _stomp.ScalarVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Stomp::ScalarPixel)> self) -> ScalarVector
        __init__(std::vector<(Stomp::ScalarPixel)> self, ScalarVector arg2) -> ScalarVector
        __init__(std::vector<(Stomp::ScalarPixel)> self, std::vector< Stomp::ScalarPixel >::size_type size) -> ScalarVector
        __init__(std::vector<(Stomp::ScalarPixel)> self, std::vector< Stomp::ScalarPixel >::size_type size, ScalarPixel value) -> ScalarVector
        """
        this = _stomp.new_ScalarVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(ScalarVector self, ScalarPixel x)"""
        return _stomp.ScalarVector_push_back(self, *args)

    def front(self):
        """front(ScalarVector self) -> ScalarPixel"""
        return _stomp.ScalarVector_front(self)

    def back(self):
        """back(ScalarVector self) -> ScalarPixel"""
        return _stomp.ScalarVector_back(self)

    def assign(self, *args):
        """assign(ScalarVector self, std::vector< Stomp::ScalarPixel >::size_type n, ScalarPixel x)"""
        return _stomp.ScalarVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(ScalarVector self, std::vector< Stomp::ScalarPixel >::size_type new_size)
        resize(ScalarVector self, std::vector< Stomp::ScalarPixel >::size_type new_size, ScalarPixel x)
        """
        return _stomp.ScalarVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(ScalarVector self, std::vector< Stomp::ScalarPixel >::iterator pos, ScalarPixel x) -> std::vector< Stomp::ScalarPixel >::iterator
        insert(ScalarVector self, std::vector< Stomp::ScalarPixel >::iterator pos, std::vector< Stomp::ScalarPixel >::size_type n, 
            ScalarPixel x)
        """
        return _stomp.ScalarVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(ScalarVector self, std::vector< Stomp::ScalarPixel >::size_type n)"""
        return _stomp.ScalarVector_reserve(self, *args)

    def capacity(self):
        """capacity(ScalarVector self) -> std::vector< Stomp::ScalarPixel >::size_type"""
        return _stomp.ScalarVector_capacity(self)

    __swig_destroy__ = _stomp.delete_ScalarVector
    __del__ = lambda self : None;
ScalarVector_swigregister = _stomp.ScalarVector_swigregister
ScalarVector_swigregister(ScalarVector)

class FieldDict(_object):
    """Proxy of C++ std::map<(std::string,double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FieldDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FieldDict, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(FieldDict self) -> SwigPyIterator"""
        return _stomp.FieldDict_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(FieldDict self) -> bool"""
        return _stomp.FieldDict___nonzero__(self)

    def __bool__(self):
        """__bool__(FieldDict self) -> bool"""
        return _stomp.FieldDict___bool__(self)

    def __len__(self):
        """__len__(FieldDict self) -> std::map< std::string,double >::size_type"""
        return _stomp.FieldDict___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """__getitem__(FieldDict self, std::map< std::string,double >::key_type const & key) -> std::map< std::string,double >::mapped_type const &"""
        return _stomp.FieldDict___getitem__(self, *args)

    def __delitem__(self, *args):
        """__delitem__(FieldDict self, std::map< std::string,double >::key_type const & key)"""
        return _stomp.FieldDict___delitem__(self, *args)

    def has_key(self, *args):
        """has_key(FieldDict self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _stomp.FieldDict_has_key(self, *args)

    def keys(self):
        """keys(FieldDict self) -> PyObject *"""
        return _stomp.FieldDict_keys(self)

    def values(self):
        """values(FieldDict self) -> PyObject *"""
        return _stomp.FieldDict_values(self)

    def items(self):
        """items(FieldDict self) -> PyObject *"""
        return _stomp.FieldDict_items(self)

    def __contains__(self, *args):
        """__contains__(FieldDict self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _stomp.FieldDict___contains__(self, *args)

    def key_iterator(self):
        """key_iterator(FieldDict self) -> SwigPyIterator"""
        return _stomp.FieldDict_key_iterator(self)

    def value_iterator(self):
        """value_iterator(FieldDict self) -> SwigPyIterator"""
        return _stomp.FieldDict_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(FieldDict self, std::map< std::string,double >::key_type const & key)
        __setitem__(FieldDict self, std::map< std::string,double >::key_type const & key, std::map< std::string,double >::mapped_type const & x)
        """
        return _stomp.FieldDict___setitem__(self, *args)

    def asdict(self):
        """asdict(FieldDict self) -> PyObject *"""
        return _stomp.FieldDict_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,double)> self, std::less< std::string > const & arg2) -> FieldDict
        __init__(std::map<(std::string,double)> self) -> FieldDict
        __init__(std::map<(std::string,double)> self, FieldDict arg2) -> FieldDict
        """
        this = _stomp.new_FieldDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(FieldDict self) -> bool"""
        return _stomp.FieldDict_empty(self)

    def size(self):
        """size(FieldDict self) -> std::map< std::string,double >::size_type"""
        return _stomp.FieldDict_size(self)

    def clear(self):
        """clear(FieldDict self)"""
        return _stomp.FieldDict_clear(self)

    def swap(self, *args):
        """swap(FieldDict self, FieldDict v)"""
        return _stomp.FieldDict_swap(self, *args)

    def get_allocator(self):
        """get_allocator(FieldDict self) -> std::map< std::string,double >::allocator_type"""
        return _stomp.FieldDict_get_allocator(self)

    def begin(self):
        """begin(FieldDict self) -> std::map< std::string,double >::iterator"""
        return _stomp.FieldDict_begin(self)

    def end(self):
        """end(FieldDict self) -> std::map< std::string,double >::iterator"""
        return _stomp.FieldDict_end(self)

    def rbegin(self):
        """rbegin(FieldDict self) -> std::map< std::string,double >::reverse_iterator"""
        return _stomp.FieldDict_rbegin(self)

    def rend(self):
        """rend(FieldDict self) -> std::map< std::string,double >::reverse_iterator"""
        return _stomp.FieldDict_rend(self)

    def count(self, *args):
        """count(FieldDict self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type"""
        return _stomp.FieldDict_count(self, *args)

    def erase(self, *args):
        """
        erase(FieldDict self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type
        erase(FieldDict self, std::map< std::string,double >::iterator position)
        erase(FieldDict self, std::map< std::string,double >::iterator first, std::map< std::string,double >::iterator last)
        """
        return _stomp.FieldDict_erase(self, *args)

    def find(self, *args):
        """find(FieldDict self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _stomp.FieldDict_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(FieldDict self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _stomp.FieldDict_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(FieldDict self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _stomp.FieldDict_upper_bound(self, *args)

    __swig_destroy__ = _stomp.delete_FieldDict
    __del__ = lambda self : None;
FieldDict_swigregister = _stomp.FieldDict_swigregister
FieldDict_swigregister(FieldDict)

class FieldColumnDict(_object):
    """Proxy of C++ std::map<(std::string,uint8_t)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FieldColumnDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FieldColumnDict, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(FieldColumnDict self) -> SwigPyIterator"""
        return _stomp.FieldColumnDict_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(FieldColumnDict self) -> bool"""
        return _stomp.FieldColumnDict___nonzero__(self)

    def __bool__(self):
        """__bool__(FieldColumnDict self) -> bool"""
        return _stomp.FieldColumnDict___bool__(self)

    def __len__(self):
        """__len__(FieldColumnDict self) -> std::map< std::string,unsigned char >::size_type"""
        return _stomp.FieldColumnDict___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """__getitem__(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & key) -> std::map< std::string,unsigned char >::mapped_type const &"""
        return _stomp.FieldColumnDict___getitem__(self, *args)

    def __delitem__(self, *args):
        """__delitem__(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & key)"""
        return _stomp.FieldColumnDict___delitem__(self, *args)

    def has_key(self, *args):
        """has_key(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & key) -> bool"""
        return _stomp.FieldColumnDict_has_key(self, *args)

    def keys(self):
        """keys(FieldColumnDict self) -> PyObject *"""
        return _stomp.FieldColumnDict_keys(self)

    def values(self):
        """values(FieldColumnDict self) -> PyObject *"""
        return _stomp.FieldColumnDict_values(self)

    def items(self):
        """items(FieldColumnDict self) -> PyObject *"""
        return _stomp.FieldColumnDict_items(self)

    def __contains__(self, *args):
        """__contains__(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & key) -> bool"""
        return _stomp.FieldColumnDict___contains__(self, *args)

    def key_iterator(self):
        """key_iterator(FieldColumnDict self) -> SwigPyIterator"""
        return _stomp.FieldColumnDict_key_iterator(self)

    def value_iterator(self):
        """value_iterator(FieldColumnDict self) -> SwigPyIterator"""
        return _stomp.FieldColumnDict_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & key)
        __setitem__(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & key, std::map< std::string,unsigned char >::mapped_type const & x)
        """
        return _stomp.FieldColumnDict___setitem__(self, *args)

    def asdict(self):
        """asdict(FieldColumnDict self) -> PyObject *"""
        return _stomp.FieldColumnDict_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,uint8_t)> self, std::less< std::string > const & arg2) -> FieldColumnDict
        __init__(std::map<(std::string,uint8_t)> self) -> FieldColumnDict
        __init__(std::map<(std::string,uint8_t)> self, FieldColumnDict arg2) -> FieldColumnDict
        """
        this = _stomp.new_FieldColumnDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(FieldColumnDict self) -> bool"""
        return _stomp.FieldColumnDict_empty(self)

    def size(self):
        """size(FieldColumnDict self) -> std::map< std::string,unsigned char >::size_type"""
        return _stomp.FieldColumnDict_size(self)

    def clear(self):
        """clear(FieldColumnDict self)"""
        return _stomp.FieldColumnDict_clear(self)

    def swap(self, *args):
        """swap(FieldColumnDict self, FieldColumnDict v)"""
        return _stomp.FieldColumnDict_swap(self, *args)

    def get_allocator(self):
        """get_allocator(FieldColumnDict self) -> std::map< std::string,unsigned char >::allocator_type"""
        return _stomp.FieldColumnDict_get_allocator(self)

    def begin(self):
        """begin(FieldColumnDict self) -> std::map< std::string,unsigned char >::iterator"""
        return _stomp.FieldColumnDict_begin(self)

    def end(self):
        """end(FieldColumnDict self) -> std::map< std::string,unsigned char >::iterator"""
        return _stomp.FieldColumnDict_end(self)

    def rbegin(self):
        """rbegin(FieldColumnDict self) -> std::map< std::string,unsigned char >::reverse_iterator"""
        return _stomp.FieldColumnDict_rbegin(self)

    def rend(self):
        """rend(FieldColumnDict self) -> std::map< std::string,unsigned char >::reverse_iterator"""
        return _stomp.FieldColumnDict_rend(self)

    def count(self, *args):
        """count(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::size_type"""
        return _stomp.FieldColumnDict_count(self, *args)

    def erase(self, *args):
        """
        erase(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::size_type
        erase(FieldColumnDict self, std::map< std::string,unsigned char >::iterator position)
        erase(FieldColumnDict self, std::map< std::string,unsigned char >::iterator first, std::map< std::string,unsigned char >::iterator last)
        """
        return _stomp.FieldColumnDict_erase(self, *args)

    def find(self, *args):
        """find(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::iterator"""
        return _stomp.FieldColumnDict_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::iterator"""
        return _stomp.FieldColumnDict_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(FieldColumnDict self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::iterator"""
        return _stomp.FieldColumnDict_upper_bound(self, *args)

    __swig_destroy__ = _stomp.delete_FieldColumnDict
    __del__ = lambda self : None;
FieldColumnDict_swigregister = _stomp.FieldColumnDict_swigregister
FieldColumnDict_swigregister(FieldColumnDict)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DoubleVector self) -> SwigPyIterator"""
        return _stomp.DoubleVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DoubleVector self) -> bool"""
        return _stomp.DoubleVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DoubleVector self) -> bool"""
        return _stomp.DoubleVector___bool__(self)

    def __len__(self):
        """__len__(DoubleVector self) -> std::vector< double >::size_type"""
        return _stomp.DoubleVector___len__(self)

    def pop(self):
        """pop(DoubleVector self) -> std::vector< double >::value_type"""
        return _stomp.DoubleVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DoubleVector"""
        return _stomp.DoubleVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            DoubleVector v=std::vector< double,std::allocator< double > >())
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _stomp.DoubleVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _stomp.DoubleVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DoubleVector self, std::vector< double >::difference_type i)
        __delitem__(DoubleVector self, PySliceObject * slice)
        """
        return _stomp.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DoubleVector self, PySliceObject * slice) -> DoubleVector
        __getitem__(DoubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _stomp.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DoubleVector self, PySliceObject * slice, DoubleVector v)
        __setitem__(DoubleVector self, PySliceObject * slice)
        __setitem__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _stomp.DoubleVector___setitem__(self, *args)

    def append(self, *args):
        """append(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _stomp.DoubleVector_append(self, *args)

    def empty(self):
        """empty(DoubleVector self) -> bool"""
        return _stomp.DoubleVector_empty(self)

    def size(self):
        """size(DoubleVector self) -> std::vector< double >::size_type"""
        return _stomp.DoubleVector_size(self)

    def clear(self):
        """clear(DoubleVector self)"""
        return _stomp.DoubleVector_clear(self)

    def swap(self, *args):
        """swap(DoubleVector self, DoubleVector v)"""
        return _stomp.DoubleVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DoubleVector self) -> std::vector< double >::allocator_type"""
        return _stomp.DoubleVector_get_allocator(self)

    def begin(self):
        """begin(DoubleVector self) -> std::vector< double >::iterator"""
        return _stomp.DoubleVector_begin(self)

    def end(self):
        """end(DoubleVector self) -> std::vector< double >::iterator"""
        return _stomp.DoubleVector_end(self)

    def rbegin(self):
        """rbegin(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _stomp.DoubleVector_rbegin(self)

    def rend(self):
        """rend(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _stomp.DoubleVector_rend(self)

    def pop_back(self):
        """pop_back(DoubleVector self)"""
        return _stomp.DoubleVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DoubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DoubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _stomp.DoubleVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> DoubleVector
        __init__(std::vector<(double)> self, DoubleVector arg2) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DoubleVector
        """
        this = _stomp.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _stomp.DoubleVector_push_back(self, *args)

    def front(self):
        """front(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _stomp.DoubleVector_front(self)

    def back(self):
        """back(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _stomp.DoubleVector_back(self)

    def assign(self, *args):
        """assign(DoubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _stomp.DoubleVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DoubleVector self, std::vector< double >::size_type new_size)
        resize(DoubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _stomp.DoubleVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _stomp.DoubleVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DoubleVector self, std::vector< double >::size_type n)"""
        return _stomp.DoubleVector_reserve(self, *args)

    def capacity(self):
        """capacity(DoubleVector self) -> std::vector< double >::size_type"""
        return _stomp.DoubleVector_capacity(self)

    __swig_destroy__ = _stomp.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _stomp.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class IndexVector(_object):
    """Proxy of C++ std::vector<(uint32_t)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(IndexVector self) -> SwigPyIterator"""
        return _stomp.IndexVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(IndexVector self) -> bool"""
        return _stomp.IndexVector___nonzero__(self)

    def __bool__(self):
        """__bool__(IndexVector self) -> bool"""
        return _stomp.IndexVector___bool__(self)

    def __len__(self):
        """__len__(IndexVector self) -> std::vector< unsigned int >::size_type"""
        return _stomp.IndexVector___len__(self)

    def pop(self):
        """pop(IndexVector self) -> std::vector< unsigned int >::value_type"""
        return _stomp.IndexVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(IndexVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> IndexVector"""
        return _stomp.IndexVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(IndexVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, 
            IndexVector v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(IndexVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        """
        return _stomp.IndexVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(IndexVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _stomp.IndexVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(IndexVector self, std::vector< unsigned int >::difference_type i)
        __delitem__(IndexVector self, PySliceObject * slice)
        """
        return _stomp.IndexVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(IndexVector self, PySliceObject * slice) -> IndexVector
        __getitem__(IndexVector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _stomp.IndexVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(IndexVector self, PySliceObject * slice, IndexVector v)
        __setitem__(IndexVector self, PySliceObject * slice)
        __setitem__(IndexVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _stomp.IndexVector___setitem__(self, *args)

    def append(self, *args):
        """append(IndexVector self, std::vector< unsigned int >::value_type const & x)"""
        return _stomp.IndexVector_append(self, *args)

    def empty(self):
        """empty(IndexVector self) -> bool"""
        return _stomp.IndexVector_empty(self)

    def size(self):
        """size(IndexVector self) -> std::vector< unsigned int >::size_type"""
        return _stomp.IndexVector_size(self)

    def clear(self):
        """clear(IndexVector self)"""
        return _stomp.IndexVector_clear(self)

    def swap(self, *args):
        """swap(IndexVector self, IndexVector v)"""
        return _stomp.IndexVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(IndexVector self) -> std::vector< unsigned int >::allocator_type"""
        return _stomp.IndexVector_get_allocator(self)

    def begin(self):
        """begin(IndexVector self) -> std::vector< unsigned int >::iterator"""
        return _stomp.IndexVector_begin(self)

    def end(self):
        """end(IndexVector self) -> std::vector< unsigned int >::iterator"""
        return _stomp.IndexVector_end(self)

    def rbegin(self):
        """rbegin(IndexVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _stomp.IndexVector_rbegin(self)

    def rend(self):
        """rend(IndexVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _stomp.IndexVector_rend(self)

    def pop_back(self):
        """pop_back(IndexVector self)"""
        return _stomp.IndexVector_pop_back(self)

    def erase(self, *args):
        """
        erase(IndexVector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(IndexVector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _stomp.IndexVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(uint32_t)> self) -> IndexVector
        __init__(std::vector<(uint32_t)> self, IndexVector arg2) -> IndexVector
        __init__(std::vector<(uint32_t)> self, std::vector< unsigned int >::size_type size) -> IndexVector
        __init__(std::vector<(uint32_t)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> IndexVector
        """
        this = _stomp.new_IndexVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(IndexVector self, std::vector< unsigned int >::value_type const & x)"""
        return _stomp.IndexVector_push_back(self, *args)

    def front(self):
        """front(IndexVector self) -> std::vector< unsigned int >::value_type const &"""
        return _stomp.IndexVector_front(self)

    def back(self):
        """back(IndexVector self) -> std::vector< unsigned int >::value_type const &"""
        return _stomp.IndexVector_back(self)

    def assign(self, *args):
        """assign(IndexVector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _stomp.IndexVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(IndexVector self, std::vector< unsigned int >::size_type new_size)
        resize(IndexVector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _stomp.IndexVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(IndexVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(IndexVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, 
            std::vector< unsigned int >::value_type const & x)
        """
        return _stomp.IndexVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(IndexVector self, std::vector< unsigned int >::size_type n)"""
        return _stomp.IndexVector_reserve(self, *args)

    def capacity(self):
        """capacity(IndexVector self) -> std::vector< unsigned int >::size_type"""
        return _stomp.IndexVector_capacity(self)

    __swig_destroy__ = _stomp.delete_IndexVector
    __del__ = lambda self : None;
IndexVector_swigregister = _stomp.IndexVector_swigregister
IndexVector_swigregister(IndexVector)


def _iter_incr(*args):
  """
    _iter_incr(std::vector< Stomp::AngularBin,std::allocator< Stomp::AngularBin > >::const_iterator * iter)
    _iter_incr(std::vector< Stomp::RadialBin,std::allocator< Stomp::RadialBin > >::const_iterator * iter)
    _iter_incr(std::vector< Stomp::HistogramBin,std::allocator< Stomp::HistogramBin > >::const_iterator * iter)
    """
  return _stomp._iter_incr(*args)
# This file is compatible with both classic and new-style classes.


