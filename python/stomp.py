# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_stomp', [dirname(__file__)])
        except ImportError:
            import _stomp
            return _stomp
        if fp is not None:
            try:
                _mod = imp.load_module('_stomp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _stomp = swig_import_helper()
    del swig_import_helper
else:
    import _stomp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _stomp.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _stomp.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _stomp.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _stomp.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _stomp.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _stomp.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _stomp.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _stomp.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _stomp.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _stomp.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _stomp.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _stomp.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _stomp.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _stomp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class GenericIterator:
    def __init__(self, begin_iter_method, deref_method, incr_method):
        self.it = begin_iter_method()
        self.incr   = incr_method
        self.deref  = deref_method

    def __iter__(self):
        return self

    def next(self):
        obj = self.deref( self.it )
        if obj is not None:
            self.incr( self.it )
            return obj
        else:
            raise StopIteration


def DoubleLT(*args):
  """DoubleLT(double a, double b) -> bool"""
  return _stomp.DoubleLT(*args)

def DoubleLE(*args):
  """DoubleLE(double a, double b) -> bool"""
  return _stomp.DoubleLE(*args)

def DoubleGT(*args):
  """DoubleGT(double a, double b) -> bool"""
  return _stomp.DoubleGT(*args)

def DoubleGE(*args):
  """DoubleGE(double a, double b) -> bool"""
  return _stomp.DoubleGE(*args)

def DoubleEQ(*args):
  """DoubleEQ(double a, double b) -> bool"""
  return _stomp.DoubleEQ(*args)

def MostSignificantBit(*args):
  """MostSignificantBit(uint32_t input_int) -> uint8_t"""
  return _stomp.MostSignificantBit(*args)
class AngularBin(_object):
    """Proxy of C++ Stomp::AngularBin class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularBin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularBin, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_AngularBin
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> AngularBin
        __init__(self, double theta_min, double theta_max) -> AngularBin
        __init__(self, double theta_min, double theta_max, int16_t n_regions) -> AngularBin
        """
        this = _stomp.new_AngularBin(*args)
        try: self.this.append(this)
        except: self.this = this
    def ClearRegions(self):
        """ClearRegions(self)"""
        return _stomp.AngularBin_ClearRegions(self)

    def InitializeRegions(self, *args):
        """InitializeRegions(self, int16_t n_regions)"""
        return _stomp.AngularBin_InitializeRegions(self, *args)

    def SetResolution(self, *args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.AngularBin_SetResolution(self, *args)

    def CalculateResolution(self, *args):
        """
        CalculateResolution(self, double lammin = -70.0, double lammax = 70.0, uint32_t max_resolution = MaxPixelResolution)
        CalculateResolution(self, double lammin = -70.0, double lammax = 70.0)
        CalculateResolution(self, double lammin = -70.0)
        CalculateResolution(self)
        """
        return _stomp.AngularBin_CalculateResolution(self, *args)

    def SetThetaMin(self, *args):
        """SetThetaMin(self, double theta_min)"""
        return _stomp.AngularBin_SetThetaMin(self, *args)

    def SetThetaMax(self, *args):
        """SetThetaMax(self, double theta_max)"""
        return _stomp.AngularBin_SetThetaMax(self, *args)

    def SetTheta(self, *args):
        """SetTheta(self, double theta)"""
        return _stomp.AngularBin_SetTheta(self, *args)

    def WithinBounds(self, *args):
        """WithinBounds(self, double theta) -> bool"""
        return _stomp.AngularBin_WithinBounds(self, *args)

    def WithinSin2Bounds(self, *args):
        """WithinSin2Bounds(self, double sin2theta) -> bool"""
        return _stomp.AngularBin_WithinSin2Bounds(self, *args)

    def WithinCosBounds(self, *args):
        """WithinCosBounds(self, double costheta) -> bool"""
        return _stomp.AngularBin_WithinCosBounds(self, *args)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.AngularBin_Area(self)

    def PoissonNoise(self, *args):
        """PoissonNoise(self, double objects_per_square_degree, double survey_area) -> double"""
        return _stomp.AngularBin_PoissonNoise(self, *args)

    def AddToPixelWtheta(self, *args):
        """
        AddToPixelWtheta(self, double dwtheta, double dweight, int16_t region_a = -1, 
            int16_t region_b = -1)
        AddToPixelWtheta(self, double dwtheta, double dweight, int16_t region_a = -1)
        AddToPixelWtheta(self, double dwtheta, double dweight)
        """
        return _stomp.AngularBin_AddToPixelWtheta(self, *args)

    def AddToWeight(self, *args):
        """
        AddToWeight(self, double weight, int16_t region = -1)
        AddToWeight(self, double weight)
        """
        return _stomp.AngularBin_AddToWeight(self, *args)

    def AddToCounter(self, *args):
        """
        AddToCounter(self, uint32_t step = 1, int16_t region = -1)
        AddToCounter(self, uint32_t step = 1)
        AddToCounter(self)
        """
        return _stomp.AngularBin_AddToCounter(self, *args)

    def MoveWeightToGalGal(self):
        """MoveWeightToGalGal(self)"""
        return _stomp.AngularBin_MoveWeightToGalGal(self)

    def MoveWeightToGalRand(self, move_to_rand_gal = False):
        """
        MoveWeightToGalRand(self, bool move_to_rand_gal = False)
        MoveWeightToGalRand(self)
        """
        return _stomp.AngularBin_MoveWeightToGalRand(self, move_to_rand_gal)

    def MoveWeightToRandGal(self, move_to_gal_rand = False):
        """
        MoveWeightToRandGal(self, bool move_to_gal_rand = False)
        MoveWeightToRandGal(self)
        """
        return _stomp.AngularBin_MoveWeightToRandGal(self, move_to_gal_rand)

    def MoveWeightToRandRand(self):
        """MoveWeightToRandRand(self)"""
        return _stomp.AngularBin_MoveWeightToRandRand(self)

    def RescaleGalGal(self, *args):
        """RescaleGalGal(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleGalGal(self, *args)

    def RescaleGalRand(self, *args):
        """RescaleGalRand(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleGalRand(self, *args)

    def RescaleRandGal(self, *args):
        """RescaleRandGal(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleRandGal(self, *args)

    def RescaleRandRand(self, *args):
        """RescaleRandRand(self, double pair_ratio)"""
        return _stomp.AngularBin_RescaleRandRand(self, *args)

    def Reset(self):
        """Reset(self)"""
        return _stomp.AngularBin_Reset(self)

    def ResetPixelWtheta(self):
        """ResetPixelWtheta(self)"""
        return _stomp.AngularBin_ResetPixelWtheta(self)

    def ResetWeight(self):
        """ResetWeight(self)"""
        return _stomp.AngularBin_ResetWeight(self)

    def ResetCounter(self):
        """ResetCounter(self)"""
        return _stomp.AngularBin_ResetCounter(self)

    def ResetGalGal(self):
        """ResetGalGal(self)"""
        return _stomp.AngularBin_ResetGalGal(self)

    def ResetGalRand(self):
        """ResetGalRand(self)"""
        return _stomp.AngularBin_ResetGalRand(self)

    def ResetRandGal(self):
        """ResetRandGal(self)"""
        return _stomp.AngularBin_ResetRandGal(self)

    def ResetRandRand(self):
        """ResetRandRand(self)"""
        return _stomp.AngularBin_ResetRandRand(self)

    def Resolution(self):
        """Resolution(self) -> uint32_t"""
        return _stomp.AngularBin_Resolution(self)

    def NRegion(self):
        """NRegion(self) -> int16_t"""
        return _stomp.AngularBin_NRegion(self)

    def Theta(self):
        """Theta(self) -> double"""
        return _stomp.AngularBin_Theta(self)

    def ThetaMin(self):
        """ThetaMin(self) -> double"""
        return _stomp.AngularBin_ThetaMin(self)

    def ThetaMax(self):
        """ThetaMax(self) -> double"""
        return _stomp.AngularBin_ThetaMax(self)

    def Sin2ThetaMin(self):
        """Sin2ThetaMin(self) -> double"""
        return _stomp.AngularBin_Sin2ThetaMin(self)

    def Sin2ThetaMax(self):
        """Sin2ThetaMax(self) -> double"""
        return _stomp.AngularBin_Sin2ThetaMax(self)

    def CosThetaMin(self):
        """CosThetaMin(self) -> double"""
        return _stomp.AngularBin_CosThetaMin(self)

    def CosThetaMax(self):
        """CosThetaMax(self) -> double"""
        return _stomp.AngularBin_CosThetaMax(self)

    def Wtheta(self, *args):
        """
        Wtheta(self, int16_t region = -1) -> double
        Wtheta(self) -> double
        """
        return _stomp.AngularBin_Wtheta(self, *args)

    def WthetaError(self, *args):
        """
        WthetaError(self, int16_t region = -1) -> double
        WthetaError(self) -> double
        """
        return _stomp.AngularBin_WthetaError(self, *args)

    def WeightedCrossCorrelation(self, *args):
        """
        WeightedCrossCorrelation(self, int16_t region = -1) -> double
        WeightedCrossCorrelation(self) -> double
        """
        return _stomp.AngularBin_WeightedCrossCorrelation(self, *args)

    def PixelWtheta(self, *args):
        """
        PixelWtheta(self, int16_t region = -1) -> double
        PixelWtheta(self) -> double
        """
        return _stomp.AngularBin_PixelWtheta(self, *args)

    def PixelWeight(self, *args):
        """
        PixelWeight(self, int16_t region = -1) -> double
        PixelWeight(self) -> double
        """
        return _stomp.AngularBin_PixelWeight(self, *args)

    def Weight(self, *args):
        """
        Weight(self, int16_t region = -1) -> double
        Weight(self) -> double
        """
        return _stomp.AngularBin_Weight(self, *args)

    def Counter(self, *args):
        """
        Counter(self, int16_t region = -1) -> uint32_t
        Counter(self) -> uint32_t
        """
        return _stomp.AngularBin_Counter(self, *args)

    def GalGal(self, *args):
        """
        GalGal(self, int16_t region = -1) -> double
        GalGal(self) -> double
        """
        return _stomp.AngularBin_GalGal(self, *args)

    def GalRand(self, *args):
        """
        GalRand(self, int16_t region = -1) -> double
        GalRand(self) -> double
        """
        return _stomp.AngularBin_GalRand(self, *args)

    def RandGal(self, *args):
        """
        RandGal(self, int16_t region = -1) -> double
        RandGal(self) -> double
        """
        return _stomp.AngularBin_RandGal(self, *args)

    def RandRand(self, *args):
        """
        RandRand(self, int16_t region = -1) -> double
        RandRand(self) -> double
        """
        return _stomp.AngularBin_RandRand(self, *args)

    def MeanWtheta(self):
        """MeanWtheta(self) -> double"""
        return _stomp.AngularBin_MeanWtheta(self)

    def MeanWthetaError(self):
        """MeanWthetaError(self) -> double"""
        return _stomp.AngularBin_MeanWthetaError(self)

    def MeanWeightedCrossCorrelation(self):
        """MeanWeightedCrossCorrelation(self) -> double"""
        return _stomp.AngularBin_MeanWeightedCrossCorrelation(self)

    def MeanWeightedCrossCorrelationError(self):
        """MeanWeightedCrossCorrelationError(self) -> double"""
        return _stomp.AngularBin_MeanWeightedCrossCorrelationError(self)

    def MeanWeight(self):
        """MeanWeight(self) -> double"""
        return _stomp.AngularBin_MeanWeight(self)

    def MeanCounter(self):
        """MeanCounter(self) -> double"""
        return _stomp.AngularBin_MeanCounter(self)

    def MeanGalGal(self):
        """MeanGalGal(self) -> double"""
        return _stomp.AngularBin_MeanGalGal(self)

    def MeanGalRand(self):
        """MeanGalRand(self) -> double"""
        return _stomp.AngularBin_MeanGalRand(self)

    def MeanRandGal(self):
        """MeanRandGal(self) -> double"""
        return _stomp.AngularBin_MeanRandGal(self)

    def MeanRandRand(self):
        """MeanRandRand(self) -> double"""
        return _stomp.AngularBin_MeanRandRand(self)

    def ThetaOrder(*args):
        """ThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_ThetaOrder(*args)

    if _newclass:ThetaOrder = staticmethod(ThetaOrder)
    __swig_getmethods__["ThetaOrder"] = lambda x: ThetaOrder
    def SinThetaOrder(*args):
        """SinThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_SinThetaOrder(*args)

    if _newclass:SinThetaOrder = staticmethod(SinThetaOrder)
    __swig_getmethods__["SinThetaOrder"] = lambda x: SinThetaOrder
    def ReverseResolutionOrder(*args):
        """ReverseResolutionOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
        return _stomp.AngularBin_ReverseResolutionOrder(*args)

    if _newclass:ReverseResolutionOrder = staticmethod(ReverseResolutionOrder)
    __swig_getmethods__["ReverseResolutionOrder"] = lambda x: ReverseResolutionOrder
AngularBin_swigregister = _stomp.AngularBin_swigregister
AngularBin_swigregister(AngularBin)
cvar = _stomp.cvar
Pi = cvar.Pi
DegToRad = cvar.DegToRad
RadToDeg = cvar.RadToDeg
StradToDeg = cvar.StradToDeg
EtaOffSet = cvar.EtaOffSet
SurveyCenterRA = cvar.SurveyCenterRA
SurveyCenterDEC = cvar.SurveyCenterDEC
Node = cvar.Node
EtaPole = cvar.EtaPole
Nx0 = cvar.Nx0
Ny0 = cvar.Ny0
HPixLevel = cvar.HPixLevel
MaxPixelLevel = cvar.MaxPixelLevel
HPixResolution = cvar.HPixResolution
MaxPixelResolution = cvar.MaxPixelResolution
ResolutionLevels = cvar.ResolutionLevels
HPixArea = cvar.HPixArea
MaxPixnum = cvar.MaxPixnum
MaxSuperpixnum = cvar.MaxSuperpixnum

def AngularBin_ThetaOrder(*args):
  """AngularBin_ThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_ThetaOrder(*args)

def AngularBin_SinThetaOrder(*args):
  """AngularBin_SinThetaOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_SinThetaOrder(*args)

def AngularBin_ReverseResolutionOrder(*args):
  """AngularBin_ReverseResolutionOrder(AngularBin theta_a, AngularBin theta_b) -> bool"""
  return _stomp.AngularBin_ReverseResolutionOrder(*args)

class RadialBin(AngularBin):
    """Proxy of C++ Stomp::RadialBin class"""
    __swig_setmethods__ = {}
    for _s in [AngularBin]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialBin, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularBin]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialBin, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _stomp.delete_RadialBin
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> RadialBin
        __init__(self, double r_min, double r_max, double redshift) -> RadialBin
        __init__(self, double r_min, double r_max, double redshift, int16_t n_regions) -> RadialBin
        """
        this = _stomp.new_RadialBin(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetRadiusMin(self, *args):
        """SetRadiusMin(self, double r_min)"""
        return _stomp.RadialBin_SetRadiusMin(self, *args)

    def SetRadiusMax(self, *args):
        """SetRadiusMax(self, double r_max)"""
        return _stomp.RadialBin_SetRadiusMax(self, *args)

    def SetRadius(self, *args):
        """SetRadius(self, double r)"""
        return _stomp.RadialBin_SetRadius(self, *args)

    def SetRedshift(self, *args):
        """SetRedshift(self, double z)"""
        return _stomp.RadialBin_SetRedshift(self, *args)

    def WithinRadialBounds(self, *args):
        """WithinRadialBounds(self, double r) -> bool"""
        return _stomp.RadialBin_WithinRadialBounds(self, *args)

    def Radius(self):
        """Radius(self) -> double"""
        return _stomp.RadialBin_Radius(self)

    def RadiusMin(self):
        """RadiusMin(self) -> double"""
        return _stomp.RadialBin_RadiusMin(self)

    def RadiusMax(self):
        """RadiusMax(self) -> double"""
        return _stomp.RadialBin_RadiusMax(self)

    def Redshift(self):
        """Redshift(self) -> double"""
        return _stomp.RadialBin_Redshift(self)

    def RadialOrder(*args):
        """RadialOrder(RadialBin r_a, RadialBin r_b) -> bool"""
        return _stomp.RadialBin_RadialOrder(*args)

    if _newclass:RadialOrder = staticmethod(RadialOrder)
    __swig_getmethods__["RadialOrder"] = lambda x: RadialOrder
    def ReverseResolutionOrder(*args):
        """ReverseResolutionOrder(RadialBin r_a, RadialBin r_b) -> bool"""
        return _stomp.RadialBin_ReverseResolutionOrder(*args)

    if _newclass:ReverseResolutionOrder = staticmethod(ReverseResolutionOrder)
    __swig_getmethods__["ReverseResolutionOrder"] = lambda x: ReverseResolutionOrder
RadialBin_swigregister = _stomp.RadialBin_swigregister
RadialBin_swigregister(RadialBin)

def RadialBin_RadialOrder(*args):
  """RadialBin_RadialOrder(RadialBin r_a, RadialBin r_b) -> bool"""
  return _stomp.RadialBin_RadialOrder(*args)

def RadialBin_ReverseResolutionOrder(*args):
  """RadialBin_ReverseResolutionOrder(RadialBin r_a, RadialBin r_b) -> bool"""
  return _stomp.RadialBin_ReverseResolutionOrder(*args)

class AngularCorrelation(_object):
    """Proxy of C++ Stomp::AngularCorrelation class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularCorrelation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularCorrelation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> AngularCorrelation
        __init__(self, double theta_min, double theta_max, double bins_per_decade, 
            bool assign_resolutions = True) -> AngularCorrelation
        __init__(self, double theta_min, double theta_max, double bins_per_decade) -> AngularCorrelation
        __init__(self, uint32_t n_bins, double theta_min, double theta_max, 
            bool assign_resolutions = True) -> AngularCorrelation
        __init__(self, uint32_t n_bins, double theta_min, double theta_max) -> AngularCorrelation
        """
        this = _stomp.new_AngularCorrelation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AngularCorrelation
    __del__ = lambda self : None;
    def AssignBinResolutions(self, *args):
        """
        AssignBinResolutions(self, double lammin = -70.0, double lammax = 70.0, uint32_t max_resolution = MaxPixelResolution)
        AssignBinResolutions(self, double lammin = -70.0, double lammax = 70.0)
        AssignBinResolutions(self, double lammin = -70.0)
        AssignBinResolutions(self)
        """
        return _stomp.AngularCorrelation_AssignBinResolutions(self, *args)

    def SetMaxResolution(self, *args):
        """
        SetMaxResolution(self, uint32_t resolution, bool manual_break = True)
        SetMaxResolution(self, uint32_t resolution)
        """
        return _stomp.AngularCorrelation_SetMaxResolution(self, *args)

    def SetMinResolution(self, *args):
        """SetMinResolution(self, uint32_t resolution)"""
        return _stomp.AngularCorrelation_SetMinResolution(self, *args)

    def AutoMaxResolution(self, *args):
        """AutoMaxResolution(self, uint32_t n_obj, double area)"""
        return _stomp.AngularCorrelation_AutoMaxResolution(self, *args)

    def InitializeRegions(self, *args):
        """InitializeRegions(self, int16_t n_regions)"""
        return _stomp.AngularCorrelation_InitializeRegions(self, *args)

    def ClearRegions(self):
        """ClearRegions(self)"""
        return _stomp.AngularCorrelation_ClearRegions(self)

    def NRegion(self):
        """NRegion(self) -> int16_t"""
        return _stomp.AngularCorrelation_NRegion(self)

    def FindAutoCorrelation(self, *args):
        """
        FindAutoCorrelation(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations = 1)
        FindAutoCorrelation(self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindAutoCorrelation(self, *args)

    def FindCrossCorrelation(self, *args):
        """
        FindCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations = 1)
        FindCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindCrossCorrelation(self, *args)

    def FindAutoCorrelationWithRegions(self, *args):
        """
        FindAutoCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations = 1, 
            uint16_t n_regions = 0)
        FindAutoCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations = 1)
        FindAutoCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindAutoCorrelationWithRegions(self, *args)

    def FindCrossCorrelationWithRegions(self, *args):
        """
        FindCrossCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations = 1, 
            uint16_t n_regions = 0)
        FindCrossCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations = 1)
        FindCrossCorrelationWithRegions(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindCrossCorrelationWithRegions(self, *args)

    def FindPixelAutoCorrelation(self, *args):
        """
        FindPixelAutoCorrelation(self, Map stomp_map, WAngularVector galaxy)
        FindPixelAutoCorrelation(self, ScalarMap stomp_map)
        """
        return _stomp.AngularCorrelation_FindPixelAutoCorrelation(self, *args)

    def FindPixelCrossCorrelation(self, *args):
        """
        FindPixelCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        FindPixelCrossCorrelation(self, ScalarMap stomp_map_a, ScalarMap stomp_map_b)
        """
        return _stomp.AngularCorrelation_FindPixelCrossCorrelation(self, *args)

    def FindPairAutoCorrelation(self, *args):
        """
        FindPairAutoCorrelation(self, Map stomp_map, WAngularVector galaxy, uint8_t random_iterations = 1)
        FindPairAutoCorrelation(self, Map stomp_map, WAngularVector galaxy)
        """
        return _stomp.AngularCorrelation_FindPairAutoCorrelation(self, *args)

    def FindPairCrossCorrelation(self, *args):
        """
        FindPairCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b, 
            uint8_t random_iterations = 1)
        FindPairCrossCorrelation(self, Map stomp_map, WAngularVector galaxy_a, WAngularVector galaxy_b)
        """
        return _stomp.AngularCorrelation_FindPairCrossCorrelation(self, *args)

    def Write(self, *args):
        """Write(self, string output_file_name) -> bool"""
        return _stomp.AngularCorrelation_Write(self, *args)

    def UseOnlyPixels(self):
        """UseOnlyPixels(self)"""
        return _stomp.AngularCorrelation_UseOnlyPixels(self)

    def UseOnlyPairs(self):
        """UseOnlyPairs(self)"""
        return _stomp.AngularCorrelation_UseOnlyPairs(self)

    def ThetaMin(self, resolution = 1):
        """
        ThetaMin(self, uint32_t resolution = 1) -> double
        ThetaMin(self) -> double
        """
        return _stomp.AngularCorrelation_ThetaMin(self, resolution)

    def ThetaMax(self, resolution = 1):
        """
        ThetaMax(self, uint32_t resolution = 1) -> double
        ThetaMax(self) -> double
        """
        return _stomp.AngularCorrelation_ThetaMax(self, resolution)

    def Sin2ThetaMin(self, resolution = 1):
        """
        Sin2ThetaMin(self, uint32_t resolution = 1) -> double
        Sin2ThetaMin(self) -> double
        """
        return _stomp.AngularCorrelation_Sin2ThetaMin(self, resolution)

    def Sin2ThetaMax(self, resolution = 1):
        """
        Sin2ThetaMax(self, uint32_t resolution = 1) -> double
        Sin2ThetaMax(self) -> double
        """
        return _stomp.AngularCorrelation_Sin2ThetaMax(self, resolution)

    def Begin(self, resolution = 1):
        """
        Begin(self, uint32_t resolution = 1) -> ThetaIterator
        Begin(self) -> ThetaIterator
        """
        return _stomp.AngularCorrelation_Begin(self, resolution)

    def End(self, resolution = 1):
        """
        End(self, uint32_t resolution = 1) -> ThetaIterator
        End(self) -> ThetaIterator
        """
        return _stomp.AngularCorrelation_End(self, resolution)

    def Find(self, *args):
        """Find(self, ThetaIterator begin, ThetaIterator end, double sin2theta) -> ThetaIterator"""
        return _stomp.AngularCorrelation_Find(self, *args)

    def BinIterator(self, bin_idx = 0):
        """
        BinIterator(self, uint8_t bin_idx = 0) -> ThetaIterator
        BinIterator(self) -> ThetaIterator
        """
        return _stomp.AngularCorrelation_BinIterator(self, bin_idx)

    def NBins(self):
        """NBins(self) -> uint32_t"""
        return _stomp.AngularCorrelation_NBins(self)

    def MinResolution(self):
        """MinResolution(self) -> uint32_t"""
        return _stomp.AngularCorrelation_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.AngularCorrelation_MaxResolution(self)

    def Covariance(self, *args):
        """Covariance(self, uint8_t bin_idx_a, uint8_t bin_idx_b) -> double"""
        return _stomp.AngularCorrelation_Covariance(self, *args)

    def WriteCovariance(self, *args):
        """WriteCovariance(self, string output_file_name) -> bool"""
        return _stomp.AngularCorrelation_WriteCovariance(self, *args)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(self):
        """_begin_Bins(self) -> std::vector<(Stomp::AngularBin,std::allocator<(Stomp::AngularBin)>)>::const_iterator"""
        return _stomp.AngularCorrelation__begin_Bins(self)

    def _deref_Bins(self, *args):
        """_deref_Bins(self, std::vector<(Stomp::AngularBin,std::allocator<(Stomp::AngularBin)>)>::const_iterator iter) -> AngularBin"""
        return _stomp.AngularCorrelation__deref_Bins(self, *args)

AngularCorrelation_swigregister = _stomp.AngularCorrelation_swigregister
AngularCorrelation_swigregister(AngularCorrelation)

class Pixel(_object):
    """Proxy of C++ Stomp::Pixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Pixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight = 0.0) -> Pixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> Pixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight = 0.0) -> Pixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> Pixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight = 0.0) -> Pixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> Pixel
        """
        this = _stomp.new_Pixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Pixel
    __del__ = lambda self : None;
    def __lt__(self, *args):
        """__lt__(self, Pixel pix) -> bool"""
        return _stomp.Pixel___lt__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Pixel pix) -> bool"""
        return _stomp.Pixel___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Pixel pix) -> bool"""
        return _stomp.Pixel___ne__(self, *args)

    def SetPixnumFromAng(self, *args):
        """SetPixnumFromAng(self, AngularCoordinate ang)"""
        return _stomp.Pixel_SetPixnumFromAng(self, *args)

    def SetResolution(self, *args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.Pixel_SetResolution(self, *args)

    def SetLevel(self, *args):
        """SetLevel(self, uint8_t level)"""
        return _stomp.Pixel_SetLevel(self, *args)

    def SetPixnumFromXY(self, *args):
        """SetPixnumFromXY(self, uint32_t x, uint32_t y)"""
        return _stomp.Pixel_SetPixnumFromXY(self, *args)

    def SetWeight(self, *args):
        """SetWeight(self, double weight)"""
        return _stomp.Pixel_SetWeight(self, *args)

    def Level(self):
        """Level(self) -> uint8_t"""
        return _stomp.Pixel_Level(self)

    def Resolution(self):
        """Resolution(self) -> uint32_t"""
        return _stomp.Pixel_Resolution(self)

    def PixelX(self):
        """PixelX(self) -> uint32_t"""
        return _stomp.Pixel_PixelX(self)

    def PixelY(self):
        """PixelY(self) -> uint32_t"""
        return _stomp.Pixel_PixelY(self)

    def Weight(self):
        """Weight(self) -> double"""
        return _stomp.Pixel_Weight(self)

    def ReverseWeight(self):
        """ReverseWeight(self)"""
        return _stomp.Pixel_ReverseWeight(self)

    def InvertWeight(self):
        """InvertWeight(self)"""
        return _stomp.Pixel_InvertWeight(self)

    def SetToSuperPix(self, *args):
        """SetToSuperPix(self, uint32_t lo_resolution) -> bool"""
        return _stomp.Pixel_SetToSuperPix(self, *args)

    def SetToLevel(self, *args):
        """SetToLevel(self, uint8_t lo_level) -> bool"""
        return _stomp.Pixel_SetToLevel(self, *args)

    def SubPix(self, *args):
        """
        SubPix(self, uint32_t hi_resolution, PixelVector pix)
        SubPix(self, uint32_t hi_resolution, uint32_t x_min, uint32_t x_max, 
            uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_SubPix(self, *args)

    def FirstCohort(self):
        """FirstCohort(self) -> bool"""
        return _stomp.Pixel_FirstCohort(self)

    def Area(*args):
        """
        Area() -> double
        Area(uint32_t resolution) -> double
        """
        return _stomp.Pixel_Area(*args)

    if _newclass:Area = staticmethod(Area)
    __swig_getmethods__["Area"] = lambda x: Area
    def Superpixnum(self):
        """Superpixnum(self) -> uint32_t"""
        return _stomp.Pixel_Superpixnum(self)

    def HPixnum(self):
        """HPixnum(self) -> uint32_t"""
        return _stomp.Pixel_HPixnum(self)

    def Pixnum(self):
        """Pixnum(self) -> uint32_t"""
        return _stomp.Pixel_Pixnum(self)

    def Contains(self, *args):
        """
        Contains(self, uint32_t pixel_resolution, uint32_t pixel_x, uint32_t pixel_y) -> bool
        Contains(self, Pixel pix) -> bool
        Contains(self, AngularCoordinate ang) -> bool
        """
        return _stomp.Pixel_Contains(self, *args)

    def WithinBounds(self, *args):
        """
        WithinBounds(self, double lon_min, double lon_max, double lat_min, double lat_max, 
            Sphere sphere) -> bool
        """
        return _stomp.Pixel_WithinBounds(self, *args)

    def IntersectsBounds(self, *args):
        """
        IntersectsBounds(self, double lon_min, double lon_max, double lat_min, double lat_max, 
            Sphere sphere) -> bool
        """
        return _stomp.Pixel_IntersectsBounds(self, *args)

    def WithinRadius(self, *args):
        """
        WithinRadius(self, double theta_max, PixelVector pix, bool check_full_pixel = False)
        WithinRadius(self, double theta_max, PixelVector pix)
        """
        return _stomp.Pixel_WithinRadius(self, *args)

    def WithinAnnulus(*args):
        """
        WithinAnnulus(double theta_min, double theta_max, PixelVector pix, 
            bool check_full_pixel = False)
        WithinAnnulus(double theta_min, double theta_max, PixelVector pix)
        WithinAnnulus(AngularBin theta, PixelVector pix, bool check_full_pixel = False)
        WithinAnnulus(AngularBin theta, PixelVector pix)
        WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
            PixelVector pix, bool check_full_pixel = False)
        WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
            PixelVector pix)
        """
        return _stomp.Pixel_WithinAnnulus(*args)

    if _newclass:WithinAnnulus = staticmethod(WithinAnnulus)
    __swig_getmethods__["WithinAnnulus"] = lambda x: WithinAnnulus
    def BoundingRadius(self, *args):
        """
        BoundingRadius(self, double theta_max, PixelVector pix)
        BoundingRadius(self, AngularCoordinate ang, double theta_max, PixelVector pix)
        """
        return _stomp.Pixel_BoundingRadius(self, *args)

    def XYBounds(*args):
        """
        XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max, bool add_buffer = False)
        XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max)
        XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max, bool add_buffer = False)
        XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max)
        XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, uint32_t y_max, 
            bool add_buffer = False)
        XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, uint32_t y_max)
        XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
            IndexVector x_max, uint32_t y_min, uint32_t y_max, 
            bool add_buffer = False)
        XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
            IndexVector x_max, uint32_t y_min, uint32_t y_max)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max, bool add_buffer = False)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            uint32_t x_min, uint32_t x_max, uint32_t y_min, 
            uint32_t y_max)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max, bool add_buffer = False)
        XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
            IndexVector x_min, IndexVector x_max, 
            uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_XYBounds(*args)

    if _newclass:XYBounds = staticmethod(XYBounds)
    __swig_getmethods__["XYBounds"] = lambda x: XYBounds
    def EtaStep(self, *args):
        """EtaStep(self, double theta) -> uint8_t"""
        return _stomp.Pixel_EtaStep(self, *args)

    def NearEdgeDistance(self, *args):
        """NearEdgeDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_NearEdgeDistance(self, *args)

    def FarEdgeDistance(self, *args):
        """FarEdgeDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_FarEdgeDistance(self, *args)

    def NearCornerDistance(self, *args):
        """NearCornerDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_NearCornerDistance(self, *args)

    def FarCornerDistance(self, *args):
        """FarCornerDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.Pixel_FarCornerDistance(self, *args)

    def EdgeDistances(self, *args):
        """EdgeDistances(self, AngularCoordinate ang, double near_edge_distance, double far_edge_distance) -> bool"""
        return _stomp.Pixel_EdgeDistances(self, *args)

    def IsWithinRadius(self, *args):
        """
        IsWithinRadius(self, AngularCoordinate ang, double theta_max, bool check_full_pixel = False) -> bool
        IsWithinRadius(self, AngularCoordinate ang, double theta_max) -> bool
        IsWithinRadius(self, Pixel pix, double theta_max, bool check_full_pixel = False) -> bool
        IsWithinRadius(self, Pixel pix, double theta_max) -> bool
        """
        return _stomp.Pixel_IsWithinRadius(self, *args)

    def IsWithinAnnulus(self, *args):
        """
        IsWithinAnnulus(self, AngularCoordinate ang, double theta_min, double theta_max, 
            bool check_full_pixel = False) -> bool
        IsWithinAnnulus(self, AngularCoordinate ang, double theta_min, double theta_max) -> bool
        IsWithinAnnulus(self, Pixel pix, double theta_min, double theta_max, bool check_full_pixel = False) -> bool
        IsWithinAnnulus(self, Pixel pix, double theta_min, double theta_max) -> bool
        IsWithinAnnulus(self, AngularCoordinate ang, AngularBin theta, bool check_full_pixel = False) -> bool
        IsWithinAnnulus(self, AngularCoordinate ang, AngularBin theta) -> bool
        IsWithinAnnulus(self, Pixel pix, AngularBin theta, bool check_full_pixel = False) -> bool
        IsWithinAnnulus(self, Pixel pix, AngularBin theta) -> bool
        """
        return _stomp.Pixel_IsWithinAnnulus(self, *args)

    def IntersectsAnnulus(self, *args):
        """
        IntersectsAnnulus(self, AngularCoordinate ang, double theta_min, double theta_max) -> int8_t
        IntersectsAnnulus(self, Pixel pix, double theta_min, double theta_max) -> int8_t
        IntersectsAnnulus(self, AngularCoordinate ang, AngularBin theta) -> int8_t
        IntersectsAnnulus(self, Pixel pix, AngularBin theta) -> int8_t
        """
        return _stomp.Pixel_IntersectsAnnulus(self, *args)

    def Stripe(self, *args):
        """
        Stripe(self, uint32_t resolution = HPixResolution) -> uint32_t
        Stripe(self) -> uint32_t
        """
        return _stomp.Pixel_Stripe(self, *args)

    def RA(self):
        """RA(self) -> double"""
        return _stomp.Pixel_RA(self)

    def DEC(self):
        """DEC(self) -> double"""
        return _stomp.Pixel_DEC(self)

    def GalLon(self):
        """GalLon(self) -> double"""
        return _stomp.Pixel_GalLon(self)

    def GalLat(self):
        """GalLat(self) -> double"""
        return _stomp.Pixel_GalLat(self)

    def Ang(self, *args):
        """
        Ang(self, AngularCoordinate ang)
        Ang(self) -> AngularCoordinate
        """
        return _stomp.Pixel_Ang(self, *args)

    def Lambda(self):
        """Lambda(self) -> double"""
        return _stomp.Pixel_Lambda(self)

    def Eta(self):
        """Eta(self) -> double"""
        return _stomp.Pixel_Eta(self)

    def UnitSphereX(self):
        """UnitSphereX(self) -> double"""
        return _stomp.Pixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(self) -> double"""
        return _stomp.Pixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(self) -> double"""
        return _stomp.Pixel_UnitSphereZ(self)

    def LambdaMin(self):
        """LambdaMin(self) -> double"""
        return _stomp.Pixel_LambdaMin(self)

    def LambdaMax(self):
        """LambdaMax(self) -> double"""
        return _stomp.Pixel_LambdaMax(self)

    def EtaMin(self):
        """EtaMin(self) -> double"""
        return _stomp.Pixel_EtaMin(self)

    def EtaMax(self):
        """EtaMax(self) -> double"""
        return _stomp.Pixel_EtaMax(self)

    def EtaMaxContinuous(self):
        """EtaMaxContinuous(self) -> double"""
        return _stomp.Pixel_EtaMaxContinuous(self)

    def SurveyContinuous(self):
        """SurveyContinuous(self) -> bool"""
        return _stomp.Pixel_SurveyContinuous(self)

    def DECMin(self):
        """DECMin(self) -> double"""
        return _stomp.Pixel_DECMin(self)

    def DECMax(self):
        """DECMax(self) -> double"""
        return _stomp.Pixel_DECMax(self)

    def RAMin(self):
        """RAMin(self) -> double"""
        return _stomp.Pixel_RAMin(self)

    def RAMax(self):
        """RAMax(self) -> double"""
        return _stomp.Pixel_RAMax(self)

    def RAMaxContinuous(self):
        """RAMaxContinuous(self) -> double"""
        return _stomp.Pixel_RAMaxContinuous(self)

    def EquatorialContinuous(self):
        """EquatorialContinuous(self) -> bool"""
        return _stomp.Pixel_EquatorialContinuous(self)

    def GalLatMin(self):
        """GalLatMin(self) -> double"""
        return _stomp.Pixel_GalLatMin(self)

    def GalLatMax(self):
        """GalLatMax(self) -> double"""
        return _stomp.Pixel_GalLatMax(self)

    def GalLonMin(self):
        """GalLonMin(self) -> double"""
        return _stomp.Pixel_GalLonMin(self)

    def GalLonMax(self):
        """GalLonMax(self) -> double"""
        return _stomp.Pixel_GalLonMax(self)

    def GalLonMaxContinuous(self):
        """GalLonMaxContinuous(self) -> double"""
        return _stomp.Pixel_GalLonMaxContinuous(self)

    def GalacticContinuous(self):
        """GalacticContinuous(self) -> bool"""
        return _stomp.Pixel_GalacticContinuous(self)

    def ContinuousBounds(self, *args):
        """ContinuousBounds(self, Sphere sphere) -> bool"""
        return _stomp.Pixel_ContinuousBounds(self, *args)

    def UnitSphereX_UL(self):
        """UnitSphereX_UL(self) -> double"""
        return _stomp.Pixel_UnitSphereX_UL(self)

    def UnitSphereY_UL(self):
        """UnitSphereY_UL(self) -> double"""
        return _stomp.Pixel_UnitSphereY_UL(self)

    def UnitSphereZ_UL(self):
        """UnitSphereZ_UL(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_UL(self)

    def UnitSphereX_UR(self):
        """UnitSphereX_UR(self) -> double"""
        return _stomp.Pixel_UnitSphereX_UR(self)

    def UnitSphereY_UR(self):
        """UnitSphereY_UR(self) -> double"""
        return _stomp.Pixel_UnitSphereY_UR(self)

    def UnitSphereZ_UR(self):
        """UnitSphereZ_UR(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_UR(self)

    def UnitSphereX_LL(self):
        """UnitSphereX_LL(self) -> double"""
        return _stomp.Pixel_UnitSphereX_LL(self)

    def UnitSphereY_LL(self):
        """UnitSphereY_LL(self) -> double"""
        return _stomp.Pixel_UnitSphereY_LL(self)

    def UnitSphereZ_LL(self):
        """UnitSphereZ_LL(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_LL(self)

    def UnitSphereX_LR(self):
        """UnitSphereX_LR(self) -> double"""
        return _stomp.Pixel_UnitSphereX_LR(self)

    def UnitSphereY_LR(self):
        """UnitSphereY_LR(self) -> double"""
        return _stomp.Pixel_UnitSphereY_LR(self)

    def UnitSphereZ_LR(self):
        """UnitSphereZ_LR(self) -> double"""
        return _stomp.Pixel_UnitSphereZ_LR(self)

    def Iterate(self, wrap_pixel = True):
        """
        Iterate(self, bool wrap_pixel = True)
        Iterate(self)
        """
        return _stomp.Pixel_Iterate(self, wrap_pixel)

    def PixelX0(self):
        """PixelX0(self) -> uint32_t"""
        return _stomp.Pixel_PixelX0(self)

    def PixelY0(self):
        """PixelY0(self) -> uint32_t"""
        return _stomp.Pixel_PixelY0(self)

    def PixelX1(self):
        """PixelX1(self) -> uint32_t"""
        return _stomp.Pixel_PixelX1(self)

    def PixelY1(self):
        """PixelY1(self) -> uint32_t"""
        return _stomp.Pixel_PixelY1(self)

    def GenerateRandomPoints(self, *args):
        """
        GenerateRandomPoints(self, AngularVector ang, uint32_t n_point = 1)
        GenerateRandomPoints(self, AngularVector ang)
        """
        return _stomp.Pixel_GenerateRandomPoints(self, *args)

    def ResolutionToLevel(*args):
        """ResolutionToLevel(uint32_t resolution) -> uint8_t"""
        return _stomp.Pixel_ResolutionToLevel(*args)

    if _newclass:ResolutionToLevel = staticmethod(ResolutionToLevel)
    __swig_getmethods__["ResolutionToLevel"] = lambda x: ResolutionToLevel
    def LevelToResolution(*args):
        """LevelToResolution(uint8_t level) -> uint32_t"""
        return _stomp.Pixel_LevelToResolution(*args)

    if _newclass:LevelToResolution = staticmethod(LevelToResolution)
    __swig_getmethods__["LevelToResolution"] = lambda x: LevelToResolution
    def Ang2Pix(*args):
        """Ang2Pix(uint32_t resolution, AngularCoordinate ang, uint32_t pixnum)"""
        return _stomp.Pixel_Ang2Pix(*args)

    if _newclass:Ang2Pix = staticmethod(Ang2Pix)
    __swig_getmethods__["Ang2Pix"] = lambda x: Ang2Pix
    def Pix2Ang(*args):
        """Pix2Ang(uint32_t resolution, uint32_t pixnum, AngularCoordinate ang)"""
        return _stomp.Pixel_Pix2Ang(*args)

    if _newclass:Pix2Ang = staticmethod(Pix2Ang)
    __swig_getmethods__["Pix2Ang"] = lambda x: Pix2Ang
    def Pix2HPix(*args):
        """
        Pix2HPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t output_hpixnum, 
            uint32_t output_superpixnum)
        """
        return _stomp.Pixel_Pix2HPix(*args)

    if _newclass:Pix2HPix = staticmethod(Pix2HPix)
    __swig_getmethods__["Pix2HPix"] = lambda x: Pix2HPix
    def HPix2Pix(*args):
        """
        HPix2Pix(uint32_t input_resolution, uint32_t input_hpixnum, 
            uint32_t input_superpixnum, uint32_t output_pixnum)
        """
        return _stomp.Pixel_HPix2Pix(*args)

    if _newclass:HPix2Pix = staticmethod(HPix2Pix)
    __swig_getmethods__["HPix2Pix"] = lambda x: HPix2Pix
    def SuperPix(*args):
        """
        SuperPix(uint32_t lo_resolution) -> uint32_t
        SuperPix(uint32_t hi_resolution, uint32_t hi_pixnum, uint32_t lo_resolution, 
            uint32_t lo_pixnum)
        """
        return _stomp.Pixel_SuperPix(*args)

    if _newclass:SuperPix = staticmethod(SuperPix)
    __swig_getmethods__["SuperPix"] = lambda x: SuperPix
    def SubPixels(*args):
        """
        SubPixels(uint32_t lo_resolution, uint32_t hi_pixnum, uint32_t hi_resolution, 
            uint32_t x_min, uint32_t x_max, 
            uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_SubPixels(*args)

    if _newclass:SubPixels = staticmethod(SubPixels)
    __swig_getmethods__["SubPixels"] = lambda x: SubPixels
    def NextSubPix(*args):
        """
        NextSubPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t sub_pixnum1, 
            uint32_t sub_pixnum2, uint32_t sub_pixnum3, 
            uint32_t sub_pixnum4)
        """
        return _stomp.Pixel_NextSubPix(*args)

    if _newclass:NextSubPix = staticmethod(NextSubPix)
    __swig_getmethods__["NextSubPix"] = lambda x: NextSubPix
    def AreaIndex(*args):
        """
        AreaIndex(uint32_t resolution, double lammin, double lammax, 
            double etamin, double etamax, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, uint32_t y_max)
        """
        return _stomp.Pixel_AreaIndex(*args)

    if _newclass:AreaIndex = staticmethod(AreaIndex)
    __swig_getmethods__["AreaIndex"] = lambda x: AreaIndex
    def PixelBound(*args):
        """
        PixelBound(uint32_t resolution, uint32_t pixnum, double lammin, 
            double lammax, double etamin, double etamax)
        """
        return _stomp.Pixel_PixelBound(*args)

    if _newclass:PixelBound = staticmethod(PixelBound)
    __swig_getmethods__["PixelBound"] = lambda x: PixelBound
    def CohortPix(*args):
        """
        CohortPix(Pixel pix_a, Pixel pix_b, Pixel pix_c)
        CohortPix(uint32_t resolution, uint32_t hpixnum, uint32_t pixnum1, 
            uint32_t pixnum2, uint32_t pixnum3)
        """
        return _stomp.Pixel_CohortPix(*args)

    if _newclass:CohortPix = staticmethod(CohortPix)
    __swig_getmethods__["CohortPix"] = lambda x: CohortPix
    def PixelArea(*args):
        """PixelArea(uint32_t resolution) -> double"""
        return _stomp.Pixel_PixelArea(*args)

    if _newclass:PixelArea = staticmethod(PixelArea)
    __swig_getmethods__["PixelArea"] = lambda x: PixelArea
    def Pix2EtaStep(*args):
        """Pix2EtaStep(uint32_t resolution, uint32_t pixnum, double theta) -> uint8_t"""
        return _stomp.Pixel_Pix2EtaStep(*args)

    if _newclass:Pix2EtaStep = staticmethod(Pix2EtaStep)
    __swig_getmethods__["Pix2EtaStep"] = lambda x: Pix2EtaStep
    def Ang2HPix(*args):
        """
        Ang2HPix(uint32_t resolution, AngularCoordinate ang, uint32_t hpixnum, 
            uint32_t superpixnum)
        """
        return _stomp.Pixel_Ang2HPix(*args)

    if _newclass:Ang2HPix = staticmethod(Ang2HPix)
    __swig_getmethods__["Ang2HPix"] = lambda x: Ang2HPix
    def HPix2Ang(*args):
        """
        HPix2Ang(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            AngularCoordinate ang)
        """
        return _stomp.Pixel_HPix2Ang(*args)

    if _newclass:HPix2Ang = staticmethod(HPix2Ang)
    __swig_getmethods__["HPix2Ang"] = lambda x: HPix2Ang
    def XY2HPix(*args):
        """
        XY2HPix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t hpixnum, 
            uint32_t superpixnum)
        """
        return _stomp.Pixel_XY2HPix(*args)

    if _newclass:XY2HPix = staticmethod(XY2HPix)
    __swig_getmethods__["XY2HPix"] = lambda x: XY2HPix
    def HPix2XY(*args):
        """
        HPix2XY(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            uint32_t x, uint32_t y)
        """
        return _stomp.Pixel_HPix2XY(*args)

    if _newclass:HPix2XY = staticmethod(HPix2XY)
    __swig_getmethods__["HPix2XY"] = lambda x: HPix2XY
    def SuperHPix(*args):
        """
        SuperHPix(uint32_t hi_resolution, uint32_t hi_hpixnum, uint32_t lo_resolution, 
            uint32_t lo_hpixnum)
        """
        return _stomp.Pixel_SuperHPix(*args)

    if _newclass:SuperHPix = staticmethod(SuperHPix)
    __swig_getmethods__["SuperHPix"] = lambda x: SuperHPix
    def NextSubHPix(*args):
        """
        NextSubHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
            uint32_t hpixnum2, uint32_t hpixnum3, 
            uint32_t hpixnum4)
        """
        return _stomp.Pixel_NextSubHPix(*args)

    if _newclass:NextSubHPix = staticmethod(NextSubHPix)
    __swig_getmethods__["NextSubHPix"] = lambda x: NextSubHPix
    def SubHPix(*args):
        """
        SubHPix(uint32_t lo_resolution, uint32_t hi_hpixnum, uint32_t hi_superpixnum, 
            uint32_t hi_resolution, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, 
            uint32_t y_max)
        """
        return _stomp.Pixel_SubHPix(*args)

    if _newclass:SubHPix = staticmethod(SubHPix)
    __swig_getmethods__["SubHPix"] = lambda x: SubHPix
    def HPixelBound(*args):
        """
        HPixelBound(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            double lammin, double lammax, double etamin, 
            double etamax)
        """
        return _stomp.Pixel_HPixelBound(*args)

    if _newclass:HPixelBound = staticmethod(HPixelBound)
    __swig_getmethods__["HPixelBound"] = lambda x: HPixelBound
    def CohortHPix(*args):
        """
        CohortHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
            uint32_t hpixnum2, uint32_t hpixnum3)
        """
        return _stomp.Pixel_CohortHPix(*args)

    if _newclass:CohortHPix = staticmethod(CohortHPix)
    __swig_getmethods__["CohortHPix"] = lambda x: CohortHPix
    def HPixelArea(*args):
        """HPixelArea(uint32_t resolution) -> double"""
        return _stomp.Pixel_HPixelArea(*args)

    if _newclass:HPixelArea = staticmethod(HPixelArea)
    __swig_getmethods__["HPixelArea"] = lambda x: HPixelArea
    def HPix2EtaStep(*args):
        """
        HPix2EtaStep(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
            double theta) -> uint8_t
        """
        return _stomp.Pixel_HPix2EtaStep(*args)

    if _newclass:HPix2EtaStep = staticmethod(HPix2EtaStep)
    __swig_getmethods__["HPix2EtaStep"] = lambda x: HPix2EtaStep
    def XY2Pix(*args):
        """XY2Pix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t pixnum)"""
        return _stomp.Pixel_XY2Pix(*args)

    if _newclass:XY2Pix = staticmethod(XY2Pix)
    __swig_getmethods__["XY2Pix"] = lambda x: XY2Pix
    def Pix2XY(*args):
        """Pix2XY(uint32_t resolution, uint32_t pixnum, uint32_t x, uint32_t y)"""
        return _stomp.Pixel_Pix2XY(*args)

    if _newclass:Pix2XY = staticmethod(Pix2XY)
    __swig_getmethods__["Pix2XY"] = lambda x: Pix2XY
    def LocalOrder(*args):
        """LocalOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_LocalOrder(*args)

    if _newclass:LocalOrder = staticmethod(LocalOrder)
    __swig_getmethods__["LocalOrder"] = lambda x: LocalOrder
    def SuperPixelBasedOrder(*args):
        """SuperPixelBasedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_SuperPixelBasedOrder(*args)

    if _newclass:SuperPixelBasedOrder = staticmethod(SuperPixelBasedOrder)
    __swig_getmethods__["SuperPixelBasedOrder"] = lambda x: SuperPixelBasedOrder
    def SuperPixelOrder(*args):
        """SuperPixelOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_SuperPixelOrder(*args)

    if _newclass:SuperPixelOrder = staticmethod(SuperPixelOrder)
    __swig_getmethods__["SuperPixelOrder"] = lambda x: SuperPixelOrder
    def WeightedOrder(*args):
        """WeightedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightedOrder(*args)

    if _newclass:WeightedOrder = staticmethod(WeightedOrder)
    __swig_getmethods__["WeightedOrder"] = lambda x: WeightedOrder
    def WeightMatch(*args):
        """WeightMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightMatch(*args)

    if _newclass:WeightMatch = staticmethod(WeightMatch)
    __swig_getmethods__["WeightMatch"] = lambda x: WeightMatch
    def WeightedPixelMatch(*args):
        """WeightedPixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_WeightedPixelMatch(*args)

    if _newclass:WeightedPixelMatch = staticmethod(WeightedPixelMatch)
    __swig_getmethods__["WeightedPixelMatch"] = lambda x: WeightedPixelMatch
    def PixelMatch(*args):
        """PixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
        return _stomp.Pixel_PixelMatch(*args)

    if _newclass:PixelMatch = staticmethod(PixelMatch)
    __swig_getmethods__["PixelMatch"] = lambda x: PixelMatch
    def ResolveSuperPixel(*args):
        """
        ResolveSuperPixel(PixelVector pix, bool ignore_weight = False)
        ResolveSuperPixel(PixelVector pix)
        """
        return _stomp.Pixel_ResolveSuperPixel(*args)

    if _newclass:ResolveSuperPixel = staticmethod(ResolveSuperPixel)
    __swig_getmethods__["ResolveSuperPixel"] = lambda x: ResolveSuperPixel
    def ResolvePixel(*args):
        """
        ResolvePixel(PixelVector pix, bool ignore_weight = False)
        ResolvePixel(PixelVector pix)
        """
        return _stomp.Pixel_ResolvePixel(*args)

    if _newclass:ResolvePixel = staticmethod(ResolvePixel)
    __swig_getmethods__["ResolvePixel"] = lambda x: ResolvePixel
    def FindUniquePixels(*args):
        """FindUniquePixels(PixelVector input_pix, PixelVector unique_pix)"""
        return _stomp.Pixel_FindUniquePixels(*args)

    if _newclass:FindUniquePixels = staticmethod(FindUniquePixels)
    __swig_getmethods__["FindUniquePixels"] = lambda x: FindUniquePixels
Pixel_swigregister = _stomp.Pixel_swigregister
Pixel_swigregister(Pixel)

def Pixel_Area(*args):
  """
    Area() -> double
    Pixel_Area(uint32_t resolution) -> double
    """
  return _stomp.Pixel_Area(*args)

def Pixel_WithinAnnulus(*args):
  """
    WithinAnnulus(double theta_min, double theta_max, PixelVector pix, 
        bool check_full_pixel = False)
    WithinAnnulus(double theta_min, double theta_max, PixelVector pix)
    WithinAnnulus(AngularBin theta, PixelVector pix, bool check_full_pixel = False)
    WithinAnnulus(AngularBin theta, PixelVector pix)
    WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
        PixelVector pix, bool check_full_pixel = False)
    Pixel_WithinAnnulus(AngularCoordinate ang, uint32_t resolution, AngularBin theta, 
        PixelVector pix)
    """
  return _stomp.Pixel_WithinAnnulus(*args)

def Pixel_XYBounds(*args):
  """
    XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max, bool add_buffer = False)
    XYBounds(double theta, uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max)
    XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max, bool add_buffer = False)
    XYBounds(double theta, IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max)
    XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, uint32_t y_max, 
        bool add_buffer = False)
    XYBounds(AngularCoordinate ang, double theta, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, uint32_t y_max)
    XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
        IndexVector x_max, uint32_t y_min, uint32_t y_max, 
        bool add_buffer = False)
    XYBounds(AngularCoordinate ang, double theta, IndexVector x_min, 
        IndexVector x_max, uint32_t y_min, uint32_t y_max)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max, bool add_buffer = False)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        uint32_t x_min, uint32_t x_max, uint32_t y_min, 
        uint32_t y_max)
    XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max, bool add_buffer = False)
    Pixel_XYBounds(AngularCoordinate ang, uint32_t resolution, double theta, 
        IndexVector x_min, IndexVector x_max, 
        uint32_t y_min, uint32_t y_max)
    """
  return _stomp.Pixel_XYBounds(*args)

def Pixel_ResolutionToLevel(*args):
  """Pixel_ResolutionToLevel(uint32_t resolution) -> uint8_t"""
  return _stomp.Pixel_ResolutionToLevel(*args)

def Pixel_LevelToResolution(*args):
  """Pixel_LevelToResolution(uint8_t level) -> uint32_t"""
  return _stomp.Pixel_LevelToResolution(*args)

def Pixel_Ang2Pix(*args):
  """Pixel_Ang2Pix(uint32_t resolution, AngularCoordinate ang, uint32_t pixnum)"""
  return _stomp.Pixel_Ang2Pix(*args)

def Pixel_Pix2Ang(*args):
  """Pixel_Pix2Ang(uint32_t resolution, uint32_t pixnum, AngularCoordinate ang)"""
  return _stomp.Pixel_Pix2Ang(*args)

def Pixel_Pix2HPix(*args):
  """
    Pixel_Pix2HPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t output_hpixnum, 
        uint32_t output_superpixnum)
    """
  return _stomp.Pixel_Pix2HPix(*args)

def Pixel_HPix2Pix(*args):
  """
    Pixel_HPix2Pix(uint32_t input_resolution, uint32_t input_hpixnum, 
        uint32_t input_superpixnum, uint32_t output_pixnum)
    """
  return _stomp.Pixel_HPix2Pix(*args)

def Pixel_SuperPix(*args):
  """
    SuperPix(uint32_t lo_resolution) -> uint32_t
    Pixel_SuperPix(uint32_t hi_resolution, uint32_t hi_pixnum, uint32_t lo_resolution, 
        uint32_t lo_pixnum)
    """
  return _stomp.Pixel_SuperPix(*args)

def Pixel_SubPixels(*args):
  """
    Pixel_SubPixels(uint32_t lo_resolution, uint32_t hi_pixnum, uint32_t hi_resolution, 
        uint32_t x_min, uint32_t x_max, 
        uint32_t y_min, uint32_t y_max)
    """
  return _stomp.Pixel_SubPixels(*args)

def Pixel_NextSubPix(*args):
  """
    Pixel_NextSubPix(uint32_t input_resolution, uint32_t input_pixnum, uint32_t sub_pixnum1, 
        uint32_t sub_pixnum2, uint32_t sub_pixnum3, 
        uint32_t sub_pixnum4)
    """
  return _stomp.Pixel_NextSubPix(*args)

def Pixel_AreaIndex(*args):
  """
    Pixel_AreaIndex(uint32_t resolution, double lammin, double lammax, 
        double etamin, double etamax, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, uint32_t y_max)
    """
  return _stomp.Pixel_AreaIndex(*args)

def Pixel_PixelBound(*args):
  """
    Pixel_PixelBound(uint32_t resolution, uint32_t pixnum, double lammin, 
        double lammax, double etamin, double etamax)
    """
  return _stomp.Pixel_PixelBound(*args)

def Pixel_CohortPix(*args):
  """
    CohortPix(Pixel pix_a, Pixel pix_b, Pixel pix_c)
    Pixel_CohortPix(uint32_t resolution, uint32_t hpixnum, uint32_t pixnum1, 
        uint32_t pixnum2, uint32_t pixnum3)
    """
  return _stomp.Pixel_CohortPix(*args)

def Pixel_PixelArea(*args):
  """Pixel_PixelArea(uint32_t resolution) -> double"""
  return _stomp.Pixel_PixelArea(*args)

def Pixel_Pix2EtaStep(*args):
  """Pixel_Pix2EtaStep(uint32_t resolution, uint32_t pixnum, double theta) -> uint8_t"""
  return _stomp.Pixel_Pix2EtaStep(*args)

def Pixel_Ang2HPix(*args):
  """
    Pixel_Ang2HPix(uint32_t resolution, AngularCoordinate ang, uint32_t hpixnum, 
        uint32_t superpixnum)
    """
  return _stomp.Pixel_Ang2HPix(*args)

def Pixel_HPix2Ang(*args):
  """
    Pixel_HPix2Ang(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        AngularCoordinate ang)
    """
  return _stomp.Pixel_HPix2Ang(*args)

def Pixel_XY2HPix(*args):
  """
    Pixel_XY2HPix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t hpixnum, 
        uint32_t superpixnum)
    """
  return _stomp.Pixel_XY2HPix(*args)

def Pixel_HPix2XY(*args):
  """
    Pixel_HPix2XY(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        uint32_t x, uint32_t y)
    """
  return _stomp.Pixel_HPix2XY(*args)

def Pixel_SuperHPix(*args):
  """
    Pixel_SuperHPix(uint32_t hi_resolution, uint32_t hi_hpixnum, uint32_t lo_resolution, 
        uint32_t lo_hpixnum)
    """
  return _stomp.Pixel_SuperHPix(*args)

def Pixel_NextSubHPix(*args):
  """
    Pixel_NextSubHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
        uint32_t hpixnum2, uint32_t hpixnum3, 
        uint32_t hpixnum4)
    """
  return _stomp.Pixel_NextSubHPix(*args)

def Pixel_SubHPix(*args):
  """
    Pixel_SubHPix(uint32_t lo_resolution, uint32_t hi_hpixnum, uint32_t hi_superpixnum, 
        uint32_t hi_resolution, uint32_t x_min, 
        uint32_t x_max, uint32_t y_min, 
        uint32_t y_max)
    """
  return _stomp.Pixel_SubHPix(*args)

def Pixel_HPixelBound(*args):
  """
    Pixel_HPixelBound(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        double lammin, double lammax, double etamin, 
        double etamax)
    """
  return _stomp.Pixel_HPixelBound(*args)

def Pixel_CohortHPix(*args):
  """
    Pixel_CohortHPix(uint32_t resolution, uint32_t hpixnum, uint32_t hpixnum1, 
        uint32_t hpixnum2, uint32_t hpixnum3)
    """
  return _stomp.Pixel_CohortHPix(*args)

def Pixel_HPixelArea(*args):
  """Pixel_HPixelArea(uint32_t resolution) -> double"""
  return _stomp.Pixel_HPixelArea(*args)

def Pixel_HPix2EtaStep(*args):
  """
    Pixel_HPix2EtaStep(uint32_t resolution, uint32_t hpixnum, uint32_t superpixnum, 
        double theta) -> uint8_t
    """
  return _stomp.Pixel_HPix2EtaStep(*args)

def Pixel_XY2Pix(*args):
  """Pixel_XY2Pix(uint32_t resolution, uint32_t x, uint32_t y, uint32_t pixnum)"""
  return _stomp.Pixel_XY2Pix(*args)

def Pixel_Pix2XY(*args):
  """Pixel_Pix2XY(uint32_t resolution, uint32_t pixnum, uint32_t x, uint32_t y)"""
  return _stomp.Pixel_Pix2XY(*args)

def Pixel_LocalOrder(*args):
  """Pixel_LocalOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_LocalOrder(*args)

def Pixel_SuperPixelBasedOrder(*args):
  """Pixel_SuperPixelBasedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_SuperPixelBasedOrder(*args)

def Pixel_SuperPixelOrder(*args):
  """Pixel_SuperPixelOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_SuperPixelOrder(*args)

def Pixel_WeightedOrder(*args):
  """Pixel_WeightedOrder(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightedOrder(*args)

def Pixel_WeightMatch(*args):
  """Pixel_WeightMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightMatch(*args)

def Pixel_WeightedPixelMatch(*args):
  """Pixel_WeightedPixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_WeightedPixelMatch(*args)

def Pixel_PixelMatch(*args):
  """Pixel_PixelMatch(Pixel pix_a, Pixel pix_b) -> bool"""
  return _stomp.Pixel_PixelMatch(*args)

def Pixel_ResolveSuperPixel(*args):
  """
    ResolveSuperPixel(PixelVector pix, bool ignore_weight = False)
    Pixel_ResolveSuperPixel(PixelVector pix)
    """
  return _stomp.Pixel_ResolveSuperPixel(*args)

def Pixel_ResolvePixel(*args):
  """
    ResolvePixel(PixelVector pix, bool ignore_weight = False)
    Pixel_ResolvePixel(PixelVector pix)
    """
  return _stomp.Pixel_ResolvePixel(*args)

def Pixel_FindUniquePixels(*args):
  """Pixel_FindUniquePixels(PixelVector input_pix, PixelVector unique_pix)"""
  return _stomp.Pixel_FindUniquePixels(*args)

class PixelOrdering(_object):
    """Proxy of C++ Stomp::PixelOrdering class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelOrdering, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelOrdering, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, Pixel pix_a, Pixel pix_b) -> int"""
        return _stomp.PixelOrdering___call__(self, *args)

    def __init__(self): 
        """__init__(self) -> PixelOrdering"""
        this = _stomp.new_PixelOrdering()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_PixelOrdering
    __del__ = lambda self : None;
PixelOrdering_swigregister = _stomp.PixelOrdering_swigregister
PixelOrdering_swigregister(PixelOrdering)

class ScalarPixel(Pixel):
    """Proxy of C++ Stomp::ScalarPixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarPixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarPixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight = 0.0, 
            double intensity = 0.0, uint32_t n_points = 0) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight = 0.0, 
            double intensity = 0.0) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum, double weight = 0.0) -> ScalarPixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight = 0.0, 
            double intensity = 0.0, uint32_t n_points = 0) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight = 0.0, 
            double intensity = 0.0) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, double weight = 0.0) -> ScalarPixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight = 0.0, 
            double intensity = 0.0, uint32_t n_points = 0) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight = 0.0, 
            double intensity = 0.0) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, double weight = 0.0) -> ScalarPixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> ScalarPixel
        """
        this = _stomp.new_ScalarPixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_ScalarPixel
    __del__ = lambda self : None;
    def SetIntensity(self, *args):
        """SetIntensity(self, double intensity)"""
        return _stomp.ScalarPixel_SetIntensity(self, *args)

    def SetNPoints(self, *args):
        """SetNPoints(self, uint32_t n_point)"""
        return _stomp.ScalarPixel_SetNPoints(self, *args)

    def Intensity(self):
        """Intensity(self) -> double"""
        return _stomp.ScalarPixel_Intensity(self)

    def NPoints(self):
        """NPoints(self) -> uint32_t"""
        return _stomp.ScalarPixel_NPoints(self)

    def MeanIntensity(self):
        """MeanIntensity(self) -> double"""
        return _stomp.ScalarPixel_MeanIntensity(self)

    def AddToIntensity(self, *args):
        """
        AddToIntensity(self, double intensity, uint32_t n_point = 1)
        AddToIntensity(self, double intensity)
        """
        return _stomp.ScalarPixel_AddToIntensity(self, *args)

    def ScaleIntensity(self, *args):
        """ScaleIntensity(self, double scale_factor)"""
        return _stomp.ScalarPixel_ScaleIntensity(self, *args)

    def NormalizeIntensity(self):
        """NormalizeIntensity(self)"""
        return _stomp.ScalarPixel_NormalizeIntensity(self)

    def ConvertToOverDensity(self, *args):
        """ConvertToOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertToOverDensity(self, *args)

    def ConvertToFractionalOverDensity(self, *args):
        """ConvertToFractionalOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertToFractionalOverDensity(self, *args)

    def ConvertFromOverDensity(self, *args):
        """ConvertFromOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertFromOverDensity(self, *args)

    def ConvertFromFractionalOverDensity(self, *args):
        """ConvertFromFractionalOverDensity(self, double expected_intensity)"""
        return _stomp.ScalarPixel_ConvertFromFractionalOverDensity(self, *args)

    def UnitSphereX(self):
        """UnitSphereX(self) -> double"""
        return _stomp.ScalarPixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(self) -> double"""
        return _stomp.ScalarPixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(self) -> double"""
        return _stomp.ScalarPixel_UnitSphereZ(self)

    def _WithinAnnulus(self, *args):
        """_WithinAnnulus(self, AngularBin theta, ScalarVector pix)"""
        return _stomp.ScalarPixel__WithinAnnulus(self, *args)

    def IsOverDensity(self):
        """IsOverDensity(self) -> bool"""
        return _stomp.ScalarPixel_IsOverDensity(self)

ScalarPixel_swigregister = _stomp.ScalarPixel_swigregister
ScalarPixel_swigregister(ScalarPixel)

class section(_object):
    """Proxy of C++ Stomp::section class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, section, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, section, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min_stripe"] = _stomp.section_min_stripe_set
    __swig_getmethods__["min_stripe"] = _stomp.section_min_stripe_get
    if _newclass:min_stripe = _swig_property(_stomp.section_min_stripe_get, _stomp.section_min_stripe_set)
    __swig_setmethods__["max_stripe"] = _stomp.section_max_stripe_set
    __swig_getmethods__["max_stripe"] = _stomp.section_max_stripe_get
    if _newclass:max_stripe = _swig_property(_stomp.section_max_stripe_get, _stomp.section_max_stripe_set)
    def __init__(self): 
        """__init__(self) -> section"""
        this = _stomp.new_section()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_section
    __del__ = lambda self : None;
section_swigregister = _stomp.section_swigregister
section_swigregister(section)

class RegionBound(_object):
    """Proxy of C++ Stomp::RegionBound class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionBound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegionBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> RegionBound
        __init__(self, GeometricBound bound) -> RegionBound
        """
        this = _stomp.new_RegionBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RegionBound
    __del__ = lambda self : None;
    def SetGeometricBound(self, *args):
        """SetGeometricBound(self, GeometricBound bound)"""
        return _stomp.RegionBound_SetGeometricBound(self, *args)

    def SetNRegion(self, *args):
        """SetNRegion(self, uint16_t n_region)"""
        return _stomp.RegionBound_SetNRegion(self, *args)

    def NRegion(self):
        """NRegion(self) -> uint16_t"""
        return _stomp.RegionBound_NRegion(self)

    def CheckPixel(self, *args):
        """CheckPixel(self, Pixel pix) -> bool"""
        return _stomp.RegionBound_CheckPixel(self, *args)

    def ScorePixel(self, *args):
        """ScorePixel(self, Pixel pix) -> double"""
        return _stomp.RegionBound_ScorePixel(self, *args)

    def AddPixel(self, *args):
        """AddPixel(self, Pixel pix) -> bool"""
        return _stomp.RegionBound_AddPixel(self, *args)

    def RemovePixel(self, *args):
        """RemovePixel(self, Pixel pix) -> bool"""
        return _stomp.RegionBound_RemovePixel(self, *args)

    def ClearPixels(self):
        """ClearPixels(self)"""
        return _stomp.RegionBound_ClearPixels(self)

    def Coverage(self, *args):
        """Coverage(self, PixelVector pix)"""
        return _stomp.RegionBound_Coverage(self, *args)

    def CoveragePixels(self):
        """CoveragePixels(self) -> uint32_t"""
        return _stomp.RegionBound_CoveragePixels(self)

    def CoverageArea(self):
        """CoverageArea(self) -> double"""
        return _stomp.RegionBound_CoverageArea(self)

    def BoundArea(self):
        """BoundArea(self) -> double"""
        return _stomp.RegionBound_BoundArea(self)

RegionBound_swigregister = _stomp.RegionBound_swigregister
RegionBound_swigregister(RegionBound)

class RegionMap(_object):
    """Proxy of C++ Stomp::RegionMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegionMap, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> RegionMap"""
        this = _stomp.new_RegionMap()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_RegionMap
    __del__ = lambda self : None;
    def InitializeRegions(self, *args):
        """
        InitializeRegions(self, BaseMap base_map, uint16_t n_region, uint32_t region_resolution = 0) -> uint16_t
        InitializeRegions(self, BaseMap base_map, uint16_t n_region) -> uint16_t
        InitializeRegions(self, BaseMap base_map, RegionBoundVector region_bounds, 
            uint16_t n_region, uint32_t region_resolution = 0) -> uint16_t
        InitializeRegions(self, BaseMap base_map, RegionBoundVector region_bounds, 
            uint16_t n_region) -> uint16_t
        InitializeRegions(self, BaseMap base_map, BaseMap source_map) -> bool
        """
        return _stomp.RegionMap_InitializeRegions(self, *args)

    def _FindRegionResolution(self, *args):
        """_FindRegionResolution(self, BaseMap base_map, uint16_t n_region, uint32_t region_resolution)"""
        return _stomp.RegionMap__FindRegionResolution(self, *args)

    def _FindUniqueStripes(self, *args):
        """_FindUniqueStripes(self, PixelVector coverage_pix, IndexVector unique_stripes)"""
        return _stomp.RegionMap__FindUniqueStripes(self, *args)

    def _FindSections(self, *args):
        """
        _FindSections(self, IndexVector unique_stripes, double base_map_area, uint16_t n_region, 
            SectionVector sectionVec)
        """
        return _stomp.RegionMap__FindSections(self, *args)

    def _Regionate(self, *args):
        """
        _Regionate(self, PixelVector coverage_pix, SectionVector sectionVec, 
            uint16_t n_region, uint16_t starting_region_index = 0)
        _Regionate(self, PixelVector coverage_pix, SectionVector sectionVec, 
            uint16_t n_region)
        """
        return _stomp.RegionMap__Regionate(self, *args)

    def _VerifyRegionation(self, *args):
        """_VerifyRegionation(self, uint16_t n_region)"""
        return _stomp.RegionMap__VerifyRegionation(self, *args)

    def FindRegion(self, *args):
        """
        FindRegion(self, AngularCoordinate ang) -> int16_t
        FindRegion(self, Pixel pix) -> int16_t
        """
        return _stomp.RegionMap_FindRegion(self, *args)

    def ClearRegions(self):
        """ClearRegions(self)"""
        return _stomp.RegionMap_ClearRegions(self)

    def Region(self, *args):
        """Region(self, uint32_t region_idx) -> int16_t"""
        return _stomp.RegionMap_Region(self, *args)

    def RegionArea(self, *args):
        """
        RegionArea(self, int16_t region, PixelVector pix)
        RegionArea(self, int16_t region) -> double
        """
        return _stomp.RegionMap_RegionArea(self, *args)

    def NRegion(self):
        """NRegion(self) -> uint16_t"""
        return _stomp.RegionMap_NRegion(self)

    def Resolution(self):
        """Resolution(self) -> uint32_t"""
        return _stomp.RegionMap_Resolution(self)

    def Initialized(self):
        """Initialized(self) -> bool"""
        return _stomp.RegionMap_Initialized(self)

    def Begin(self):
        """Begin(self) -> RegionIterator"""
        return _stomp.RegionMap_Begin(self)

    def End(self):
        """End(self) -> RegionIterator"""
        return _stomp.RegionMap_End(self)

RegionMap_swigregister = _stomp.RegionMap_swigregister
RegionMap_swigregister(RegionMap)

class BaseMap(_object):
    """Proxy of C++ Stomp::BaseMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseMap, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> BaseMap"""
        this = _stomp.new_BaseMap()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_BaseMap
    __del__ = lambda self : None;
    def Coverage(self, *args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution, 
            bool calculate_fraction = True)
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.BaseMap_Coverage(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.BaseMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.BaseMap_FindUnmaskedStatus(self, *args)

    def Empty(self):
        """Empty(self) -> bool"""
        return _stomp.BaseMap_Empty(self)

    def Clear(self):
        """Clear(self)"""
        return _stomp.BaseMap_Clear(self)

    def Size(self):
        """Size(self) -> uint32_t"""
        return _stomp.BaseMap_Size(self)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.BaseMap_Area(self)

    def MinResolution(self):
        """MinResolution(self) -> uint32_t"""
        return _stomp.BaseMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.BaseMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(self) -> uint8_t"""
        return _stomp.BaseMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.BaseMap_MaxLevel(self)

    def InitializeRegions(self, *args):
        """
        InitializeRegions(self, uint16_t n_regions, uint32_t region_resolution = 0) -> uint16_t
        InitializeRegions(self, uint16_t n_regions) -> uint16_t
        InitializeRegions(self, RegionBoundVector region_bounds, uint16_t n_region, 
            uint32_t region_resolution = 0) -> uint16_t
        InitializeRegions(self, RegionBoundVector region_bounds, uint16_t n_region) -> uint16_t
        InitializeRegions(self, BaseMap base_map) -> bool
        """
        return _stomp.BaseMap_InitializeRegions(self, *args)

    def FindRegion(self, *args):
        """
        FindRegion(self, AngularCoordinate ang) -> int16_t
        FindRegion(self, Pixel pix) -> int16_t
        """
        return _stomp.BaseMap_FindRegion(self, *args)

    def ClearRegions(self):
        """ClearRegions(self)"""
        return _stomp.BaseMap_ClearRegions(self)

    def Region(self, *args):
        """Region(self, uint32_t region_idx) -> int16_t"""
        return _stomp.BaseMap_Region(self, *args)

    def RegionArea(self, *args):
        """
        RegionArea(self, int16_t region, PixelVector pix)
        RegionArea(self, int16_t region) -> double
        """
        return _stomp.BaseMap_RegionArea(self, *args)

    def NRegion(self):
        """NRegion(self) -> uint16_t"""
        return _stomp.BaseMap_NRegion(self)

    def RegionResolution(self):
        """RegionResolution(self) -> uint32_t"""
        return _stomp.BaseMap_RegionResolution(self)

    def RegionsInitialized(self):
        """RegionsInitialized(self) -> bool"""
        return _stomp.BaseMap_RegionsInitialized(self)

    def RegionBegin(self):
        """RegionBegin(self) -> RegionIterator"""
        return _stomp.BaseMap_RegionBegin(self)

    def RegionEnd(self):
        """RegionEnd(self) -> RegionIterator"""
        return _stomp.BaseMap_RegionEnd(self)

BaseMap_swigregister = _stomp.BaseMap_swigregister
BaseMap_swigregister(BaseMap)

class SubMap(_object):
    """Proxy of C++ Stomp::SubMap class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SubMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, uint32_t superpixnum) -> SubMap"""
        this = _stomp.new_SubMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_SubMap
    __del__ = lambda self : None;
    def AddPixel(self, *args):
        """AddPixel(self, Pixel pix)"""
        return _stomp.SubMap_AddPixel(self, *args)

    def Resolve(self, force_resolve = False):
        """
        Resolve(self, bool force_resolve = False)
        Resolve(self)
        """
        return _stomp.SubMap_Resolve(self, force_resolve)

    def SetMinimumWeight(self, *args):
        """SetMinimumWeight(self, double minimum_weight)"""
        return _stomp.SubMap_SetMinimumWeight(self, *args)

    def SetMaximumWeight(self, *args):
        """SetMaximumWeight(self, double maximum_weight)"""
        return _stomp.SubMap_SetMaximumWeight(self, *args)

    def SetMaximumResolution(self, *args):
        """SetMaximumResolution(self, uint32_t maximum_resolution, bool average_weights)"""
        return _stomp.SubMap_SetMaximumResolution(self, *args)

    def FindLocation(self, *args):
        """FindLocation(self, AngularCoordinate ang, double weight) -> bool"""
        return _stomp.SubMap_FindLocation(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.SubMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.SubMap_FindUnmaskedStatus(self, *args)

    def FindAverageWeight(self, *args):
        """FindAverageWeight(self, Pixel pix) -> double"""
        return _stomp.SubMap_FindAverageWeight(self, *args)

    def FindMatchingPixels(self, *args):
        """
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix, bool use_local_weights = False)
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix)
        """
        return _stomp.SubMap_FindMatchingPixels(self, *args)

    def AverageWeight(self):
        """AverageWeight(self) -> double"""
        return _stomp.SubMap_AverageWeight(self)

    def Soften(self, *args):
        """
        Soften(self, PixelVector softened_pix, uint32_t maximum_resolution, 
            bool average_weights)
        """
        return _stomp.SubMap_Soften(self, *args)

    def Add(self, *args):
        """Add(self, Map stomp_map, bool drop_single) -> bool"""
        return _stomp.SubMap_Add(self, *args)

    def Multiply(self, *args):
        """Multiply(self, Map stomp_map, bool drop_single) -> bool"""
        return _stomp.SubMap_Multiply(self, *args)

    def Exclude(self, *args):
        """Exclude(self, Map stomp_map) -> bool"""
        return _stomp.SubMap_Exclude(self, *args)

    def ScaleWeight(self, *args):
        """ScaleWeight(self, double weight_scale)"""
        return _stomp.SubMap_ScaleWeight(self, *args)

    def AddConstantWeight(self, *args):
        """AddConstantWeight(self, double add_weight)"""
        return _stomp.SubMap_AddConstantWeight(self, *args)

    def InvertWeight(self):
        """InvertWeight(self)"""
        return _stomp.SubMap_InvertWeight(self)

    def Pixels(self, *args):
        """Pixels(self, PixelVector pix)"""
        return _stomp.SubMap_Pixels(self, *args)

    def Clear(self):
        """Clear(self)"""
        return _stomp.SubMap_Clear(self)

    def Superpixnum(self):
        """Superpixnum(self) -> uint32_t"""
        return _stomp.SubMap_Superpixnum(self)

    def Begin(self):
        """Begin(self) -> PixelIterator"""
        return _stomp.SubMap_Begin(self)

    def End(self):
        """End(self) -> PixelIterator"""
        return _stomp.SubMap_End(self)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.SubMap_Area(self)

    def Initialized(self):
        """Initialized(self) -> bool"""
        return _stomp.SubMap_Initialized(self)

    def Unsorted(self):
        """Unsorted(self) -> bool"""
        return _stomp.SubMap_Unsorted(self)

    def SetUnsorted(self):
        """SetUnsorted(self)"""
        return _stomp.SubMap_SetUnsorted(self)

    def MinResolution(self):
        """MinResolution(self) -> uint32_t"""
        return _stomp.SubMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.SubMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(self) -> uint8_t"""
        return _stomp.SubMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.SubMap_MaxLevel(self)

    def MinWeight(self):
        """MinWeight(self) -> double"""
        return _stomp.SubMap_MinWeight(self)

    def MaxWeight(self):
        """MaxWeight(self) -> double"""
        return _stomp.SubMap_MaxWeight(self)

    def LambdaMin(self):
        """LambdaMin(self) -> double"""
        return _stomp.SubMap_LambdaMin(self)

    def LambdaMax(self):
        """LambdaMax(self) -> double"""
        return _stomp.SubMap_LambdaMax(self)

    def EtaMin(self):
        """EtaMin(self) -> double"""
        return _stomp.SubMap_EtaMin(self)

    def EtaMax(self):
        """EtaMax(self) -> double"""
        return _stomp.SubMap_EtaMax(self)

    def ZMin(self):
        """ZMin(self) -> double"""
        return _stomp.SubMap_ZMin(self)

    def ZMax(self):
        """ZMax(self) -> double"""
        return _stomp.SubMap_ZMax(self)

    def Size(self):
        """Size(self) -> uint32_t"""
        return _stomp.SubMap_Size(self)

    def PixelCount(self, *args):
        """PixelCount(self, uint32_t resolution) -> uint32_t"""
        return _stomp.SubMap_PixelCount(self, *args)

SubMap_swigregister = _stomp.SubMap_swigregister
SubMap_swigregister(SubMap)

class Map(BaseMap):
    """Proxy of C++ Stomp::Map class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Map, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Map, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Map
        __init__(self, PixelVector pix, bool force_resolve = True) -> Map
        __init__(self, PixelVector pix) -> Map
        __init__(self, string InputFile, bool hpixel_format = True, bool weighted_map = True) -> Map
        __init__(self, string InputFile, bool hpixel_format = True) -> Map
        __init__(self, string InputFile) -> Map
        __init__(self, GeometricBound bound, double weight = 1.0, uint32_t maximum_resolution = MaxPixelResolution, 
            bool verbose = False) -> Map
        __init__(self, GeometricBound bound, double weight = 1.0, uint32_t maximum_resolution = MaxPixelResolution) -> Map
        __init__(self, GeometricBound bound, double weight = 1.0) -> Map
        __init__(self, GeometricBound bound) -> Map
        """
        this = _stomp.new_Map(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Map
    __del__ = lambda self : None;
    def Initialize(self, *args):
        """
        Initialize(self) -> bool
        Initialize(self, PixelVector pix, bool force_resolve = True) -> bool
        Initialize(self, PixelVector pix) -> bool
        """
        return _stomp.Map_Initialize(self, *args)

    def AddPixel(self, *args):
        """AddPixel(self, Pixel pix)"""
        return _stomp.Map_AddPixel(self, *args)

    def FindLocation(self, *args):
        """FindLocation(self, AngularCoordinate ang, double weight) -> bool"""
        return _stomp.Map_FindLocation(self, *args)

    def FindLocationWeight(self, *args):
        """FindLocationWeight(self, AngularCoordinate ang) -> double"""
        return _stomp.Map_FindLocationWeight(self, *args)

    def FindUnmaskedStatus(self, *args):
        """
        FindUnmaskedStatus(self, Pixel pix) -> int8_t
        FindUnmaskedStatus(self, PixelVector pix, std::vector<(int8_t,std::allocator<(int8_t)>)> unmasked_status)
        FindUnmaskedStatus(self, Map stomp_map) -> int8_t
        """
        return _stomp.Map_FindUnmaskedStatus(self, *args)

    def FindAverageWeight(self, *args):
        """
        FindAverageWeight(self, Pixel pix) -> double
        FindAverageWeight(self, PixelVector pix, DoubleVector average_weight)
        FindAverageWeight(self, PixelVector pix)
        """
        return _stomp.Map_FindAverageWeight(self, *args)

    def AverageWeight(self):
        """AverageWeight(self) -> double"""
        return _stomp.Map_AverageWeight(self)

    def FindMatchingPixels(self, *args):
        """
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix, bool use_local_weights = False)
        FindMatchingPixels(self, Pixel pix, PixelVector match_pix)
        FindMatchingPixels(self, PixelVector pix, PixelVector match_pix, bool use_local_weights = False)
        FindMatchingPixels(self, PixelVector pix, PixelVector match_pix)
        """
        return _stomp.Map_FindMatchingPixels(self, *args)

    def Coverage(self, *args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution, 
            bool calculate_fraction = True)
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.Map_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.Map_Covering(self, *args)

    def Soften(self, *args):
        """
        Soften(self, Map stomp_map, uint32_t maximum_resolution, bool average_weights = False)
        Soften(self, Map stomp_map, uint32_t maximum_resolution)
        Soften(self, uint32_t maximum_resolution, bool average_weights = False)
        Soften(self, uint32_t maximum_resolution)
        """
        return _stomp.Map_Soften(self, *args)

    def SetMinimumWeight(self, *args):
        """SetMinimumWeight(self, double min_weight)"""
        return _stomp.Map_SetMinimumWeight(self, *args)

    def SetMaximumWeight(self, *args):
        """SetMaximumWeight(self, double max_weight)"""
        return _stomp.Map_SetMaximumWeight(self, *args)

    def RegionOnlyMap(self, *args):
        """RegionOnlyMap(self, int16_t region_index, Map stomp_map) -> bool"""
        return _stomp.Map_RegionOnlyMap(self, *args)

    def RegionExcludedMap(self, *args):
        """RegionExcludedMap(self, int16_t region_index, Map stomp_map) -> bool"""
        return _stomp.Map_RegionExcludedMap(self, *args)

    def GenerateSingleRandomPoint(self, *args):
        """
        GenerateSingleRandomPoint(self, WeightedAngularCoordinate ang, bool return_local_weight = False, 
            bool use_weighted_sampling = False)
        GenerateSingleRandomPoint(self, WeightedAngularCoordinate ang, bool return_local_weight = False)
        GenerateSingleRandomPoint(self, WeightedAngularCoordinate ang)
        """
        return _stomp.Map_GenerateSingleRandomPoint(self, *args)

    def GenerateRandomPoints(self, *args):
        """
        GenerateRandomPoints(self, AngularVector ang, uint32_t n_point = 1, bool use_weighted_sampling = False)
        GenerateRandomPoints(self, AngularVector ang, uint32_t n_point = 1)
        GenerateRandomPoints(self, AngularVector ang)
        GenerateRandomPoints(self, WAngularVector ang, WAngularVector input_ang, bool use_weighted_sampling = False)
        GenerateRandomPoints(self, WAngularVector ang, WAngularVector input_ang)
        GenerateRandomPoints(self, WAngularVector ang, DoubleVector weights, bool use_weighted_sampling = False)
        GenerateRandomPoints(self, WAngularVector ang, DoubleVector weights)
        GenerateRandomPoints(self, CosmoVector ang, CosmoVector input_ang, bool use_weighted_sampling = False)
        GenerateRandomPoints(self, CosmoVector ang, CosmoVector input_ang)
        GenerateRandomPoints(self, uint32_t n_point, Sphere systemid, bool use_weighted_sampling = False) -> PyObject
        GenerateRandomPoints(self, uint32_t n_point, Sphere systemid) -> PyObject
        GenerateRandomPoints(self, uint32_t n_point, string system, bool use_weighted_sampling = False) -> PyObject
        GenerateRandomPoints(self, uint32_t n_point, string system) -> PyObject
        """
        return _stomp.Map_GenerateRandomPoints(self, *args)

    def GenerateRandomEq(self, *args):
        """
        GenerateRandomEq(self, uint32_t n_point, bool use_weighted_sampling = False) -> PyObject
        GenerateRandomEq(self, uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomEq(self, *args)

    def GenerateRandomSurvey(self, *args):
        """
        GenerateRandomSurvey(self, uint32_t n_point, bool use_weighted_sampling = False) -> PyObject
        GenerateRandomSurvey(self, uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomSurvey(self, *args)

    def GenerateRandomGal(self, *args):
        """
        GenerateRandomGal(self, uint32_t n_point, bool use_weighted_sampling = False) -> PyObject
        GenerateRandomGal(self, uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomGal(self, *args)

    def GenerateRandomQuadrantPointsSurvey(self, *args):
        """
        GenerateRandomQuadrantPointsSurvey(self, double lambda_center, double eta_center, double R, 
            uint32_t n_point, int quadrant = -1) -> PyObject
        GenerateRandomQuadrantPointsSurvey(self, double lambda_center, double eta_center, double R, 
            uint32_t n_point) -> PyObject
        """
        return _stomp.Map_GenerateRandomQuadrantPointsSurvey(self, *args)

    __swig_setmethods__["INSIDE_MAP"] = _stomp.Map_INSIDE_MAP_set
    __swig_getmethods__["INSIDE_MAP"] = _stomp.Map_INSIDE_MAP_get
    if _newclass:INSIDE_MAP = _swig_property(_stomp.Map_INSIDE_MAP_get, _stomp.Map_INSIDE_MAP_set)
    __swig_setmethods__["FIRST_QUADRANT_OK"] = _stomp.Map_FIRST_QUADRANT_OK_set
    __swig_getmethods__["FIRST_QUADRANT_OK"] = _stomp.Map_FIRST_QUADRANT_OK_get
    if _newclass:FIRST_QUADRANT_OK = _swig_property(_stomp.Map_FIRST_QUADRANT_OK_get, _stomp.Map_FIRST_QUADRANT_OK_set)
    __swig_setmethods__["SECOND_QUADRANT_OK"] = _stomp.Map_SECOND_QUADRANT_OK_set
    __swig_getmethods__["SECOND_QUADRANT_OK"] = _stomp.Map_SECOND_QUADRANT_OK_get
    if _newclass:SECOND_QUADRANT_OK = _swig_property(_stomp.Map_SECOND_QUADRANT_OK_get, _stomp.Map_SECOND_QUADRANT_OK_set)
    __swig_setmethods__["THIRD_QUADRANT_OK"] = _stomp.Map_THIRD_QUADRANT_OK_set
    __swig_getmethods__["THIRD_QUADRANT_OK"] = _stomp.Map_THIRD_QUADRANT_OK_get
    if _newclass:THIRD_QUADRANT_OK = _swig_property(_stomp.Map_THIRD_QUADRANT_OK_get, _stomp.Map_THIRD_QUADRANT_OK_set)
    __swig_setmethods__["FOURTH_QUADRANT_OK"] = _stomp.Map_FOURTH_QUADRANT_OK_set
    __swig_getmethods__["FOURTH_QUADRANT_OK"] = _stomp.Map_FOURTH_QUADRANT_OK_get
    if _newclass:FOURTH_QUADRANT_OK = _swig_property(_stomp.Map_FOURTH_QUADRANT_OK_get, _stomp.Map_FOURTH_QUADRANT_OK_set)
    def QuadrantsContainedMC(self, *args):
        """QuadrantsContainedMC(self, AngularCoordinate ang, double radius, Sphere coord_system) -> int"""
        return _stomp.Map_QuadrantsContainedMC(self, *args)

    def QuadrantContainedMC(self, *args):
        """QuadrantContainedMC(self, AngularCoordinate ang, double radius, int quadrant) -> bool"""
        return _stomp.Map_QuadrantContainedMC(self, *args)

    def Contains(self, *args):
        """
        Contains(self, AngularCoordinate ang) -> bool
        Contains(self, Pixel pix) -> bool
        Contains(self, Map stomp_map) -> bool
        Contains(self, PyObject x1obj, PyObject x2obj, string system, PyObject radobj = None) -> PyObject
        Contains(self, PyObject x1obj, PyObject x2obj, string system) -> PyObject
        Contains(self, GeometricBound bound, double area_resolution = 0.5, 
            double precision = 0.01) -> bool
        Contains(self, GeometricBound bound, double area_resolution = 0.5) -> bool
        Contains(self, GeometricBound bound) -> bool
        """
        return _stomp.Map_Contains(self, *args)

    def FindUnmaskedFraction(self, *args):
        """
        FindUnmaskedFraction(self, Pixel pix) -> double
        FindUnmaskedFraction(self, PixelVector pix, DoubleVector unmasked_fraction)
        FindUnmaskedFraction(self, PixelVector pix)
        FindUnmaskedFraction(self, Map stomp_map) -> double
        FindUnmaskedFraction(self, GeometricBound bound, double area_resolution = 0.5, 
            double precision = 0.01) -> double
        FindUnmaskedFraction(self, GeometricBound bound, double area_resolution = 0.5) -> double
        FindUnmaskedFraction(self, GeometricBound bound) -> double
        """
        return _stomp.Map_FindUnmaskedFraction(self, *args)

    def Write(self, *args):
        """
        Write(self, string OutputFile, bool hpixel_format = True, bool weighted_map = True) -> bool
        Write(self, string OutputFile, bool hpixel_format = True) -> bool
        Write(self, string OutputFile) -> bool
        """
        return _stomp.Map_Write(self, *args)

    def Read(self, *args):
        """
        Read(self, string InputFile, bool hpixel_format = True, bool weighted_map = True) -> bool
        Read(self, string InputFile, bool hpixel_format = True) -> bool
        Read(self, string InputFile) -> bool
        """
        return _stomp.Map_Read(self, *args)

    def PixelizeBound(self, *args):
        """
        PixelizeBound(self, GeometricBound bound, double weight = 1.0, uint32_t maximum_resolution = MaxPixelResolution) -> bool
        PixelizeBound(self, GeometricBound bound, double weight = 1.0) -> bool
        PixelizeBound(self, GeometricBound bound) -> bool
        """
        return _stomp.Map_PixelizeBound(self, *args)

    def _FindStartingResolutionLevel(self, *args):
        """_FindStartingResolutionLevel(self, double bound_area) -> uint8_t"""
        return _stomp.Map__FindStartingResolutionLevel(self, *args)

    def _FindXYBounds(self, *args):
        """
        _FindXYBounds(self, uint8_t resolution_level, GeometricBound bound, uint32_t x_min, 
            uint32_t x_max, uint32_t y_min, 
            uint32_t y_max) -> bool
        """
        return _stomp.Map__FindXYBounds(self, *args)

    def ScaleWeight(self, *args):
        """ScaleWeight(self, double weight_scale)"""
        return _stomp.Map_ScaleWeight(self, *args)

    def AddConstantWeight(self, *args):
        """AddConstantWeight(self, double add_weight)"""
        return _stomp.Map_AddConstantWeight(self, *args)

    def InvertWeight(self):
        """InvertWeight(self)"""
        return _stomp.Map_InvertWeight(self)

    def IngestMap(self, *args):
        """
        IngestMap(self, PixelVector pix, bool destroy_copy = True) -> bool
        IngestMap(self, PixelVector pix) -> bool
        IngestMap(self, Map stomp_map, bool destroy_copy = True) -> bool
        IngestMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_IngestMap(self, *args)

    def IntersectMap(self, *args):
        """
        IntersectMap(self, PixelVector pix) -> bool
        IntersectMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_IntersectMap(self, *args)

    def ExcludeMap(self, *args):
        """
        ExcludeMap(self, PixelVector pix, bool destroy_copy = True) -> bool
        ExcludeMap(self, PixelVector pix) -> bool
        ExcludeMap(self, Map stomp_map, bool destroy_copy = True) -> bool
        ExcludeMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_ExcludeMap(self, *args)

    def AddMap(self, *args):
        """
        AddMap(self, PixelVector pix, bool drop_single = True) -> bool
        AddMap(self, PixelVector pix) -> bool
        AddMap(self, Map stomp_map, bool drop_single = True) -> bool
        AddMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_AddMap(self, *args)

    def MultiplyMap(self, *args):
        """
        MultiplyMap(self, PixelVector pix, bool drop_single = True) -> bool
        MultiplyMap(self, PixelVector pix) -> bool
        MultiplyMap(self, Map stomp_map, bool drop_single = True) -> bool
        MultiplyMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_MultiplyMap(self, *args)

    def ImprintMap(self, *args):
        """
        ImprintMap(self, PixelVector pix) -> bool
        ImprintMap(self, Map stomp_map) -> bool
        """
        return _stomp.Map_ImprintMap(self, *args)

    def Pixels(self, *args):
        """
        Pixels(self, PixelVector pix, uint32_t superpixnum = MaxSuperpixnum)
        Pixels(self, PixelVector pix)
        """
        return _stomp.Map_Pixels(self, *args)

    def Begin(self):
        """Begin(self) -> MapIterator"""
        return _stomp.Map_Begin(self)

    def End(self):
        """End(self) -> MapIterator"""
        return _stomp.Map_End(self)

    def Iterate(self, *args):
        """Iterate(self, MapIterator iter)"""
        return _stomp.Map_Iterate(self, *args)

    def Clear(self, *args):
        """
        Clear(self)
        Clear(self, uint32_t superpixnum)
        """
        return _stomp.Map_Clear(self, *args)

    def ContainsSuperpixel(self, *args):
        """ContainsSuperpixel(self, uint32_t superpixnum) -> bool"""
        return _stomp.Map_ContainsSuperpixel(self, *args)

    def Area(self, *args):
        """
        Area(self) -> double
        Area(self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_Area(self, *args)

    def MinResolution(self, *args):
        """
        MinResolution(self) -> uint32_t
        MinResolution(self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_MinResolution(self, *args)

    def MaxResolution(self, *args):
        """
        MaxResolution(self) -> uint32_t
        MaxResolution(self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_MaxResolution(self, *args)

    def MinLevel(self, *args):
        """
        MinLevel(self) -> uint8_t
        MinLevel(self, uint32_t superpixnum) -> uint8_t
        """
        return _stomp.Map_MinLevel(self, *args)

    def MaxLevel(self, *args):
        """
        MaxLevel(self) -> uint8_t
        MaxLevel(self, uint32_t superpixnum) -> uint8_t
        """
        return _stomp.Map_MaxLevel(self, *args)

    def MinWeight(self, *args):
        """
        MinWeight(self) -> double
        MinWeight(self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_MinWeight(self, *args)

    def MaxWeight(self, *args):
        """
        MaxWeight(self) -> double
        MaxWeight(self, uint32_t superpixnum) -> double
        """
        return _stomp.Map_MaxWeight(self, *args)

    def Size(self, *args):
        """
        Size(self) -> uint32_t
        Size(self, uint32_t superpixnum) -> uint32_t
        """
        return _stomp.Map_Size(self, *args)

    def Empty(self):
        """Empty(self) -> bool"""
        return _stomp.Map_Empty(self)

    def PixelCount(self, *args):
        """PixelCount(self, uint32_t resolution) -> uint32_t"""
        return _stomp.Map_PixelCount(self, *args)

Map_swigregister = _stomp.Map_swigregister
Map_swigregister(Map)

class ScalarMap(BaseMap):
    """Proxy of C++ Stomp::ScalarMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarMap, name)
    __repr__ = _swig_repr
    ScalarField = _stomp.ScalarMap_ScalarField
    DensityField = _stomp.ScalarMap_DensityField
    SampledField = _stomp.ScalarMap_SampledField
    def __init__(self, *args): 
        """
        __init__(self) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution, ScalarMapType scalar_map_type = ScalarField, 
            double min_unmasked_fraction = 0.0000001, 
            bool use_map_weight_as_intensity = False) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution, ScalarMapType scalar_map_type = ScalarField, 
            double min_unmasked_fraction = 0.0000001) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution, ScalarMapType scalar_map_type = ScalarField) -> ScalarMap
        __init__(self, Map stomp_map, uint32_t resolution) -> ScalarMap
        __init__(self, ScalarMap scalar_map, uint32_t resolution, double min_unmasked_fraction = 0.0000001) -> ScalarMap
        __init__(self, ScalarMap scalar_map, uint32_t resolution) -> ScalarMap
        __init__(self, ScalarVector pix, ScalarMapType scalar_map_type = ScalarField, 
            double min_unmasked_fraction = 0.0000001) -> ScalarMap
        __init__(self, ScalarVector pix, ScalarMapType scalar_map_type = ScalarField) -> ScalarMap
        __init__(self, ScalarVector pix) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution, ScalarMapType scalar_map_type = ScalarField, 
            double min_unmasked_fraction = 0.0000001, 
            double theta_min = -1.0) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution, ScalarMapType scalar_map_type = ScalarField, 
            double min_unmasked_fraction = 0.0000001) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution, ScalarMapType scalar_map_type = ScalarField) -> ScalarMap
        __init__(self, Map stomp_map, AngularCoordinate center, double theta_max, 
            uint32_t resolution) -> ScalarMap
        """
        this = _stomp.new_ScalarMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_ScalarMap
    __del__ = lambda self : None;
    def Read(self, *args):
        """
        Read(self, string InputFile, ScalarMapType scalar_map_type = ScalarField, 
            double min_unmasked_fraction = 0.0000001) -> bool
        Read(self, string InputFile, ScalarMapType scalar_map_type = ScalarField) -> bool
        Read(self, string InputFile) -> bool
        """
        return _stomp.ScalarMap_Read(self, *args)

    def Write(self, *args):
        """Write(self, string OutputFile) -> bool"""
        return _stomp.ScalarMap_Write(self, *args)

    def SetResolution(self, *args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.ScalarMap_SetResolution(self, *args)

    def InitializeFromMap(self, *args):
        """
        InitializeFromMap(self, Map stomp_map, uint32_t resolution = 0, bool use_map_weight_as_intensity = False)
        InitializeFromMap(self, Map stomp_map, uint32_t resolution = 0)
        InitializeFromMap(self, Map stomp_map)
        """
        return _stomp.ScalarMap_InitializeFromMap(self, *args)

    def InitializeFromScalarMap(self, *args):
        """
        InitializeFromScalarMap(self, ScalarMap scalar_map, uint32_t resolution = 0)
        InitializeFromScalarMap(self, ScalarMap scalar_map)
        """
        return _stomp.ScalarMap_InitializeFromScalarMap(self, *args)

    def InitializeFromScalarPixels(self, *args):
        """
        InitializeFromScalarPixels(self, ScalarVector pix, ScalarMapType map_type = ScalarField)
        InitializeFromScalarPixels(self, ScalarVector pix)
        """
        return _stomp.ScalarMap_InitializeFromScalarPixels(self, *args)

    def AddToMap(self, *args):
        """
        AddToMap(self, AngularCoordinate ang, double object_weight = 1.0) -> bool
        AddToMap(self, AngularCoordinate ang) -> bool
        AddToMap(self, WeightedAngularCoordinate ang) -> bool
        AddToMap(self, Pixel pix) -> bool
        """
        return _stomp.ScalarMap_AddToMap(self, *args)

    def Coverage(self, *args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution, 
            bool calculate_fraction = True)
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.ScalarMap_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.ScalarMap_Covering(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.ScalarMap_FindUnmaskedStatus(self, *args)

    def Resample(self, *args):
        """Resample(self, ScalarPixel pix)"""
        return _stomp.ScalarMap_Resample(self, *args)

    def FindIntensity(self, *args):
        """FindIntensity(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindIntensity(self, *args)

    def FindDensity(self, *args):
        """FindDensity(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindDensity(self, *args)

    def FindPointDensity(self, *args):
        """FindPointDensity(self, Pixel pix) -> double"""
        return _stomp.ScalarMap_FindPointDensity(self, *args)

    def FindLocalArea(self, *args):
        """
        FindLocalArea(self, AngularCoordinate ang, double theta_max, double theta_min = -1.0) -> double
        FindLocalArea(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalArea(self, *args)

    def FindLocalIntensity(self, *args):
        """
        FindLocalIntensity(self, AngularCoordinate ang, double theta_max, double theta_min = -1.0) -> double
        FindLocalIntensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalIntensity(self, *args)

    def FindLocalAverageIntensity(self, *args):
        """
        FindLocalAverageIntensity(self, AngularCoordinate ang, double theta_max, double theta_min = -1.0) -> double
        FindLocalAverageIntensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalAverageIntensity(self, *args)

    def FindLocalDensity(self, *args):
        """
        FindLocalDensity(self, AngularCoordinate ang, double theta_max, double theta_min = -1.0) -> double
        FindLocalDensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalDensity(self, *args)

    def FindLocalPointDensity(self, *args):
        """
        FindLocalPointDensity(self, AngularCoordinate ang, double theta_max, double theta_min = 0.0) -> double
        FindLocalPointDensity(self, AngularCoordinate ang, double theta_max) -> double
        """
        return _stomp.ScalarMap_FindLocalPointDensity(self, *args)

    def CalculateMeanIntensity(self):
        """CalculateMeanIntensity(self)"""
        return _stomp.ScalarMap_CalculateMeanIntensity(self)

    def ConvertToOverDensity(self):
        """ConvertToOverDensity(self)"""
        return _stomp.ScalarMap_ConvertToOverDensity(self)

    def ConvertFromOverDensity(self):
        """ConvertFromOverDensity(self)"""
        return _stomp.ScalarMap_ConvertFromOverDensity(self)

    def UseLocalMeanIntensity(self, *args):
        """UseLocalMeanIntensity(self, bool use_local_mean) -> bool"""
        return _stomp.ScalarMap_UseLocalMeanIntensity(self, *args)

    def UsingLocalMeanIntensity(self):
        """UsingLocalMeanIntensity(self) -> bool"""
        return _stomp.ScalarMap_UsingLocalMeanIntensity(self)

    def ImprintMap(self, *args):
        """
        ImprintMap(self, Map stomp_map, bool use_mean_local_intensity = False) -> bool
        ImprintMap(self, Map stomp_map) -> bool
        """
        return _stomp.ScalarMap_ImprintMap(self, *args)

    def AutoCorrelate(self, *args):
        """
        AutoCorrelate(self, ThetaIterator theta_iter)
        AutoCorrelate(self, AngularCorrelation wtheta)
        """
        return _stomp.ScalarMap_AutoCorrelate(self, *args)

    def AutoCorrelateWithRegions(self, *args):
        """
        AutoCorrelateWithRegions(self, AngularCorrelation wtheta)
        AutoCorrelateWithRegions(self, ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_AutoCorrelateWithRegions(self, *args)

    def CrossCorrelate(self, *args):
        """
        CrossCorrelate(self, ScalarMap scalar_map, AngularCorrelation wtheta)
        CrossCorrelate(self, ScalarMap scalar_map, ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_CrossCorrelate(self, *args)

    def CrossCorrelateWithRegions(self, *args):
        """
        CrossCorrelateWithRegions(self, ScalarMap scalar_map, AngularCorrelation wtheta)
        CrossCorrelateWithRegions(self, ScalarMap scalar_map, ThetaIterator theta_iter)
        """
        return _stomp.ScalarMap_CrossCorrelateWithRegions(self, *args)

    def Variance(self):
        """Variance(self) -> double"""
        return _stomp.ScalarMap_Variance(self)

    def Covariance(self, *args):
        """Covariance(self, ScalarMap scalar_map) -> double"""
        return _stomp.ScalarMap_Covariance(self, *args)

    def VarianceWithErrors(self, *args):
        """VarianceWithErrors(self, double variance, double variance_error)"""
        return _stomp.ScalarMap_VarianceWithErrors(self, *args)

    def CovarianceWithErrors(self, *args):
        """CovarianceWithErrors(self, ScalarMap scalar_map, double covariance, double covariance_error)"""
        return _stomp.ScalarMap_CovarianceWithErrors(self, *args)

    def Resolution(self):
        """Resolution(self) -> uint32_t"""
        return _stomp.ScalarMap_Resolution(self)

    def Intensity(self):
        """Intensity(self) -> double"""
        return _stomp.ScalarMap_Intensity(self)

    def NPoints(self):
        """NPoints(self) -> int"""
        return _stomp.ScalarMap_NPoints(self)

    def Density(self):
        """Density(self) -> double"""
        return _stomp.ScalarMap_Density(self)

    def PointDensity(self):
        """PointDensity(self) -> double"""
        return _stomp.ScalarMap_PointDensity(self)

    def ScalarPixels(self, *args):
        """ScalarPixels(self, ScalarVector s_pix)"""
        return _stomp.ScalarMap_ScalarPixels(self, *args)

    def Begin(self):
        """Begin(self) -> ScalarIterator"""
        return _stomp.ScalarMap_Begin(self)

    def End(self):
        """End(self) -> ScalarIterator"""
        return _stomp.ScalarMap_End(self)

    def MeanIntensity(self):
        """MeanIntensity(self) -> double"""
        return _stomp.ScalarMap_MeanIntensity(self)

    def IsOverDensityMap(self):
        """IsOverDensityMap(self) -> bool"""
        return _stomp.ScalarMap_IsOverDensityMap(self)

    def MapType(self):
        """MapType(self) -> ScalarMapType"""
        return _stomp.ScalarMap_MapType(self)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.ScalarMap_Area(self)

    def Size(self):
        """Size(self) -> uint32_t"""
        return _stomp.ScalarMap_Size(self)

    def MinResolution(self):
        """MinResolution(self) -> uint32_t"""
        return _stomp.ScalarMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.ScalarMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(self) -> uint8_t"""
        return _stomp.ScalarMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.ScalarMap_MaxLevel(self)

    def Empty(self):
        """Empty(self) -> bool"""
        return _stomp.ScalarMap_Empty(self)

    def Clear(self):
        """Clear(self)"""
        return _stomp.ScalarMap_Clear(self)

ScalarMap_swigregister = _stomp.ScalarMap_swigregister
ScalarMap_swigregister(ScalarMap)

class GeometricBound(_object):
    """Proxy of C++ Stomp::GeometricBound class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricBound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricBound, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> GeometricBound"""
        this = _stomp.new_GeometricBound()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_GeometricBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.GeometricBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.GeometricBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.GeometricBound_FindArea(self)

    def CheckPixel(self, *args):
        """CheckPixel(self, Pixel pix) -> bool"""
        return _stomp.GeometricBound_CheckPixel(self, *args)

    def ScorePixel(self, *args):
        """ScorePixel(self, Pixel pix) -> double"""
        return _stomp.GeometricBound_ScorePixel(self, *args)

    def SetArea(self, *args):
        """SetArea(self, double input_area)"""
        return _stomp.GeometricBound_SetArea(self, *args)

    def SetAngularBounds(self, *args):
        """SetAngularBounds(self, double lammin, double lammax, double etamin, double etamax)"""
        return _stomp.GeometricBound_SetAngularBounds(self, *args)

    def SetContinuousBounds(self, *args):
        """SetContinuousBounds(self, bool continuous_bounds)"""
        return _stomp.GeometricBound_SetContinuousBounds(self, *args)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.GeometricBound_Area(self)

    def LambdaMin(self):
        """LambdaMin(self) -> double"""
        return _stomp.GeometricBound_LambdaMin(self)

    def LambdaMax(self):
        """LambdaMax(self) -> double"""
        return _stomp.GeometricBound_LambdaMax(self)

    def EtaMin(self):
        """EtaMin(self) -> double"""
        return _stomp.GeometricBound_EtaMin(self)

    def EtaMax(self):
        """EtaMax(self) -> double"""
        return _stomp.GeometricBound_EtaMax(self)

    def ContinuousBounds(self):
        """ContinuousBounds(self) -> bool"""
        return _stomp.GeometricBound_ContinuousBounds(self)

    def GenerateRandomPoint(self, *args):
        """GenerateRandomPoint(self, AngularCoordinate ang)"""
        return _stomp.GeometricBound_GenerateRandomPoint(self, *args)

    def GenerateRandomPoints(self, *args):
        """GenerateRandomPoints(self, AngularVector angVec, uint32_t n_rand)"""
        return _stomp.GeometricBound_GenerateRandomPoints(self, *args)

GeometricBound_swigregister = _stomp.GeometricBound_swigregister
GeometricBound_swigregister(GeometricBound)

class CircleBound(GeometricBound):
    """Proxy of C++ Stomp::CircleBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircleBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircleBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, AngularCoordinate center_point, double radius) -> CircleBound"""
        this = _stomp.new_CircleBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_CircleBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.CircleBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.CircleBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.CircleBound_FindArea(self)

CircleBound_swigregister = _stomp.CircleBound_swigregister
CircleBound_swigregister(CircleBound)

class AnnulusBound(GeometricBound):
    """Proxy of C++ Stomp::AnnulusBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnulusBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AnnulusBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate center_point, double min_radius, 
            double max_radius) -> AnnulusBound
        __init__(self, AngularCoordinate center_point, AngularBin angular_bin) -> AnnulusBound
        """
        this = _stomp.new_AnnulusBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AnnulusBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.AnnulusBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.AnnulusBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.AnnulusBound_FindArea(self)

AnnulusBound_swigregister = _stomp.AnnulusBound_swigregister
AnnulusBound_swigregister(AnnulusBound)

class WedgeBound(GeometricBound):
    """Proxy of C++ Stomp::WedgeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WedgeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WedgeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate center_point, double radius, double position_angle_min, 
            double position_angle_max, 
            Sphere sphere = Survey) -> WedgeBound
        __init__(self, AngularCoordinate center_point, double radius, double position_angle_min, 
            double position_angle_max) -> WedgeBound
        """
        this = _stomp.new_WedgeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_WedgeBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.WedgeBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.WedgeBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.WedgeBound_FindArea(self)

WedgeBound_swigregister = _stomp.WedgeBound_swigregister
WedgeBound_swigregister(WedgeBound)

class PolygonBound(GeometricBound):
    """Proxy of C++ Stomp::PolygonBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, AngularVector ang) -> PolygonBound"""
        this = _stomp.new_PolygonBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_PolygonBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.PolygonBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.PolygonBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.PolygonBound_FindArea(self)

PolygonBound_swigregister = _stomp.PolygonBound_swigregister
PolygonBound_swigregister(PolygonBound)

class LongitudeBound(GeometricBound):
    """Proxy of C++ Stomp::LongitudeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongitudeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongitudeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double min_longitude, double max_longitude, Sphere sphere) -> LongitudeBound"""
        this = _stomp.new_LongitudeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LongitudeBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.LongitudeBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.LongitudeBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.LongitudeBound_FindArea(self)

    def LongitudeMin(self):
        """LongitudeMin(self) -> double"""
        return _stomp.LongitudeBound_LongitudeMin(self)

    def LongitudeMax(self):
        """LongitudeMax(self) -> double"""
        return _stomp.LongitudeBound_LongitudeMax(self)

    def Sphere(self):
        """Sphere(self) -> Sphere"""
        return _stomp.LongitudeBound_Sphere(self)

LongitudeBound_swigregister = _stomp.LongitudeBound_swigregister
LongitudeBound_swigregister(LongitudeBound)

class LatitudeBound(GeometricBound):
    """Proxy of C++ Stomp::LatitudeBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatitudeBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatitudeBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, double min_latitude, double max_latitude, Sphere sphere) -> LatitudeBound"""
        this = _stomp.new_LatitudeBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LatitudeBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.LatitudeBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.LatitudeBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.LatitudeBound_FindArea(self)

    def LatitudeMin(self):
        """LatitudeMin(self) -> double"""
        return _stomp.LatitudeBound_LatitudeMin(self)

    def LatitudeMax(self):
        """LatitudeMax(self) -> double"""
        return _stomp.LatitudeBound_LatitudeMax(self)

    def Sphere(self):
        """Sphere(self) -> Sphere"""
        return _stomp.LatitudeBound_Sphere(self)

LatitudeBound_swigregister = _stomp.LatitudeBound_swigregister
LatitudeBound_swigregister(LatitudeBound)

class LatLonBound(GeometricBound):
    """Proxy of C++ Stomp::LatLonBound class"""
    __swig_setmethods__ = {}
    for _s in [GeometricBound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatLonBound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricBound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatLonBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double min_latitude, double max_latitude, double min_longitude, 
            double max_longitude, Sphere sphere) -> LatLonBound
        """
        this = _stomp.new_LatLonBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_LatLonBound
    __del__ = lambda self : None;
    def CheckPoint(self, *args):
        """CheckPoint(self, AngularCoordinate ang) -> bool"""
        return _stomp.LatLonBound_CheckPoint(self, *args)

    def FindAngularBounds(self):
        """FindAngularBounds(self) -> bool"""
        return _stomp.LatLonBound_FindAngularBounds(self)

    def FindArea(self):
        """FindArea(self) -> bool"""
        return _stomp.LatLonBound_FindArea(self)

    def LongitudeMin(self):
        """LongitudeMin(self) -> double"""
        return _stomp.LatLonBound_LongitudeMin(self)

    def LongitudeMax(self):
        """LongitudeMax(self) -> double"""
        return _stomp.LatLonBound_LongitudeMax(self)

    def LatitudeMin(self):
        """LatitudeMin(self) -> double"""
        return _stomp.LatLonBound_LatitudeMin(self)

    def LatitudeMax(self):
        """LatitudeMax(self) -> double"""
        return _stomp.LatLonBound_LatitudeMax(self)

    def Sphere(self):
        """Sphere(self) -> Sphere"""
        return _stomp.LatLonBound_Sphere(self)

LatLonBound_swigregister = _stomp.LatLonBound_swigregister
LatLonBound_swigregister(LatLonBound)

class Cosmology(_object):
    """Proxy of C++ Stomp::Cosmology class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cosmology, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Cosmology, name)
    __repr__ = _swig_repr
    __swig_setmethods__["omega_m"] = _stomp.Cosmology_omega_m_set
    __swig_getmethods__["omega_m"] = _stomp.Cosmology_omega_m_get
    if _newclass:omega_m = _swig_property(_stomp.Cosmology_omega_m_get, _stomp.Cosmology_omega_m_set)
    __swig_setmethods__["h"] = _stomp.Cosmology_h_set
    __swig_getmethods__["h"] = _stomp.Cosmology_h_get
    if _newclass:h = _swig_property(_stomp.Cosmology_h_get, _stomp.Cosmology_h_set)
    __swig_setmethods__["a_"] = _stomp.Cosmology_a__set
    __swig_getmethods__["a_"] = _stomp.Cosmology_a__get
    if _newclass:a_ = _swig_property(_stomp.Cosmology_a__get, _stomp.Cosmology_a__set)
    __swig_setmethods__["b_"] = _stomp.Cosmology_b__set
    __swig_getmethods__["b_"] = _stomp.Cosmology_b__get
    if _newclass:b_ = _swig_property(_stomp.Cosmology_b__get, _stomp.Cosmology_b__set)
    def OmegaM():
        """OmegaM() -> double"""
        return _stomp.Cosmology_OmegaM()

    if _newclass:OmegaM = staticmethod(OmegaM)
    __swig_getmethods__["OmegaM"] = lambda x: OmegaM
    def HubbleConstant():
        """HubbleConstant() -> double"""
        return _stomp.Cosmology_HubbleConstant()

    if _newclass:HubbleConstant = staticmethod(HubbleConstant)
    __swig_getmethods__["HubbleConstant"] = lambda x: HubbleConstant
    def HubbleDistance():
        """HubbleDistance() -> double"""
        return _stomp.Cosmology_HubbleDistance()

    if _newclass:HubbleDistance = staticmethod(HubbleDistance)
    __swig_getmethods__["HubbleDistance"] = lambda x: HubbleDistance
    def OmegaL():
        """OmegaL() -> double"""
        return _stomp.Cosmology_OmegaL()

    if _newclass:OmegaL = staticmethod(OmegaL)
    __swig_getmethods__["OmegaL"] = lambda x: OmegaL
    def SetOmegaM(*args):
        """SetOmegaM(double omega_m)"""
        return _stomp.Cosmology_SetOmegaM(*args)

    if _newclass:SetOmegaM = staticmethod(SetOmegaM)
    __swig_getmethods__["SetOmegaM"] = lambda x: SetOmegaM
    def SetHubbleConstant(*args):
        """SetHubbleConstant(double hubble)"""
        return _stomp.Cosmology_SetHubbleConstant(*args)

    if _newclass:SetHubbleConstant = staticmethod(SetHubbleConstant)
    __swig_getmethods__["SetHubbleConstant"] = lambda x: SetHubbleConstant
    def SetOmegaL(*args):
        """SetOmegaL(double omega_lambda)"""
        return _stomp.Cosmology_SetOmegaL(*args)

    if _newclass:SetOmegaL = staticmethod(SetOmegaL)
    __swig_getmethods__["SetOmegaL"] = lambda x: SetOmegaL
    def ComovingDistance(*args):
        """ComovingDistance(double z) -> double"""
        return _stomp.Cosmology_ComovingDistance(*args)

    if _newclass:ComovingDistance = staticmethod(ComovingDistance)
    __swig_getmethods__["ComovingDistance"] = lambda x: ComovingDistance
    def AngularDiameterDistance(*args):
        """AngularDiameterDistance(double z) -> double"""
        return _stomp.Cosmology_AngularDiameterDistance(*args)

    if _newclass:AngularDiameterDistance = staticmethod(AngularDiameterDistance)
    __swig_getmethods__["AngularDiameterDistance"] = lambda x: AngularDiameterDistance
    def LuminosityDistance(*args):
        """LuminosityDistance(double z) -> double"""
        return _stomp.Cosmology_LuminosityDistance(*args)

    if _newclass:LuminosityDistance = staticmethod(LuminosityDistance)
    __swig_getmethods__["LuminosityDistance"] = lambda x: LuminosityDistance
    def ProjectedDistance(*args):
        """ProjectedDistance(double z, double theta) -> double"""
        return _stomp.Cosmology_ProjectedDistance(*args)

    if _newclass:ProjectedDistance = staticmethod(ProjectedDistance)
    __swig_getmethods__["ProjectedDistance"] = lambda x: ProjectedDistance
    def ProjectedAngle(*args):
        """ProjectedAngle(double z, double radius) -> double"""
        return _stomp.Cosmology_ProjectedAngle(*args)

    if _newclass:ProjectedAngle = staticmethod(ProjectedAngle)
    __swig_getmethods__["ProjectedAngle"] = lambda x: ProjectedAngle
    def __init__(self): 
        """__init__(self) -> Cosmology"""
        this = _stomp.new_Cosmology()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Cosmology
    __del__ = lambda self : None;
Cosmology_swigregister = _stomp.Cosmology_swigregister
Cosmology_swigregister(Cosmology)
Cosmology.AA_ = _stomp.cvar.Cosmology_AA_
Cosmology.BB_ = _stomp.cvar.Cosmology_BB_

def Cosmology_OmegaM():
  """Cosmology_OmegaM() -> double"""
  return _stomp.Cosmology_OmegaM()

def Cosmology_HubbleConstant():
  """Cosmology_HubbleConstant() -> double"""
  return _stomp.Cosmology_HubbleConstant()

def Cosmology_HubbleDistance():
  """Cosmology_HubbleDistance() -> double"""
  return _stomp.Cosmology_HubbleDistance()

def Cosmology_OmegaL():
  """Cosmology_OmegaL() -> double"""
  return _stomp.Cosmology_OmegaL()

def Cosmology_SetOmegaM(*args):
  """Cosmology_SetOmegaM(double omega_m)"""
  return _stomp.Cosmology_SetOmegaM(*args)

def Cosmology_SetHubbleConstant(*args):
  """Cosmology_SetHubbleConstant(double hubble)"""
  return _stomp.Cosmology_SetHubbleConstant(*args)

def Cosmology_SetOmegaL(*args):
  """Cosmology_SetOmegaL(double omega_lambda)"""
  return _stomp.Cosmology_SetOmegaL(*args)

def Cosmology_ComovingDistance(*args):
  """Cosmology_ComovingDistance(double z) -> double"""
  return _stomp.Cosmology_ComovingDistance(*args)

def Cosmology_AngularDiameterDistance(*args):
  """Cosmology_AngularDiameterDistance(double z) -> double"""
  return _stomp.Cosmology_AngularDiameterDistance(*args)

def Cosmology_LuminosityDistance(*args):
  """Cosmology_LuminosityDistance(double z) -> double"""
  return _stomp.Cosmology_LuminosityDistance(*args)

def Cosmology_ProjectedDistance(*args):
  """Cosmology_ProjectedDistance(double z, double theta) -> double"""
  return _stomp.Cosmology_ProjectedDistance(*args)

def Cosmology_ProjectedAngle(*args):
  """Cosmology_ProjectedAngle(double z, double radius) -> double"""
  return _stomp.Cosmology_ProjectedAngle(*args)

class StompWatch(_object):
    """Proxy of C++ Stomp::StompWatch class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StompWatch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StompWatch, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> StompWatch"""
        this = _stomp.new_StompWatch()
        try: self.this.append(this)
        except: self.this = this
    def StartTimer(self):
        """StartTimer(self)"""
        return _stomp.StompWatch_StartTimer(self)

    def StopTimer(self):
        """StopTimer(self)"""
        return _stomp.StompWatch_StopTimer(self)

    def ElapsedTime(self):
        """ElapsedTime(self) -> double"""
        return _stomp.StompWatch_ElapsedTime(self)

    __swig_destroy__ = _stomp.delete_StompWatch
    __del__ = lambda self : None;
StompWatch_swigregister = _stomp.StompWatch_swigregister
StompWatch_swigregister(StompWatch)

class HistogramBin(_object):
    """Proxy of C++ Stomp::HistogramBin class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HistogramBin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HistogramBin, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> HistogramBin
        __init__(self, double bin_min, double bin_max) -> HistogramBin
        """
        this = _stomp.new_HistogramBin(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_HistogramBin
    __del__ = lambda self : None;
    def SetBounds(self, *args):
        """SetBounds(self, double bin_min, double bin_max)"""
        return _stomp.HistogramBin_SetBounds(self, *args)

    def AddToBin(self, *args):
        """
        AddToBin(self, double bin_value, double weight = 1.0) -> bool
        AddToBin(self, double bin_value) -> bool
        """
        return _stomp.HistogramBin_AddToBin(self, *args)

    def BinMinimum(self):
        """BinMinimum(self) -> double"""
        return _stomp.HistogramBin_BinMinimum(self)

    def BinMaximum(self):
        """BinMaximum(self) -> double"""
        return _stomp.HistogramBin_BinMaximum(self)

    def BinCenter(self):
        """BinCenter(self) -> double"""
        return _stomp.HistogramBin_BinCenter(self)

    def BinLogCenter(self):
        """BinLogCenter(self) -> double"""
        return _stomp.HistogramBin_BinLogCenter(self)

    def BinWeightedCenter(self):
        """BinWeightedCenter(self) -> double"""
        return _stomp.HistogramBin_BinWeightedCenter(self)

    def BinAveragedCenter(self):
        """BinAveragedCenter(self) -> double"""
        return _stomp.HistogramBin_BinAveragedCenter(self)

    def WithinBin(self, *args):
        """WithinBin(self, double bin_value) -> bool"""
        return _stomp.HistogramBin_WithinBin(self, *args)

    def BinWeight(self):
        """BinWeight(self) -> double"""
        return _stomp.HistogramBin_BinWeight(self)

    def BinItems(self):
        """BinItems(self) -> uint32_t"""
        return _stomp.HistogramBin_BinItems(self)

    def BinMeanWeight(self):
        """BinMeanWeight(self) -> double"""
        return _stomp.HistogramBin_BinMeanWeight(self)

HistogramBin_swigregister = _stomp.HistogramBin_swigregister
HistogramBin_swigregister(HistogramBin)

class Histogram(_object):
    """Proxy of C++ Stomp::Histogram class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Histogram, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Histogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Histogram
        __init__(self, double hist_min, double hist_max, uint16_t n_bins, 
            bool log_binning = False) -> Histogram
        __init__(self, double hist_min, double hist_max, uint16_t n_bins) -> Histogram
        """
        this = _stomp.new_Histogram(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_Histogram
    __del__ = lambda self : None;
    def SetBounds(self, *args):
        """SetBounds(self, double bin_min, double bin_max)"""
        return _stomp.Histogram_SetBounds(self, *args)

    def SetNBins(self, *args):
        """SetNBins(self, uint16_t n_bins)"""
        return _stomp.Histogram_SetNBins(self, *args)

    def SetLogBinning(self, *args):
        """SetLogBinning(self, bool log_binning) -> bool"""
        return _stomp.Histogram_SetLogBinning(self, *args)

    def AssignBins(self):
        """AssignBins(self) -> bool"""
        return _stomp.Histogram_AssignBins(self)

    def AddToBin(self, *args):
        """
        AddToBin(self, double bin_value, double weight = 1.0) -> bool
        AddToBin(self, double bin_value) -> bool
        """
        return _stomp.Histogram_AddToBin(self, *args)

    def Begin(self):
        """Begin(self) -> BinIterator"""
        return _stomp.Histogram_Begin(self)

    def End(self):
        """End(self) -> BinIterator"""
        return _stomp.Histogram_End(self)

    def BoundMin(self):
        """BoundMin(self) -> double"""
        return _stomp.Histogram_BoundMin(self)

    def BoundMax(self):
        """BoundMax(self) -> double"""
        return _stomp.Histogram_BoundMax(self)

    def NBins(self):
        """NBins(self) -> uint16_t"""
        return _stomp.Histogram_NBins(self)

    def LogBinning(self):
        """LogBinning(self) -> bool"""
        return _stomp.Histogram_LogBinning(self)

    def TotalItems(self):
        """TotalItems(self) -> uint32_t"""
        return _stomp.Histogram_TotalItems(self)

    def TotalWeight(self):
        """TotalWeight(self) -> double"""
        return _stomp.Histogram_TotalWeight(self)

    def MeanItemWeight(self):
        """MeanItemWeight(self) -> double"""
        return _stomp.Histogram_MeanItemWeight(self)

    def MeanBinValue(self):
        """MeanBinValue(self) -> double"""
        return _stomp.Histogram_MeanBinValue(self)

    def MeanWeightedBinValue(self):
        """MeanWeightedBinValue(self) -> double"""
        return _stomp.Histogram_MeanWeightedBinValue(self)

    def Bins(self):
        "Returns an iterator for Bins."
        return GenericIterator(
                self._begin_Bins,
                self._deref_Bins,
                _iter_incr
                 )

    def _begin_Bins(self):
        """_begin_Bins(self) -> std::vector<(Stomp::HistogramBin,std::allocator<(Stomp::HistogramBin)>)>::const_iterator"""
        return _stomp.Histogram__begin_Bins(self)

    def _deref_Bins(self, *args):
        """_deref_Bins(self, std::vector<(Stomp::HistogramBin,std::allocator<(Stomp::HistogramBin)>)>::const_iterator iter) -> HistogramBin"""
        return _stomp.Histogram__deref_Bins(self, *args)

Histogram_swigregister = _stomp.Histogram_swigregister
Histogram_swigregister(Histogram)


def Tokenize(*args):
  """
    Tokenize(string str, std::vector<(std::string,std::allocator<(std::string)>)> tokens, 
        string delimiters)
    """
  return _stomp.Tokenize(*args)
class AngularCoordinate(_object):
    """Proxy of C++ Stomp::AngularCoordinate class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularCoordinate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularCoordinate, name)
    __repr__ = _swig_repr
    Survey = _stomp.AngularCoordinate_Survey
    Equatorial = _stomp.AngularCoordinate_Equatorial
    Galactic = _stomp.AngularCoordinate_Galactic
    def __init__(self, *args): 
        """
        __init__(self, double theta = 0.0, double phi = 0.0, Sphere sphere = Survey, 
            bool radians = False) -> AngularCoordinate
        __init__(self, double theta = 0.0, double phi = 0.0, Sphere sphere = Survey) -> AngularCoordinate
        __init__(self, double theta = 0.0, double phi = 0.0) -> AngularCoordinate
        __init__(self, double theta = 0.0) -> AngularCoordinate
        __init__(self) -> AngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z) -> AngularCoordinate
        """
        this = _stomp.new_AngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_AngularCoordinate
    __del__ = lambda self : None;
    def SetSurveyCoordinates(self, *args):
        """
        SetSurveyCoordinates(self, double _lambda, double eta, bool radians = False)
        SetSurveyCoordinates(self, double _lambda, double eta)
        """
        return _stomp.AngularCoordinate_SetSurveyCoordinates(self, *args)

    def SetEquatorialCoordinates(self, *args):
        """
        SetEquatorialCoordinates(self, double ra, double dec, bool radians = False)
        SetEquatorialCoordinates(self, double ra, double dec)
        """
        return _stomp.AngularCoordinate_SetEquatorialCoordinates(self, *args)

    def SetGalacticCoordinates(self, *args):
        """
        SetGalacticCoordinates(self, double gal_lon, double gal_lat, bool radians = False)
        SetGalacticCoordinates(self, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_SetGalacticCoordinates(self, *args)

    def SetUnitSphereCoordinates(self, *args):
        """
        SetUnitSphereCoordinates(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z)
        SetUnitSphereCoordinates(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            Sphere sphere)
        """
        return _stomp.AngularCoordinate_SetUnitSphereCoordinates(self, *args)

    def Set(self, *args):
        """
        Set(self, double theta, double phi, Sphere sphere, bool radians = False)
        Set(self, double theta, double phi, Sphere sphere)
        """
        return _stomp.AngularCoordinate_Set(self, *args)

    def Lambda(self):
        """Lambda(self) -> double"""
        return _stomp.AngularCoordinate_Lambda(self)

    def Eta(self):
        """Eta(self) -> double"""
        return _stomp.AngularCoordinate_Eta(self)

    def LambdaRadians(self):
        """LambdaRadians(self) -> double"""
        return _stomp.AngularCoordinate_LambdaRadians(self)

    def EtaRadians(self):
        """EtaRadians(self) -> double"""
        return _stomp.AngularCoordinate_EtaRadians(self)

    def RA(self):
        """RA(self) -> double"""
        return _stomp.AngularCoordinate_RA(self)

    def DEC(self):
        """DEC(self) -> double"""
        return _stomp.AngularCoordinate_DEC(self)

    def RARadians(self):
        """RARadians(self) -> double"""
        return _stomp.AngularCoordinate_RARadians(self)

    def DECRadians(self):
        """DECRadians(self) -> double"""
        return _stomp.AngularCoordinate_DECRadians(self)

    def GalLon(self):
        """GalLon(self) -> double"""
        return _stomp.AngularCoordinate_GalLon(self)

    def GalLat(self):
        """GalLat(self) -> double"""
        return _stomp.AngularCoordinate_GalLat(self)

    def GalLonRadians(self):
        """GalLonRadians(self) -> double"""
        return _stomp.AngularCoordinate_GalLonRadians(self)

    def GalLatRadians(self):
        """GalLatRadians(self) -> double"""
        return _stomp.AngularCoordinate_GalLatRadians(self)

    def UnitSphereX(self, *args):
        """
        UnitSphereX(self) -> double
        UnitSphereX(self, Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereX(self, *args)

    def UnitSphereY(self, *args):
        """
        UnitSphereY(self) -> double
        UnitSphereY(self, Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereY(self, *args)

    def UnitSphereZ(self, *args):
        """
        UnitSphereZ(self) -> double
        UnitSphereZ(self, Sphere sphere) -> double
        """
        return _stomp.AngularCoordinate_UnitSphereZ(self, *args)

    def AngularDistance(self, *args):
        """AngularDistance(self, AngularCoordinate ang) -> double"""
        return _stomp.AngularCoordinate_AngularDistance(self, *args)

    def DotProduct(self, *args):
        """DotProduct(self, AngularCoordinate ang) -> double"""
        return _stomp.AngularCoordinate_DotProduct(self, *args)

    def CrossProduct(self, *args):
        """
        CrossProduct(self, AngularCoordinate ang, Sphere sphere = Equatorial) -> AngularCoordinate
        CrossProduct(self, AngularCoordinate ang) -> AngularCoordinate
        """
        return _stomp.AngularCoordinate_CrossProduct(self, *args)

    def GreatCircle(self, *args):
        """
        GreatCircle(self, AngularCoordinate ang, AngularCoordinate great_circle, 
            Sphere sphere = Equatorial)
        GreatCircle(self, AngularCoordinate ang, AngularCoordinate great_circle)
        """
        return _stomp.AngularCoordinate_GreatCircle(self, *args)

    def PositionAngle(self, *args):
        """
        PositionAngle(self, AngularCoordinate ang, Sphere sphere = Equatorial) -> double
        PositionAngle(self, AngularCoordinate ang) -> double
        PositionAngle(self, Pixel pix, Sphere sphere = Equatorial) -> double
        PositionAngle(self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_PositionAngle(self, *args)

    def CosPositionAngle(self, *args):
        """
        CosPositionAngle(self, AngularCoordinate ang, Sphere sphere = Equatorial) -> double
        CosPositionAngle(self, AngularCoordinate ang) -> double
        CosPositionAngle(self, Pixel pix, Sphere sphere = Equatorial) -> double
        CosPositionAngle(self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_CosPositionAngle(self, *args)

    def SinPositionAngle(self, *args):
        """
        SinPositionAngle(self, AngularCoordinate ang, Sphere sphere = Equatorial) -> double
        SinPositionAngle(self, AngularCoordinate ang) -> double
        SinPositionAngle(self, Pixel pix, Sphere sphere = Equatorial) -> double
        SinPositionAngle(self, Pixel pix) -> double
        """
        return _stomp.AngularCoordinate_SinPositionAngle(self, *args)

    def Rotate(self, *args):
        """
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            Sphere sphere = Equatorial)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            AngularCoordinate rotated_ang, Sphere sphere = Equatorial)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            AngularCoordinate rotated_ang)
        Rotate(self, AngularCoordinate fixed_ang, double rotation_angle, 
            Sphere sphere, double unit_sphere_x, double unit_sphere_y, 
            double unit_sphere_z)
        """
        return _stomp.AngularCoordinate_Rotate(self, *args)

    def SurveyToGalactic(*args):
        """
        SurveyToGalactic(double _lambda, double eta, double gal_lon, double gal_lat, 
            bool radians = False)
        SurveyToGalactic(double _lambda, double eta, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_SurveyToGalactic(*args)

    if _newclass:SurveyToGalactic = staticmethod(SurveyToGalactic)
    __swig_getmethods__["SurveyToGalactic"] = lambda x: SurveyToGalactic
    def SurveyToEquatorial(*args):
        """
        SurveyToEquatorial(double _lambda, double eta, double ra, double dec, 
            bool radians = False)
        SurveyToEquatorial(double _lambda, double eta, double ra, double dec)
        """
        return _stomp.AngularCoordinate_SurveyToEquatorial(*args)

    if _newclass:SurveyToEquatorial = staticmethod(SurveyToEquatorial)
    __swig_getmethods__["SurveyToEquatorial"] = lambda x: SurveyToEquatorial
    def EquatorialToSurvey(*args):
        """
        EquatorialToSurvey(double ra, double dec, double _lambda, double eta, 
            bool radians = False)
        EquatorialToSurvey(double ra, double dec, double _lambda, double eta)
        """
        return _stomp.AngularCoordinate_EquatorialToSurvey(*args)

    if _newclass:EquatorialToSurvey = staticmethod(EquatorialToSurvey)
    __swig_getmethods__["EquatorialToSurvey"] = lambda x: EquatorialToSurvey
    def EquatorialToGalactic(*args):
        """
        EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat, 
            bool radians = False)
        EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat)
        """
        return _stomp.AngularCoordinate_EquatorialToGalactic(*args)

    if _newclass:EquatorialToGalactic = staticmethod(EquatorialToGalactic)
    __swig_getmethods__["EquatorialToGalactic"] = lambda x: EquatorialToGalactic
    def GalacticToSurvey(*args):
        """
        GalacticToSurvey(double gal_lon, double gal_lat, double _lambda, double eta, 
            bool radians = False)
        GalacticToSurvey(double gal_lon, double gal_lat, double _lambda, double eta)
        """
        return _stomp.AngularCoordinate_GalacticToSurvey(*args)

    if _newclass:GalacticToSurvey = staticmethod(GalacticToSurvey)
    __swig_getmethods__["GalacticToSurvey"] = lambda x: GalacticToSurvey
    def GalacticToEquatorial(*args):
        """
        GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec, 
            bool radians = False)
        GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec)
        """
        return _stomp.AngularCoordinate_GalacticToEquatorial(*args)

    if _newclass:GalacticToEquatorial = staticmethod(GalacticToEquatorial)
    __swig_getmethods__["GalacticToEquatorial"] = lambda x: GalacticToEquatorial
    def SurveyToXYZ(*args):
        """
        SurveyToXYZ(double _lambda, double eta, double x, double y, double z, 
            bool radians = False)
        SurveyToXYZ(double _lambda, double eta, double x, double y, double z)
        """
        return _stomp.AngularCoordinate_SurveyToXYZ(*args)

    if _newclass:SurveyToXYZ = staticmethod(SurveyToXYZ)
    __swig_getmethods__["SurveyToXYZ"] = lambda x: SurveyToXYZ
    def EquatorialToXYZ(*args):
        """
        EquatorialToXYZ(double ra, double dec, double x, double y, double z, 
            bool radians = False)
        EquatorialToXYZ(double ra, double dec, double x, double y, double z)
        """
        return _stomp.AngularCoordinate_EquatorialToXYZ(*args)

    if _newclass:EquatorialToXYZ = staticmethod(EquatorialToXYZ)
    __swig_getmethods__["EquatorialToXYZ"] = lambda x: EquatorialToXYZ
    def GalacticToXYZ(*args):
        """
        GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
            double z, bool radians = False)
        GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
            double z)
        """
        return _stomp.AngularCoordinate_GalacticToXYZ(*args)

    if _newclass:GalacticToXYZ = staticmethod(GalacticToXYZ)
    __swig_getmethods__["GalacticToXYZ"] = lambda x: GalacticToXYZ
    def EtaMultiplier(*args):
        """EtaMultiplier(double lam) -> double"""
        return _stomp.AngularCoordinate_EtaMultiplier(*args)

    if _newclass:EtaMultiplier = staticmethod(EtaMultiplier)
    __swig_getmethods__["EtaMultiplier"] = lambda x: EtaMultiplier
    def RAMultiplier(*args):
        """RAMultiplier(double dec) -> double"""
        return _stomp.AngularCoordinate_RAMultiplier(*args)

    if _newclass:RAMultiplier = staticmethod(RAMultiplier)
    __swig_getmethods__["RAMultiplier"] = lambda x: RAMultiplier
    def GalLonMultiplier(*args):
        """GalLonMultiplier(double glat) -> double"""
        return _stomp.AngularCoordinate_GalLonMultiplier(*args)

    if _newclass:GalLonMultiplier = staticmethod(GalLonMultiplier)
    __swig_getmethods__["GalLonMultiplier"] = lambda x: GalLonMultiplier
    def ToAngularVector(*args):
        """
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
            Sphere sphere = Equatorial, bool radians = False) -> bool
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
            Sphere sphere = Equatorial) -> bool
        ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial) -> bool
        ToAngularVector(string input_file, AngularVector ang) -> bool
        """
        return _stomp.AngularCoordinate_ToAngularVector(*args)

    if _newclass:ToAngularVector = staticmethod(ToAngularVector)
    __swig_getmethods__["ToAngularVector"] = lambda x: ToAngularVector
    def FromAngularVector(*args):
        """
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
            Sphere sphere = Equatorial, bool radians = False) -> bool
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
            Sphere sphere = Equatorial) -> bool
        FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec) -> bool
        FromAngularVector(AngularVector ang, string output_file, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromAngularVector(AngularVector ang, string output_file, Sphere sphere = Equatorial) -> bool
        FromAngularVector(AngularVector ang, string output_file) -> bool
        """
        return _stomp.AngularCoordinate_FromAngularVector(*args)

    if _newclass:FromAngularVector = staticmethod(FromAngularVector)
    __swig_getmethods__["FromAngularVector"] = lambda x: FromAngularVector
AngularCoordinate_swigregister = _stomp.AngularCoordinate_swigregister
AngularCoordinate_swigregister(AngularCoordinate)

def AngularCoordinate_SurveyToGalactic(*args):
  """
    SurveyToGalactic(double _lambda, double eta, double gal_lon, double gal_lat, 
        bool radians = False)
    AngularCoordinate_SurveyToGalactic(double _lambda, double eta, double gal_lon, double gal_lat)
    """
  return _stomp.AngularCoordinate_SurveyToGalactic(*args)

def AngularCoordinate_SurveyToEquatorial(*args):
  """
    SurveyToEquatorial(double _lambda, double eta, double ra, double dec, 
        bool radians = False)
    AngularCoordinate_SurveyToEquatorial(double _lambda, double eta, double ra, double dec)
    """
  return _stomp.AngularCoordinate_SurveyToEquatorial(*args)

def AngularCoordinate_EquatorialToSurvey(*args):
  """
    EquatorialToSurvey(double ra, double dec, double _lambda, double eta, 
        bool radians = False)
    AngularCoordinate_EquatorialToSurvey(double ra, double dec, double _lambda, double eta)
    """
  return _stomp.AngularCoordinate_EquatorialToSurvey(*args)

def AngularCoordinate_EquatorialToGalactic(*args):
  """
    EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat, 
        bool radians = False)
    AngularCoordinate_EquatorialToGalactic(double ra, double dec, double gal_lon, double gal_lat)
    """
  return _stomp.AngularCoordinate_EquatorialToGalactic(*args)

def AngularCoordinate_GalacticToSurvey(*args):
  """
    GalacticToSurvey(double gal_lon, double gal_lat, double _lambda, double eta, 
        bool radians = False)
    AngularCoordinate_GalacticToSurvey(double gal_lon, double gal_lat, double _lambda, double eta)
    """
  return _stomp.AngularCoordinate_GalacticToSurvey(*args)

def AngularCoordinate_GalacticToEquatorial(*args):
  """
    GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec, 
        bool radians = False)
    AngularCoordinate_GalacticToEquatorial(double gal_lon, double gal_lat, double ra, double dec)
    """
  return _stomp.AngularCoordinate_GalacticToEquatorial(*args)

def AngularCoordinate_SurveyToXYZ(*args):
  """
    SurveyToXYZ(double _lambda, double eta, double x, double y, double z, 
        bool radians = False)
    AngularCoordinate_SurveyToXYZ(double _lambda, double eta, double x, double y, double z)
    """
  return _stomp.AngularCoordinate_SurveyToXYZ(*args)

def AngularCoordinate_EquatorialToXYZ(*args):
  """
    EquatorialToXYZ(double ra, double dec, double x, double y, double z, 
        bool radians = False)
    AngularCoordinate_EquatorialToXYZ(double ra, double dec, double x, double y, double z)
    """
  return _stomp.AngularCoordinate_EquatorialToXYZ(*args)

def AngularCoordinate_GalacticToXYZ(*args):
  """
    GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
        double z, bool radians = False)
    AngularCoordinate_GalacticToXYZ(double gal_lon, double gal_lat, double x, double y, 
        double z)
    """
  return _stomp.AngularCoordinate_GalacticToXYZ(*args)

def AngularCoordinate_EtaMultiplier(*args):
  """AngularCoordinate_EtaMultiplier(double lam) -> double"""
  return _stomp.AngularCoordinate_EtaMultiplier(*args)

def AngularCoordinate_RAMultiplier(*args):
  """AngularCoordinate_RAMultiplier(double dec) -> double"""
  return _stomp.AngularCoordinate_RAMultiplier(*args)

def AngularCoordinate_GalLonMultiplier(*args):
  """AngularCoordinate_GalLonMultiplier(double glat) -> double"""
  return _stomp.AngularCoordinate_GalLonMultiplier(*args)

def AngularCoordinate_ToAngularVector(*args):
  """
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
        Sphere sphere = Equatorial, bool radians = False) -> bool
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang, 
        Sphere sphere = Equatorial) -> bool
    ToAngularVector(DoubleVector thetaVec, DoubleVector phiVec, AngularVector ang) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToAngularVector(string input_file, AngularVector ang, Sphere sphere = Equatorial) -> bool
    AngularCoordinate_ToAngularVector(string input_file, AngularVector ang) -> bool
    """
  return _stomp.AngularCoordinate_ToAngularVector(*args)

def AngularCoordinate_FromAngularVector(*args):
  """
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
        Sphere sphere = Equatorial, bool radians = False) -> bool
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec, 
        Sphere sphere = Equatorial) -> bool
    FromAngularVector(AngularVector ang, DoubleVector thetaVec, DoubleVector phiVec) -> bool
    FromAngularVector(AngularVector ang, string output_file, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromAngularVector(AngularVector ang, string output_file, Sphere sphere = Equatorial) -> bool
    AngularCoordinate_FromAngularVector(AngularVector ang, string output_file) -> bool
    """
  return _stomp.AngularCoordinate_FromAngularVector(*args)

class WeightedAngularCoordinate(AngularCoordinate):
    """Proxy of C++ Stomp::WeightedAngularCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [AngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedAngularCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedAngularCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, Sphere sphere = Survey, 
            bool radians = False) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, Sphere sphere = Survey) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, FieldDict fields, 
            Sphere sphere = Survey, bool radians = False) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, FieldDict fields, 
            Sphere sphere = Survey) -> WeightedAngularCoordinate
        __init__(self, double theta, double phi, double weight, FieldDict fields) -> WeightedAngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            double weight) -> WeightedAngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            double weight, FieldDict fields) -> WeightedAngularCoordinate
        """
        this = _stomp.new_WeightedAngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_WeightedAngularCoordinate
    __del__ = lambda self : None;
    def SetWeight(self, *args):
        """SetWeight(self, double weight)"""
        return _stomp.WeightedAngularCoordinate_SetWeight(self, *args)

    def Weight(self):
        """Weight(self) -> double"""
        return _stomp.WeightedAngularCoordinate_Weight(self)

    def SetField(self, *args):
        """SetField(self, string field_name, double weight)"""
        return _stomp.WeightedAngularCoordinate_SetField(self, *args)

    def Field(self, *args):
        """Field(self, string field_name) -> double"""
        return _stomp.WeightedAngularCoordinate_Field(self, *args)

    def NFields(self):
        """NFields(self) -> uint16_t"""
        return _stomp.WeightedAngularCoordinate_NFields(self)

    def HasFields(self):
        """HasFields(self) -> bool"""
        return _stomp.WeightedAngularCoordinate_HasFields(self)

    def FieldNames(self, *args):
        """FieldNames(self, std::vector<(std::string,std::allocator<(std::string)>)> field_names)"""
        return _stomp.WeightedAngularCoordinate_FieldNames(self, *args)

    def CopyFields(self, *args):
        """CopyFields(self, WeightedAngularCoordinate w_ang)"""
        return _stomp.WeightedAngularCoordinate_CopyFields(self, *args)

    def CopyFieldToWeight(self, *args):
        """CopyFieldToWeight(self, string field_name)"""
        return _stomp.WeightedAngularCoordinate_CopyFieldToWeight(self, *args)

    def RestoreOriginalWeight(self):
        """RestoreOriginalWeight(self)"""
        return _stomp.WeightedAngularCoordinate_RestoreOriginalWeight(self)

    def ToWAngularVector(*args):
        """
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            WAngularVector w_ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            WAngularVector w_ang, Sphere sphere = Equatorial) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
            WAngularVector w_ang) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
            WAngularVector w_ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
            WAngularVector w_ang, Sphere sphere = Equatorial) -> bool
        ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
            WAngularVector w_ang) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, 
            int8_t weight_column = -1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, int8_t weight_column = -1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
            Sphere sphere = Equatorial) -> bool
        ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns) -> bool
        """
        return _stomp.WeightedAngularCoordinate_ToWAngularVector(*args)

    if _newclass:ToWAngularVector = staticmethod(ToWAngularVector)
    __swig_getmethods__["ToWAngularVector"] = lambda x: ToWAngularVector
    def FromWAngularVector(*args):
        """
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector weightVec, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector weightVec, Sphere sphere = Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector weightVec) -> bool
        FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere = Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, string output_file) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, uint8_t weight_column = 2) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file, Sphere sphere = Equatorial) -> bool
        FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
            string output_file) -> bool
        """
        return _stomp.WeightedAngularCoordinate_FromWAngularVector(*args)

    if _newclass:FromWAngularVector = staticmethod(FromWAngularVector)
    __swig_getmethods__["FromWAngularVector"] = lambda x: FromWAngularVector
    def AddField(*args):
        """AddField(WAngularVector w_ang, string field_name, DoubleVector field_value) -> bool"""
        return _stomp.WeightedAngularCoordinate_AddField(*args)

    if _newclass:AddField = staticmethod(AddField)
    __swig_getmethods__["AddField"] = lambda x: AddField
WeightedAngularCoordinate_swigregister = _stomp.WeightedAngularCoordinate_swigregister
WeightedAngularCoordinate_swigregister(WeightedAngularCoordinate)

def WeightedAngularCoordinate_ToWAngularVector(*args):
  """
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        WAngularVector w_ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        WAngularVector w_ang, Sphere sphere = Equatorial) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector weightVec, 
        WAngularVector w_ang) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
        WAngularVector w_ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
        WAngularVector w_ang, Sphere sphere = Equatorial) -> bool
    ToWAngularVector(DoubleVector thetaVec, DoubleVector phiVec, double weight, 
        WAngularVector w_ang) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1, 
        int8_t weight_column = -1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, Sphere sphere = Equatorial) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1, int8_t weight_column = -1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns, 
        Sphere sphere = Equatorial) -> bool
    WeightedAngularCoordinate_ToWAngularVector(string input_file, WAngularVector w_ang, FieldColumnDict field_columns) -> bool
    """
  return _stomp.WeightedAngularCoordinate_ToWAngularVector(*args)

def WeightedAngularCoordinate_FromWAngularVector(*args):
  """
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector weightVec, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector weightVec, Sphere sphere = Equatorial) -> bool
    FromWAngularVector(WAngularVector w_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector weightVec) -> bool
    FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromWAngularVector(WAngularVector w_ang, string output_file, Sphere sphere = Equatorial) -> bool
    FromWAngularVector(WAngularVector w_ang, string output_file) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1, uint8_t weight_column = 2) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file, Sphere sphere = Equatorial) -> bool
    WeightedAngularCoordinate_FromWAngularVector(WAngularVector w_ang, FieldColumnDict field_columns, 
        string output_file) -> bool
    """
  return _stomp.WeightedAngularCoordinate_FromWAngularVector(*args)

def WeightedAngularCoordinate_AddField(*args):
  """WeightedAngularCoordinate_AddField(WAngularVector w_ang, string field_name, DoubleVector field_value) -> bool"""
  return _stomp.WeightedAngularCoordinate_AddField(*args)

class CosmoCoordinate(WeightedAngularCoordinate):
    """Proxy of C++ Stomp::CosmoCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [WeightedAngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosmoCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [WeightedAngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CosmoCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CosmoCoordinate
        __init__(self, double theta, double phi, double redshift, double weight, 
            Sphere sphere = Survey, bool radians = False) -> CosmoCoordinate
        __init__(self, double theta, double phi, double redshift, double weight, 
            Sphere sphere = Survey) -> CosmoCoordinate
        __init__(self, double theta, double phi, double redshift, double weight) -> CosmoCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            double redshift, double weight) -> CosmoCoordinate
        """
        this = _stomp.new_CosmoCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_CosmoCoordinate
    __del__ = lambda self : None;
    def ProjectedRadius(self, *args):
        """ProjectedRadius(self, AngularCoordinate ang) -> double"""
        return _stomp.CosmoCoordinate_ProjectedRadius(self, *args)

    def DotProduct(self, *args):
        """DotProduct(self, CosmoCoordinate ang) -> double"""
        return _stomp.CosmoCoordinate_DotProduct(self, *args)

    def ComovingDistance(self):
        """ComovingDistance(self) -> double"""
        return _stomp.CosmoCoordinate_ComovingDistance(self)

    def AngularDiameterDistance(self):
        """AngularDiameterDistance(self) -> double"""
        return _stomp.CosmoCoordinate_AngularDiameterDistance(self)

    def LuminosityDistance(self):
        """LuminosityDistance(self) -> double"""
        return _stomp.CosmoCoordinate_LuminosityDistance(self)

    def Redshift(self):
        """Redshift(self) -> double"""
        return _stomp.CosmoCoordinate_Redshift(self)

    def SetRedshift(self, *args):
        """SetRedshift(self, double redshift)"""
        return _stomp.CosmoCoordinate_SetRedshift(self, *args)

    def ToCosmoVector(*args):
        """
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, CosmoVector z_ang, 
            Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, CosmoVector z_ang, 
            Sphere sphere = Equatorial) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            DoubleVector weightVec, CosmoVector z_ang) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            double weight, CosmoVector z_ang, 
            Sphere sphere = Equatorial, bool radians = False) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            double weight, CosmoVector z_ang, 
            Sphere sphere = Equatorial) -> bool
        ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
            double weight, CosmoVector z_ang) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, uint8_t redshift_column = 2, 
            int8_t weight_column = -1) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, uint8_t redshift_column = 2) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial) -> bool
        ToCosmoVector(string input_file, CosmoVector z_ang) -> bool
        """
        return _stomp.CosmoCoordinate_ToCosmoVector(*args)

    if _newclass:ToCosmoVector = staticmethod(ToCosmoVector)
    __swig_getmethods__["ToCosmoVector"] = lambda x: ToCosmoVector
    def FromCosmoVector(*args):
        """
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector redshiftVec, DoubleVector weightVec, 
            Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector redshiftVec, DoubleVector weightVec, 
            Sphere sphere = Equatorial) -> bool
        FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            DoubleVector redshiftVec, DoubleVector weightVec) -> bool
        FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere = Equatorial) -> bool
        FromCosmoVector(CosmoVector z_ang, string output_file) -> bool
        """
        return _stomp.CosmoCoordinate_FromCosmoVector(*args)

    if _newclass:FromCosmoVector = staticmethod(FromCosmoVector)
    __swig_getmethods__["FromCosmoVector"] = lambda x: FromCosmoVector
CosmoCoordinate_swigregister = _stomp.CosmoCoordinate_swigregister
CosmoCoordinate_swigregister(CosmoCoordinate)

def CosmoCoordinate_ToCosmoVector(*args):
  """
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, CosmoVector z_ang, 
        Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, CosmoVector z_ang, 
        Sphere sphere = Equatorial) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        DoubleVector weightVec, CosmoVector z_ang) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        double weight, CosmoVector z_ang, 
        Sphere sphere = Equatorial, bool radians = False) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        double weight, CosmoVector z_ang, 
        Sphere sphere = Equatorial) -> bool
    ToCosmoVector(DoubleVector thetaVec, DoubleVector phiVec, DoubleVector redshiftVec, 
        double weight, CosmoVector z_ang) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1, uint8_t redshift_column = 2, 
        int8_t weight_column = -1) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1, uint8_t redshift_column = 2) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToCosmoVector(string input_file, CosmoVector z_ang, Sphere sphere = Equatorial) -> bool
    CosmoCoordinate_ToCosmoVector(string input_file, CosmoVector z_ang) -> bool
    """
  return _stomp.CosmoCoordinate_ToCosmoVector(*args)

def CosmoCoordinate_FromCosmoVector(*args):
  """
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector redshiftVec, DoubleVector weightVec, 
        Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector redshiftVec, DoubleVector weightVec, 
        Sphere sphere = Equatorial) -> bool
    FromCosmoVector(CosmoVector z_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        DoubleVector redshiftVec, DoubleVector weightVec) -> bool
    FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromCosmoVector(CosmoVector z_ang, string output_file, Sphere sphere = Equatorial) -> bool
    CosmoCoordinate_FromCosmoVector(CosmoVector z_ang, string output_file) -> bool
    """
  return _stomp.CosmoCoordinate_FromCosmoVector(*args)

class IndexedAngularCoordinate(AngularCoordinate):
    """Proxy of C++ Stomp::IndexedAngularCoordinate class"""
    __swig_setmethods__ = {}
    for _s in [AngularCoordinate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedAngularCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [AngularCoordinate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedAngularCoordinate, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IndexedAngularCoordinate
        __init__(self, double theta, double phi, uint32_t index, Sphere sphere = Survey, 
            bool radians = False) -> IndexedAngularCoordinate
        __init__(self, double theta, double phi, uint32_t index, Sphere sphere = Survey) -> IndexedAngularCoordinate
        __init__(self, double theta, double phi, uint32_t index) -> IndexedAngularCoordinate
        __init__(self, double unit_sphere_x, double unit_sphere_y, double unit_sphere_z, 
            uint32_t index) -> IndexedAngularCoordinate
        """
        this = _stomp.new_IndexedAngularCoordinate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedAngularCoordinate
    __del__ = lambda self : None;
    def SetIndex(self, *args):
        """SetIndex(self, uint32_t index)"""
        return _stomp.IndexedAngularCoordinate_SetIndex(self, *args)

    def Index(self):
        """Index(self) -> uint32_t"""
        return _stomp.IndexedAngularCoordinate_Index(self)

    def ToIAngularVector(*args):
        """
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            IAngularVector i_ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            IAngularVector i_ang, Sphere sphere = Equatorial) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
            IAngularVector i_ang) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
            Sphere sphere = Equatorial, bool radians = False) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
            Sphere sphere = Equatorial) -> bool
        ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, 
            int8_t index_column = -1) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
            bool radians = False, uint8_t theta_column = 0) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial) -> bool
        ToIAngularVector(string input_file, IAngularVector i_ang) -> bool
        """
        return _stomp.IndexedAngularCoordinate_ToIAngularVector(*args)

    if _newclass:ToIAngularVector = staticmethod(ToIAngularVector)
    __swig_getmethods__["ToIAngularVector"] = lambda x: ToIAngularVector
    def FromIAngularVector(*args):
        """
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            IndexVector indexVec, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            IndexVector indexVec, Sphere sphere = Equatorial) -> bool
        FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
            IndexVector indexVec) -> bool
        FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere = Equatorial, 
            bool radians = False) -> bool
        FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere = Equatorial) -> bool
        FromIAngularVector(IAngularVector i_ang, string output_file) -> bool
        """
        return _stomp.IndexedAngularCoordinate_FromIAngularVector(*args)

    if _newclass:FromIAngularVector = staticmethod(FromIAngularVector)
    __swig_getmethods__["FromIAngularVector"] = lambda x: FromIAngularVector
IndexedAngularCoordinate_swigregister = _stomp.IndexedAngularCoordinate_swigregister
IndexedAngularCoordinate_swigregister(IndexedAngularCoordinate)

def IndexedAngularCoordinate_ToIAngularVector(*args):
  """
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        IAngularVector i_ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        IAngularVector i_ang, Sphere sphere = Equatorial) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IndexVector indexVec, 
        IAngularVector i_ang) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
        Sphere sphere = Equatorial, bool radians = False) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang, 
        Sphere sphere = Equatorial) -> bool
    ToIAngularVector(DoubleVector thetaVec, DoubleVector phiVec, IAngularVector i_ang) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1, 
        int8_t index_column = -1) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0, 
        uint8_t phi_column = 1) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
        bool radians = False, uint8_t theta_column = 0) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    ToIAngularVector(string input_file, IAngularVector i_ang, Sphere sphere = Equatorial) -> bool
    IndexedAngularCoordinate_ToIAngularVector(string input_file, IAngularVector i_ang) -> bool
    """
  return _stomp.IndexedAngularCoordinate_ToIAngularVector(*args)

def IndexedAngularCoordinate_FromIAngularVector(*args):
  """
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        IndexVector indexVec, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        IndexVector indexVec, Sphere sphere = Equatorial) -> bool
    FromIAngularVector(IAngularVector i_ang, DoubleVector thetaVec, DoubleVector phiVec, 
        IndexVector indexVec) -> bool
    FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere = Equatorial, 
        bool radians = False) -> bool
    FromIAngularVector(IAngularVector i_ang, string output_file, Sphere sphere = Equatorial) -> bool
    IndexedAngularCoordinate_FromIAngularVector(IAngularVector i_ang, string output_file) -> bool
    """
  return _stomp.IndexedAngularCoordinate_FromIAngularVector(*args)

class TreePixel(Pixel):
    """Proxy of C++ Stomp::TreePixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TreePixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> TreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum, uint16_t maximum_points = 200) -> TreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> TreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, uint16_t maximum_points = 200) -> TreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> TreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, uint16_t maximum_points = 200) -> TreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> TreePixel
        """
        this = _stomp.new_TreePixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreePixel
    __del__ = lambda self : None;
    def _InitializeSubPixels(self):
        """_InitializeSubPixels(self) -> bool"""
        return _stomp.TreePixel__InitializeSubPixels(self)

    def DirectPairCount(self, *args):
        """
        DirectPairCount(self, AngularCoordinate ang, AngularBin theta, int16_t region = -1) -> uint32_t
        DirectPairCount(self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        """
        return _stomp.TreePixel_DirectPairCount(self, *args)

    def FindPairs(self, *args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta, int16_t region = -1) -> uint32_t
        FindPairs(self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_max) -> uint32_t
        FindPairs(self, AngularVector ang, AngularBin theta, int16_t region = -1)
        FindPairs(self, AngularVector ang, AngularBin theta)
        FindPairs(self, AngularVector ang, AngularCorrelation wtheta, int16_t region = -1)
        FindPairs(self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreePixel_FindPairs(self, *args)

    def DirectWeightedPairs(self, *args):
        """
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta, int16_t region = -1) -> double
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            int16_t region = -1) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name, 
            int16_t region = -1) -> double
        DirectWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name, int16_t region = -1) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name, int16_t region = -1) -> double
        DirectWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name) -> double
        """
        return _stomp.TreePixel_DirectWeightedPairs(self, *args)

    def FindWeightedPairs(self, *args):
        """
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, int16_t region = -1) -> double
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            int16_t region = -1) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, int16_t region = -1)
        FindWeightedPairs(self, AngularVector ang, AngularBin theta)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, int16_t region = -1)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, int16_t region = -1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, int16_t region = -1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name, 
            int16_t region = -1) -> double
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max, string field_name) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, string field_name, 
            int16_t region = -1)
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, string field_name, 
            int16_t region = -1)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name, int16_t region = -1) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, string field_name, 
            int16_t region = -1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name, 
            int16_t region = -1)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name, int16_t region = -1) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_min, double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name, int16_t region = -1)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name, int16_t region = -1)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name)
        """
        return _stomp.TreePixel_FindWeightedPairs(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, WAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.TreePixel_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(self, AngularCoordinate ang, WeightedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.TreePixel_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.TreePixel_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.TreePixel_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, WeightedAngularCoordinate match_ang) -> bool"""
        return _stomp.TreePixel_ClosestMatch(self, *args)

    def InitializeCorners(self):
        """InitializeCorners(self)"""
        return _stomp.TreePixel_InitializeCorners(self)

    def AddPoint(self, *args):
        """
        AddPoint(self, WeightedAngularCoordinate w_ang) -> bool
        AddPoint(self, AngularCoordinate ang, double object_weight = 1.0) -> bool
        AddPoint(self, AngularCoordinate ang) -> bool
        """
        return _stomp.TreePixel_AddPoint(self, *args)

    def NPoints(self, *args):
        """
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.TreePixel_NPoints(self, *args)

    def PixelWeight(self, *args):
        """PixelWeight(self, Pixel pix) -> double"""
        return _stomp.TreePixel_PixelWeight(self, *args)

    def Coverage(self, *args):
        """
        Coverage(self) -> double
        Coverage(self, Pixel pix) -> double
        """
        return _stomp.TreePixel_Coverage(self, *args)

    def Points(self, *args):
        """
        Points(self, WAngularVector w_ang)
        Points(self, WAngularVector w_ang, Pixel pix)
        """
        return _stomp.TreePixel_Points(self, *args)

    def Nodes(self):
        """Nodes(self) -> uint16_t"""
        return _stomp.TreePixel_Nodes(self)

    def AddToWeight(self, *args):
        """AddToWeight(self, double weight)"""
        return _stomp.TreePixel_AddToWeight(self, *args)

    def FieldTotal(self, *args):
        """
        FieldTotal(self, string field_name) -> double
        FieldTotal(self, string field_name, Pixel pix) -> double
        """
        return _stomp.TreePixel_FieldTotal(self, *args)

    def AddToField(self, *args):
        """AddToField(self, string field_name, double weight)"""
        return _stomp.TreePixel_AddToField(self, *args)

    def NField(self):
        """NField(self) -> uint16_t"""
        return _stomp.TreePixel_NField(self)

    def HasFields(self):
        """HasFields(self) -> bool"""
        return _stomp.TreePixel_HasFields(self)

    def FieldNames(self, *args):
        """FieldNames(self, std::vector<(std::string,std::allocator<(std::string)>)> field_names)"""
        return _stomp.TreePixel_FieldNames(self, *args)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(self, uint16_t maximum_points)"""
        return _stomp.TreePixel_SetPixelCapacity(self, *args)

    def PixelCapacity(self):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.TreePixel_PixelCapacity(self)

    def HasPoints(self):
        """HasPoints(self) -> bool"""
        return _stomp.TreePixel_HasPoints(self)

    def HasNodes(self):
        """HasNodes(self) -> bool"""
        return _stomp.TreePixel_HasNodes(self)

    def Clear(self):
        """Clear(self)"""
        return _stomp.TreePixel_Clear(self)

    def UnitSphereX(self):
        """UnitSphereX(self) -> double"""
        return _stomp.TreePixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(self) -> double"""
        return _stomp.TreePixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ(self)

    def UnitSphereX_UL(self):
        """UnitSphereX_UL(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_UL(self)

    def UnitSphereY_UL(self):
        """UnitSphereY_UL(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_UL(self)

    def UnitSphereZ_UL(self):
        """UnitSphereZ_UL(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_UL(self)

    def UnitSphereX_UR(self):
        """UnitSphereX_UR(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_UR(self)

    def UnitSphereY_UR(self):
        """UnitSphereY_UR(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_UR(self)

    def UnitSphereZ_UR(self):
        """UnitSphereZ_UR(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_UR(self)

    def UnitSphereX_LL(self):
        """UnitSphereX_LL(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_LL(self)

    def UnitSphereY_LL(self):
        """UnitSphereY_LL(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_LL(self)

    def UnitSphereZ_LL(self):
        """UnitSphereZ_LL(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_LL(self)

    def UnitSphereX_LR(self):
        """UnitSphereX_LR(self) -> double"""
        return _stomp.TreePixel_UnitSphereX_LR(self)

    def UnitSphereY_LR(self):
        """UnitSphereY_LR(self) -> double"""
        return _stomp.TreePixel_UnitSphereY_LR(self)

    def UnitSphereZ_LR(self):
        """UnitSphereZ_LR(self) -> double"""
        return _stomp.TreePixel_UnitSphereZ_LR(self)

    def WithinAnnulus(self, *args):
        """WithinAnnulus(self, AngularBin theta, PixelVector pix, bool check_full_pixel)"""
        return _stomp.TreePixel_WithinAnnulus(self, *args)

TreePixel_swigregister = _stomp.TreePixel_swigregister
TreePixel_swigregister(TreePixel)

class NearestNeighborPixel(_object):
    """Proxy of C++ Stomp::NearestNeighborPixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborPixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborPixel, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, DistancePixelPair x, DistancePixelPair y) -> int"""
        return _stomp.NearestNeighborPixel___call__(self, *args)

    def __init__(self): 
        """__init__(self) -> NearestNeighborPixel"""
        this = _stomp.new_NearestNeighborPixel()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborPixel
    __del__ = lambda self : None;
NearestNeighborPixel_swigregister = _stomp.NearestNeighborPixel_swigregister
NearestNeighborPixel_swigregister(NearestNeighborPixel)

class NearestNeighborPoint(_object):
    """Proxy of C++ Stomp::NearestNeighborPoint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborPoint, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, DistancePointPair x, DistancePointPair y) -> int"""
        return _stomp.NearestNeighborPoint___call__(self, *args)

    def __init__(self): 
        """__init__(self) -> NearestNeighborPoint"""
        this = _stomp.new_NearestNeighborPoint()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborPoint
    __del__ = lambda self : None;
NearestNeighborPoint_swigregister = _stomp.NearestNeighborPoint_swigregister
NearestNeighborPoint_swigregister(NearestNeighborPoint)

class TreeNeighbor(_object):
    """Proxy of C++ Stomp::TreeNeighbor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeNeighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeNeighbor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate reference_ang, uint8_t n_neighbors = 1) -> TreeNeighbor
        __init__(self, AngularCoordinate reference_ang) -> TreeNeighbor
        """
        this = _stomp.new_TreeNeighbor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreeNeighbor
    __del__ = lambda self : None;
    def NearestNeighbors(self, *args):
        """
        NearestNeighbors(self, WAngularVector w_ang, bool save_neighbors = True)
        NearestNeighbors(self, WAngularVector w_ang)
        """
        return _stomp.TreeNeighbor_NearestNeighbors(self, *args)

    def Neighbors(self):
        """Neighbors(self) -> uint8_t"""
        return _stomp.TreeNeighbor_Neighbors(self)

    def MaxNeighbors(self):
        """MaxNeighbors(self) -> uint8_t"""
        return _stomp.TreeNeighbor_MaxNeighbors(self)

    def TestPoint(self, *args):
        """TestPoint(self, WeightedAngularCoordinate test_ang) -> bool"""
        return _stomp.TreeNeighbor_TestPoint(self, *args)

    def MaxDistance(self):
        """MaxDistance(self) -> double"""
        return _stomp.TreeNeighbor_MaxDistance(self)

    def MaxAngularDistance(self):
        """MaxAngularDistance(self) -> double"""
        return _stomp.TreeNeighbor_MaxAngularDistance(self)

    def NodesVisited(self):
        """NodesVisited(self) -> uint16_t"""
        return _stomp.TreeNeighbor_NodesVisited(self)

    def AddNode(self):
        """AddNode(self)"""
        return _stomp.TreeNeighbor_AddNode(self)

TreeNeighbor_swigregister = _stomp.TreeNeighbor_swigregister
TreeNeighbor_swigregister(TreeNeighbor)

class IndexedTreePixel(Pixel):
    """Proxy of C++ Stomp::IndexedTreePixel class"""
    __swig_setmethods__ = {}
    for _s in [Pixel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreePixel, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreePixel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IndexedTreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum, uint16_t maximum_points = 200) -> IndexedTreePixel
        __init__(self, uint32_t resolution, uint32_t pixnum) -> IndexedTreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution, uint16_t maximum_points = 200) -> IndexedTreePixel
        __init__(self, AngularCoordinate ang, uint32_t resolution) -> IndexedTreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution, uint16_t maximum_points = 200) -> IndexedTreePixel
        __init__(self, uint32_t x, uint32_t y, uint32_t resolution) -> IndexedTreePixel
        """
        this = _stomp.new_IndexedTreePixel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreePixel
    __del__ = lambda self : None;
    def FindPairs(self, *args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IAngularVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IndexVector pair_indices)
        """
        return _stomp.IndexedTreePixel_FindPairs(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, IAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.IndexedTreePixel_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(self, AngularCoordinate ang, IndexedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.IndexedTreePixel_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreePixel_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreePixel_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, IndexedAngularCoordinate match_ang) -> bool"""
        return _stomp.IndexedTreePixel_ClosestMatch(self, *args)

    def InitializeCorners(self):
        """InitializeCorners(self)"""
        return _stomp.IndexedTreePixel_InitializeCorners(self)

    def AddPoint(self, *args):
        """
        AddPoint(self, IndexedAngularCoordinate w_ang) -> bool
        AddPoint(self, AngularCoordinate ang, uint32_t index) -> bool
        """
        return _stomp.IndexedTreePixel_AddPoint(self, *args)

    def NPoints(self, *args):
        """
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.IndexedTreePixel_NPoints(self, *args)

    def Indices(self, *args):
        """Indices(self, Pixel pix, IndexVector indices)"""
        return _stomp.IndexedTreePixel_Indices(self, *args)

    def Coverage(self, *args):
        """
        Coverage(self) -> double
        Coverage(self, Pixel pix) -> double
        """
        return _stomp.IndexedTreePixel_Coverage(self, *args)

    def Points(self, *args):
        """
        Points(self, IAngularVector i_ang)
        Points(self, IAngularVector i_ang, Pixel pix)
        """
        return _stomp.IndexedTreePixel_Points(self, *args)

    def Nodes(self):
        """Nodes(self) -> uint16_t"""
        return _stomp.IndexedTreePixel_Nodes(self)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(self, uint16_t maximum_points)"""
        return _stomp.IndexedTreePixel_SetPixelCapacity(self, *args)

    def PixelCapacity(self):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.IndexedTreePixel_PixelCapacity(self)

    def HasPoints(self):
        """HasPoints(self) -> bool"""
        return _stomp.IndexedTreePixel_HasPoints(self)

    def HasNodes(self):
        """HasNodes(self) -> bool"""
        return _stomp.IndexedTreePixel_HasNodes(self)

    def Clear(self):
        """Clear(self)"""
        return _stomp.IndexedTreePixel_Clear(self)

    def UnitSphereX(self):
        """UnitSphereX(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX(self)

    def UnitSphereY(self):
        """UnitSphereY(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY(self)

    def UnitSphereZ(self):
        """UnitSphereZ(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ(self)

    def UnitSphereX_UL(self):
        """UnitSphereX_UL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_UL(self)

    def UnitSphereY_UL(self):
        """UnitSphereY_UL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_UL(self)

    def UnitSphereZ_UL(self):
        """UnitSphereZ_UL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_UL(self)

    def UnitSphereX_UR(self):
        """UnitSphereX_UR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_UR(self)

    def UnitSphereY_UR(self):
        """UnitSphereY_UR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_UR(self)

    def UnitSphereZ_UR(self):
        """UnitSphereZ_UR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_UR(self)

    def UnitSphereX_LL(self):
        """UnitSphereX_LL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_LL(self)

    def UnitSphereY_LL(self):
        """UnitSphereY_LL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_LL(self)

    def UnitSphereZ_LL(self):
        """UnitSphereZ_LL(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_LL(self)

    def UnitSphereX_LR(self):
        """UnitSphereX_LR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereX_LR(self)

    def UnitSphereY_LR(self):
        """UnitSphereY_LR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereY_LR(self)

    def UnitSphereZ_LR(self):
        """UnitSphereZ_LR(self) -> double"""
        return _stomp.IndexedTreePixel_UnitSphereZ_LR(self)

    def WithinAnnulus(self, *args):
        """WithinAnnulus(self, AngularBin theta, PixelVector pix, bool check_full_pixel)"""
        return _stomp.IndexedTreePixel_WithinAnnulus(self, *args)

IndexedTreePixel_swigregister = _stomp.IndexedTreePixel_swigregister
IndexedTreePixel_swigregister(IndexedTreePixel)

class NearestNeighborIndexedPixel(_object):
    """Proxy of C++ Stomp::NearestNeighborIndexedPixel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborIndexedPixel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborIndexedPixel, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, DistanceIPixelPair x, DistanceIPixelPair y) -> int"""
        return _stomp.NearestNeighborIndexedPixel___call__(self, *args)

    def __init__(self): 
        """__init__(self) -> NearestNeighborIndexedPixel"""
        this = _stomp.new_NearestNeighborIndexedPixel()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborIndexedPixel
    __del__ = lambda self : None;
NearestNeighborIndexedPixel_swigregister = _stomp.NearestNeighborIndexedPixel_swigregister
NearestNeighborIndexedPixel_swigregister(NearestNeighborIndexedPixel)

class NearestNeighborIndexedPoint(_object):
    """Proxy of C++ Stomp::NearestNeighborIndexedPoint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NearestNeighborIndexedPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NearestNeighborIndexedPoint, name)
    __repr__ = _swig_repr
    def __call__(self, *args):
        """__call__(self, DistanceIPointPair x, DistanceIPointPair y) -> int"""
        return _stomp.NearestNeighborIndexedPoint___call__(self, *args)

    def __init__(self): 
        """__init__(self) -> NearestNeighborIndexedPoint"""
        this = _stomp.new_NearestNeighborIndexedPoint()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_NearestNeighborIndexedPoint
    __del__ = lambda self : None;
NearestNeighborIndexedPoint_swigregister = _stomp.NearestNeighborIndexedPoint_swigregister
NearestNeighborIndexedPoint_swigregister(NearestNeighborIndexedPoint)

class IndexedTreeNeighbor(_object):
    """Proxy of C++ Stomp::IndexedTreeNeighbor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreeNeighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreeNeighbor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, AngularCoordinate reference_ang, uint8_t n_neighbors = 1) -> IndexedTreeNeighbor
        __init__(self, AngularCoordinate reference_ang) -> IndexedTreeNeighbor
        __init__(self, AngularCoordinate reference_ang, uint8_t n_neighbors, 
            double max_distance) -> IndexedTreeNeighbor
        """
        this = _stomp.new_IndexedTreeNeighbor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreeNeighbor
    __del__ = lambda self : None;
    def NearestNeighbors(self, *args):
        """
        NearestNeighbors(self, IAngularVector i_ang, bool save_neighbors = True)
        NearestNeighbors(self, IAngularVector i_ang)
        """
        return _stomp.IndexedTreeNeighbor_NearestNeighbors(self, *args)

    def Neighbors(self):
        """Neighbors(self) -> uint8_t"""
        return _stomp.IndexedTreeNeighbor_Neighbors(self)

    def MaxNeighbors(self):
        """MaxNeighbors(self) -> uint8_t"""
        return _stomp.IndexedTreeNeighbor_MaxNeighbors(self)

    def TestPoint(self, *args):
        """TestPoint(self, IndexedAngularCoordinate test_ang) -> bool"""
        return _stomp.IndexedTreeNeighbor_TestPoint(self, *args)

    def MaxDistance(self):
        """MaxDistance(self) -> double"""
        return _stomp.IndexedTreeNeighbor_MaxDistance(self)

    def MaxAngularDistance(self):
        """MaxAngularDistance(self) -> double"""
        return _stomp.IndexedTreeNeighbor_MaxAngularDistance(self)

    def NodesVisited(self):
        """NodesVisited(self) -> uint16_t"""
        return _stomp.IndexedTreeNeighbor_NodesVisited(self)

    def AddNode(self):
        """AddNode(self)"""
        return _stomp.IndexedTreeNeighbor_AddNode(self)

IndexedTreeNeighbor_swigregister = _stomp.IndexedTreeNeighbor_swigregister
IndexedTreeNeighbor_swigregister(IndexedTreeNeighbor)

class TreeMap(BaseMap):
    """Proxy of C++ Stomp::TreeMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TreeMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, uint32_t resolution = HPixResolution, uint16_t maximum_points = 50) -> TreeMap
        __init__(self, uint32_t resolution = HPixResolution) -> TreeMap
        __init__(self) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, 
            int8_t weight_column = -1) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50) -> TreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution) -> TreeMap
        __init__(self, string input_file) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, 
            Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, int8_t weight_column = -1) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, 
            Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, 
            Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, 
            Sphere sphere = Equatorial, 
            bool verbose = False) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, 
            Sphere sphere = Equatorial) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns, uint32_t resolution = HPixResolution) -> TreeMap
        __init__(self, string input_file, FieldColumnDict field_columns) -> TreeMap
        """
        this = _stomp.new_TreeMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_TreeMap
    __del__ = lambda self : None;
    def FindPairs(self, *args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> uint32_t
        FindPairs(self, AngularCoordinate ang, double theta_max) -> uint32_t
        FindPairs(self, AngularVector ang, AngularBin theta)
        FindPairs(self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreeMap_FindPairs(self, *args)

    def FindWeightedPairs(self, *args):
        """
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max) -> double
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairs(self, AngularCoordinate ang, AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, AngularCoordinate ang, double theta_max, string field_name) -> double
        FindWeightedPairs(self, AngularVector ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, AngularVector ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, AngularBin theta, 
            string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_min, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, double theta_max, 
            string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, AngularBin theta, string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            AngularBin theta, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_min, double theta_max, string field_name) -> double
        FindWeightedPairs(self, WeightedAngularCoordinate w_ang, string ang_field_name, 
            double theta_max, string field_name) -> double
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name)
        FindWeightedPairs(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name)
        """
        return _stomp.TreeMap_FindWeightedPairs(self, *args)

    def FindPairsWithRegions(self, *args):
        """
        FindPairsWithRegions(self, AngularVector ang, AngularBin theta)
        FindPairsWithRegions(self, AngularVector ang, AngularCorrelation wtheta)
        """
        return _stomp.TreeMap_FindPairsWithRegions(self, *args)

    def FindWeightedPairsWithRegions(self, *args):
        """
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularBin theta)
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularCorrelation wtheta)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularBin theta)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularCorrelation wtheta)
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularBin theta, string field_name)
        FindWeightedPairsWithRegions(self, AngularVector ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularBin theta, string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, AngularCorrelation wtheta, string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, string ang_field_name, AngularBin theta, 
            string field_name)
        FindWeightedPairsWithRegions(self, WAngularVector w_ang, string ang_field_name, AngularCorrelation wtheta, 
            string field_name)
        """
        return _stomp.TreeMap_FindWeightedPairsWithRegions(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, WAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.TreeMap_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(self, AngularCoordinate ang, WeightedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.TreeMap_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.TreeMap_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.TreeMap_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, WeightedAngularCoordinate match_ang) -> bool"""
        return _stomp.TreeMap_ClosestMatch(self, *args)

    def AddPoint(self, *args):
        """
        AddPoint(self, WeightedAngularCoordinate w_ang) -> bool
        AddPoint(self, AngularCoordinate ang, double object_weight = 1.0) -> bool
        AddPoint(self, AngularCoordinate ang) -> bool
        """
        return _stomp.TreeMap_AddPoint(self, *args)

    def Read(self, *args):
        """
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False, 
            uint8_t theta_column = 0, uint8_t phi_column = 1, 
            int8_t weight_column = -1) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False, 
            uint8_t theta_column = 0, uint8_t phi_column = 1) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False, 
            uint8_t theta_column = 0) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial) -> bool
        Read(self, string input_file) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere = Equatorial, 
            bool verbose = False, 
            uint8_t theta_column = 0, uint8_t phi_column = 1, 
            int8_t weight_column = -1) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere = Equatorial, 
            bool verbose = False, 
            uint8_t theta_column = 0, uint8_t phi_column = 1) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere = Equatorial, 
            bool verbose = False, 
            uint8_t theta_column = 0) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere = Equatorial, 
            bool verbose = False) -> bool
        Read(self, string input_file, FieldColumnDict field_columns, Sphere sphere = Equatorial) -> bool
        Read(self, string input_file, FieldColumnDict field_columns) -> bool
        """
        return _stomp.TreeMap_Read(self, *args)

    def Coverage(self, *args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.TreeMap_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.TreeMap_Covering(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.TreeMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.TreeMap_FindUnmaskedStatus(self, *args)

    def NodeMap(self, *args):
        """NodeMap(self, Map stomp_map)"""
        return _stomp.TreeMap_NodeMap(self, *args)

    def Resolution(self):
        """Resolution(self) -> uint32_t"""
        return _stomp.TreeMap_Resolution(self)

    def PixelCapacity(self):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.TreeMap_PixelCapacity(self)

    def SetResolution(self, *args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.TreeMap_SetResolution(self, *args)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(self, int pixel_capacity)"""
        return _stomp.TreeMap_SetPixelCapacity(self, *args)

    def NPoints(self, *args):
        """
        NPoints(self, uint32_t k = MaxPixnum) -> uint32_t
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.TreeMap_NPoints(self, *args)

    def Points(self, *args):
        """
        Points(self, WAngularVector w_ang)
        Points(self, WAngularVector w_ang, Pixel pix)
        """
        return _stomp.TreeMap_Points(self, *args)

    def Weight(self, *args):
        """
        Weight(self, uint32_t k = MaxPixnum) -> double
        Weight(self) -> double
        Weight(self, Pixel pix) -> double
        """
        return _stomp.TreeMap_Weight(self, *args)

    def FieldTotal(self, *args):
        """
        FieldTotal(self, string field_name, uint32_t k = MaxPixnum) -> double
        FieldTotal(self, string field_name) -> double
        FieldTotal(self, string field_name, Pixel pix) -> double
        """
        return _stomp.TreeMap_FieldTotal(self, *args)

    def NField(self):
        """NField(self) -> uint16_t"""
        return _stomp.TreeMap_NField(self)

    def HasFields(self):
        """HasFields(self) -> bool"""
        return _stomp.TreeMap_HasFields(self)

    def FieldNames(self, *args):
        """FieldNames(self, std::vector<(std::string,std::allocator<(std::string)>)> field_names)"""
        return _stomp.TreeMap_FieldNames(self, *args)

    def BaseNodes(self):
        """BaseNodes(self) -> uint16_t"""
        return _stomp.TreeMap_BaseNodes(self)

    def Nodes(self):
        """Nodes(self) -> uint16_t"""
        return _stomp.TreeMap_Nodes(self)

    def Size(self):
        """Size(self) -> uint32_t"""
        return _stomp.TreeMap_Size(self)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.TreeMap_Area(self)

    def CalculateArea(self):
        """CalculateArea(self)"""
        return _stomp.TreeMap_CalculateArea(self)

    def MinResolution(self):
        """MinResolution(self) -> uint32_t"""
        return _stomp.TreeMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.TreeMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(self) -> uint8_t"""
        return _stomp.TreeMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.TreeMap_MaxLevel(self)

    def Empty(self):
        """Empty(self) -> bool"""
        return _stomp.TreeMap_Empty(self)

    def Clear(self):
        """Clear(self)"""
        return _stomp.TreeMap_Clear(self)

TreeMap_swigregister = _stomp.TreeMap_swigregister
TreeMap_swigregister(TreeMap)

class IndexedTreeMap(BaseMap):
    """Proxy of C++ Stomp::IndexedTreeMap class"""
    __swig_setmethods__ = {}
    for _s in [BaseMap]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedTreeMap, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseMap]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedTreeMap, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, uint32_t resolution = HPixResolution, uint16_t maximum_points = 50) -> IndexedTreeMap
        __init__(self, uint32_t resolution = HPixResolution) -> IndexedTreeMap
        __init__(self) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1, 
            int8_t index_column = -1) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0, 
            uint8_t phi_column = 1) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False, uint8_t theta_column = 0) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial, 
            bool verbose = False) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50, Sphere sphere = Equatorial) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution, 
            uint16_t maximum_points = 50) -> IndexedTreeMap
        __init__(self, string input_file, uint32_t resolution = HPixResolution) -> IndexedTreeMap
        __init__(self, string input_file) -> IndexedTreeMap
        """
        this = _stomp.new_IndexedTreeMap(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _stomp.delete_IndexedTreeMap
    __del__ = lambda self : None;
    def FindPairs(self, *args):
        """
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, AngularBin theta, IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IAngularVector i_angVec)
        FindPairs(self, AngularCoordinate ang, double theta_min, double theta_max, 
            IndexVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IAngularVector pair_indices)
        FindPairs(self, AngularCoordinate ang, double theta_max, IndexVector pair_indices)
        """
        return _stomp.IndexedTreeMap_FindPairs(self, *args)

    def FindKNearestNeighbors(self, *args):
        """FindKNearestNeighbors(self, AngularCoordinate ang, uint8_t n_neighbors, IAngularVector neighbors_ang) -> uint16_t"""
        return _stomp.IndexedTreeMap_FindKNearestNeighbors(self, *args)

    def FindNearestNeighbor(self, *args):
        """FindNearestNeighbor(self, AngularCoordinate ang, IndexedAngularCoordinate neighbor_ang) -> uint16_t"""
        return _stomp.IndexedTreeMap_FindNearestNeighbor(self, *args)

    def KNearestNeighborDistance(self, *args):
        """KNearestNeighborDistance(self, AngularCoordinate ang, uint8_t n_neighbors, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreeMap_KNearestNeighborDistance(self, *args)

    def NearestNeighborDistance(self, *args):
        """NearestNeighborDistance(self, AngularCoordinate ang, uint16_t nodes_visited) -> double"""
        return _stomp.IndexedTreeMap_NearestNeighborDistance(self, *args)

    def ClosestMatch(self, *args):
        """ClosestMatch(self, AngularCoordinate ang, double max_distance, IndexedAngularCoordinate match_ang) -> bool"""
        return _stomp.IndexedTreeMap_ClosestMatch(self, *args)

    def AddPoint(self, *args):
        """
        AddPoint(self, IndexedAngularCoordinate i_ang) -> bool
        AddPoint(self, AngularCoordinate ang, uint32_t index) -> bool
        """
        return _stomp.IndexedTreeMap_AddPoint(self, *args)

    def Read(self, *args):
        """
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False, 
            uint8_t theta_column = 0, uint8_t phi_column = 1, 
            int8_t index_column = -1) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False, 
            uint8_t theta_column = 0, uint8_t phi_column = 1) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False, 
            uint8_t theta_column = 0) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial, bool verbose = False) -> bool
        Read(self, string input_file, Sphere sphere = Equatorial) -> bool
        Read(self, string input_file) -> bool
        """
        return _stomp.IndexedTreeMap_Read(self, *args)

    def Coverage(self, *args):
        """
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution, 
            bool calculate_fraction = True)
        Coverage(self, PixelVector superpix, uint32_t resolution = HPixResolution)
        Coverage(self, PixelVector superpix)
        """
        return _stomp.IndexedTreeMap_Coverage(self, *args)

    def Covering(self, *args):
        """Covering(self, Map stomp_map, uint32_t maximum_pixels) -> bool"""
        return _stomp.IndexedTreeMap_Covering(self, *args)

    def FindUnmaskedFraction(self, *args):
        """FindUnmaskedFraction(self, Pixel pix) -> double"""
        return _stomp.IndexedTreeMap_FindUnmaskedFraction(self, *args)

    def FindUnmaskedStatus(self, *args):
        """FindUnmaskedStatus(self, Pixel pix) -> int8_t"""
        return _stomp.IndexedTreeMap_FindUnmaskedStatus(self, *args)

    def NodeMap(self, *args):
        """NodeMap(self, Map stomp_map)"""
        return _stomp.IndexedTreeMap_NodeMap(self, *args)

    def Resolution(self):
        """Resolution(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_Resolution(self)

    def PixelCapacity(self):
        """PixelCapacity(self) -> uint16_t"""
        return _stomp.IndexedTreeMap_PixelCapacity(self)

    def SetResolution(self, *args):
        """SetResolution(self, uint32_t resolution)"""
        return _stomp.IndexedTreeMap_SetResolution(self, *args)

    def SetPixelCapacity(self, *args):
        """SetPixelCapacity(self, int pixel_capacity)"""
        return _stomp.IndexedTreeMap_SetPixelCapacity(self, *args)

    def NPoints(self, *args):
        """
        NPoints(self, uint32_t k = MaxPixnum) -> uint32_t
        NPoints(self) -> uint32_t
        NPoints(self, Pixel pix) -> uint32_t
        """
        return _stomp.IndexedTreeMap_NPoints(self, *args)

    def Points(self, *args):
        """
        Points(self, IAngularVector i_ang)
        Points(self, IAngularVector i_ang, Pixel pix)
        """
        return _stomp.IndexedTreeMap_Points(self, *args)

    def Indices(self, *args):
        """Indices(self, Pixel pix, IndexVector indices)"""
        return _stomp.IndexedTreeMap_Indices(self, *args)

    def BaseNodes(self):
        """BaseNodes(self) -> uint16_t"""
        return _stomp.IndexedTreeMap_BaseNodes(self)

    def Nodes(self):
        """Nodes(self) -> uint16_t"""
        return _stomp.IndexedTreeMap_Nodes(self)

    def Size(self):
        """Size(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_Size(self)

    def Area(self):
        """Area(self) -> double"""
        return _stomp.IndexedTreeMap_Area(self)

    def CalculateArea(self):
        """CalculateArea(self)"""
        return _stomp.IndexedTreeMap_CalculateArea(self)

    def MinResolution(self):
        """MinResolution(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_MinResolution(self)

    def MaxResolution(self):
        """MaxResolution(self) -> uint32_t"""
        return _stomp.IndexedTreeMap_MaxResolution(self)

    def MinLevel(self):
        """MinLevel(self) -> uint8_t"""
        return _stomp.IndexedTreeMap_MinLevel(self)

    def MaxLevel(self):
        """MaxLevel(self) -> uint8_t"""
        return _stomp.IndexedTreeMap_MaxLevel(self)

    def Empty(self):
        """Empty(self) -> bool"""
        return _stomp.IndexedTreeMap_Empty(self)

    def Clear(self):
        """Clear(self)"""
        return _stomp.IndexedTreeMap_Clear(self)

IndexedTreeMap_swigregister = _stomp.IndexedTreeMap_swigregister
IndexedTreeMap_swigregister(IndexedTreeMap)

class AngularVector(_object):
    """Proxy of C++ std::vector<(Stomp::AngularCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngularVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.AngularVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.AngularVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.AngularVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.AngularVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.AngularVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> AngularVector"""
        return _stomp.AngularVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, AngularVector v = std::vector< Stomp::AngularCoordinate,std::allocator< Stomp::AngularCoordinate > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.AngularVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.AngularVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.AngularVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> AngularVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.AngularVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, AngularVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.AngularVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.AngularVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.AngularVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.AngularVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.AngularVector_clear(self)

    def swap(self, *args):
        """swap(self, AngularVector v)"""
        return _stomp.AngularVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.AngularVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.AngularVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.AngularVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.AngularVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.AngularVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.AngularVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.AngularVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> AngularVector
        __init__(self, AngularVector arg0) -> AngularVector
        __init__(self, size_type size) -> AngularVector
        __init__(self, size_type size, value_type value) -> AngularVector
        """
        this = _stomp.new_AngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.AngularVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.AngularVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.AngularVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.AngularVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.AngularVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.AngularVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.AngularVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.AngularVector_capacity(self)

    __swig_destroy__ = _stomp.delete_AngularVector
    __del__ = lambda self : None;
AngularVector_swigregister = _stomp.AngularVector_swigregister
AngularVector_swigregister(AngularVector)

class ThetaVector(_object):
    """Proxy of C++ std::vector<(Stomp::AngularBin)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThetaVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThetaVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.ThetaVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.ThetaVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.ThetaVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.ThetaVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.ThetaVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> ThetaVector"""
        return _stomp.ThetaVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, ThetaVector v = std::vector< Stomp::AngularBin,std::allocator< Stomp::AngularBin > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.ThetaVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.ThetaVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.ThetaVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> ThetaVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.ThetaVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, ThetaVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.ThetaVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.ThetaVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.ThetaVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.ThetaVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.ThetaVector_clear(self)

    def swap(self, *args):
        """swap(self, ThetaVector v)"""
        return _stomp.ThetaVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.ThetaVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.ThetaVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.ThetaVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.ThetaVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.ThetaVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.ThetaVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.ThetaVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> ThetaVector
        __init__(self, ThetaVector arg0) -> ThetaVector
        __init__(self, size_type size) -> ThetaVector
        __init__(self, size_type size, value_type value) -> ThetaVector
        """
        this = _stomp.new_ThetaVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.ThetaVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.ThetaVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.ThetaVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.ThetaVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.ThetaVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.ThetaVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.ThetaVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.ThetaVector_capacity(self)

    __swig_destroy__ = _stomp.delete_ThetaVector
    __del__ = lambda self : None;
ThetaVector_swigregister = _stomp.ThetaVector_swigregister
ThetaVector_swigregister(ThetaVector)

class RadialVector(_object):
    """Proxy of C++ std::vector<(Stomp::RadialBin)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadialVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.RadialVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.RadialVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.RadialVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.RadialVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.RadialVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> RadialVector"""
        return _stomp.RadialVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, RadialVector v = std::vector< Stomp::RadialBin,std::allocator< Stomp::RadialBin > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.RadialVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.RadialVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.RadialVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> RadialVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.RadialVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, RadialVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.RadialVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.RadialVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.RadialVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.RadialVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.RadialVector_clear(self)

    def swap(self, *args):
        """swap(self, RadialVector v)"""
        return _stomp.RadialVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.RadialVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.RadialVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.RadialVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.RadialVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.RadialVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.RadialVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.RadialVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> RadialVector
        __init__(self, RadialVector arg0) -> RadialVector
        __init__(self, size_type size) -> RadialVector
        __init__(self, size_type size, value_type value) -> RadialVector
        """
        this = _stomp.new_RadialVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.RadialVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.RadialVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.RadialVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.RadialVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.RadialVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.RadialVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.RadialVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.RadialVector_capacity(self)

    __swig_destroy__ = _stomp.delete_RadialVector
    __del__ = lambda self : None;
RadialVector_swigregister = _stomp.RadialVector_swigregister
RadialVector_swigregister(RadialVector)

class WAngularVector(_object):
    """Proxy of C++ std::vector<(Stomp::WeightedAngularCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WAngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WAngularVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.WAngularVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.WAngularVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.WAngularVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.WAngularVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.WAngularVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> WAngularVector"""
        return _stomp.WAngularVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, WAngularVector v = std::vector< Stomp::WeightedAngularCoordinate,std::allocator< Stomp::WeightedAngularCoordinate > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.WAngularVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.WAngularVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.WAngularVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> WAngularVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.WAngularVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, WAngularVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.WAngularVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.WAngularVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.WAngularVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.WAngularVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.WAngularVector_clear(self)

    def swap(self, *args):
        """swap(self, WAngularVector v)"""
        return _stomp.WAngularVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.WAngularVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.WAngularVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.WAngularVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.WAngularVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.WAngularVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.WAngularVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.WAngularVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> WAngularVector
        __init__(self, WAngularVector arg0) -> WAngularVector
        __init__(self, size_type size) -> WAngularVector
        __init__(self, size_type size, value_type value) -> WAngularVector
        """
        this = _stomp.new_WAngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.WAngularVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.WAngularVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.WAngularVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.WAngularVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.WAngularVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.WAngularVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.WAngularVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.WAngularVector_capacity(self)

    __swig_destroy__ = _stomp.delete_WAngularVector
    __del__ = lambda self : None;
WAngularVector_swigregister = _stomp.WAngularVector_swigregister
WAngularVector_swigregister(WAngularVector)

class CosmoVector(_object):
    """Proxy of C++ std::vector<(Stomp::CosmoCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosmoVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CosmoVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.CosmoVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.CosmoVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.CosmoVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.CosmoVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.CosmoVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> CosmoVector"""
        return _stomp.CosmoVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, CosmoVector v = std::vector< Stomp::CosmoCoordinate,std::allocator< Stomp::CosmoCoordinate > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.CosmoVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.CosmoVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.CosmoVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> CosmoVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.CosmoVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, CosmoVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.CosmoVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.CosmoVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.CosmoVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.CosmoVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.CosmoVector_clear(self)

    def swap(self, *args):
        """swap(self, CosmoVector v)"""
        return _stomp.CosmoVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.CosmoVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.CosmoVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.CosmoVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.CosmoVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.CosmoVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.CosmoVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.CosmoVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CosmoVector
        __init__(self, CosmoVector arg0) -> CosmoVector
        __init__(self, size_type size) -> CosmoVector
        __init__(self, size_type size, value_type value) -> CosmoVector
        """
        this = _stomp.new_CosmoVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.CosmoVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.CosmoVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.CosmoVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.CosmoVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.CosmoVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.CosmoVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.CosmoVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.CosmoVector_capacity(self)

    __swig_destroy__ = _stomp.delete_CosmoVector
    __del__ = lambda self : None;
CosmoVector_swigregister = _stomp.CosmoVector_swigregister
CosmoVector_swigregister(CosmoVector)

class IAngularVector(_object):
    """Proxy of C++ std::vector<(Stomp::IndexedAngularCoordinate)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAngularVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAngularVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.IAngularVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.IAngularVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.IAngularVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.IAngularVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.IAngularVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> IAngularVector"""
        return _stomp.IAngularVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, IAngularVector v = std::vector< Stomp::IndexedAngularCoordinate,std::allocator< Stomp::IndexedAngularCoordinate > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.IAngularVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.IAngularVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.IAngularVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> IAngularVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.IAngularVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, IAngularVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.IAngularVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.IAngularVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.IAngularVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.IAngularVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.IAngularVector_clear(self)

    def swap(self, *args):
        """swap(self, IAngularVector v)"""
        return _stomp.IAngularVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.IAngularVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.IAngularVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.IAngularVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.IAngularVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.IAngularVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.IAngularVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.IAngularVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> IAngularVector
        __init__(self, IAngularVector arg0) -> IAngularVector
        __init__(self, size_type size) -> IAngularVector
        __init__(self, size_type size, value_type value) -> IAngularVector
        """
        this = _stomp.new_IAngularVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.IAngularVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.IAngularVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.IAngularVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.IAngularVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.IAngularVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.IAngularVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.IAngularVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.IAngularVector_capacity(self)

    __swig_destroy__ = _stomp.delete_IAngularVector
    __del__ = lambda self : None;
IAngularVector_swigregister = _stomp.IAngularVector_swigregister
IAngularVector_swigregister(IAngularVector)

class PixelVector(_object):
    """Proxy of C++ std::vector<(Stomp::Pixel)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.PixelVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.PixelVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.PixelVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.PixelVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.PixelVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> PixelVector"""
        return _stomp.PixelVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, PixelVector v = std::vector< Stomp::Pixel,std::allocator< Stomp::Pixel > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.PixelVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.PixelVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.PixelVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> PixelVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.PixelVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, PixelVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.PixelVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.PixelVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.PixelVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.PixelVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.PixelVector_clear(self)

    def swap(self, *args):
        """swap(self, PixelVector v)"""
        return _stomp.PixelVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.PixelVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.PixelVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.PixelVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.PixelVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.PixelVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.PixelVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.PixelVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> PixelVector
        __init__(self, PixelVector arg0) -> PixelVector
        __init__(self, size_type size) -> PixelVector
        __init__(self, size_type size, value_type value) -> PixelVector
        """
        this = _stomp.new_PixelVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.PixelVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.PixelVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.PixelVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.PixelVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.PixelVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.PixelVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.PixelVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.PixelVector_capacity(self)

    __swig_destroy__ = _stomp.delete_PixelVector
    __del__ = lambda self : None;
PixelVector_swigregister = _stomp.PixelVector_swigregister
PixelVector_swigregister(PixelVector)

class ScalarVector(_object):
    """Proxy of C++ std::vector<(Stomp::ScalarPixel)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.ScalarVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.ScalarVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.ScalarVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.ScalarVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.ScalarVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> ScalarVector"""
        return _stomp.ScalarVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, ScalarVector v = std::vector< Stomp::ScalarPixel,std::allocator< Stomp::ScalarPixel > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.ScalarVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.ScalarVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.ScalarVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> ScalarVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.ScalarVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, ScalarVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.ScalarVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.ScalarVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.ScalarVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.ScalarVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.ScalarVector_clear(self)

    def swap(self, *args):
        """swap(self, ScalarVector v)"""
        return _stomp.ScalarVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.ScalarVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.ScalarVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.ScalarVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.ScalarVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.ScalarVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.ScalarVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.ScalarVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> ScalarVector
        __init__(self, ScalarVector arg0) -> ScalarVector
        __init__(self, size_type size) -> ScalarVector
        __init__(self, size_type size, value_type value) -> ScalarVector
        """
        this = _stomp.new_ScalarVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.ScalarVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.ScalarVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.ScalarVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.ScalarVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.ScalarVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.ScalarVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.ScalarVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.ScalarVector_capacity(self)

    __swig_destroy__ = _stomp.delete_ScalarVector
    __del__ = lambda self : None;
ScalarVector_swigregister = _stomp.ScalarVector_swigregister
ScalarVector_swigregister(ScalarVector)

class FieldDict(_object):
    """Proxy of C++ std::map<(std::string,double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FieldDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FieldDict, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.FieldDict_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.FieldDict___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.FieldDict___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.FieldDict___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """__getitem__(self, key_type key) -> mapped_type"""
        return _stomp.FieldDict___getitem__(self, *args)

    def __delitem__(self, *args):
        """__delitem__(self, key_type key)"""
        return _stomp.FieldDict___delitem__(self, *args)

    def has_key(self, *args):
        """has_key(self, key_type key) -> bool"""
        return _stomp.FieldDict_has_key(self, *args)

    def keys(self):
        """keys(self) -> PyObject"""
        return _stomp.FieldDict_keys(self)

    def values(self):
        """values(self) -> PyObject"""
        return _stomp.FieldDict_values(self)

    def items(self):
        """items(self) -> PyObject"""
        return _stomp.FieldDict_items(self)

    def __contains__(self, *args):
        """__contains__(self, key_type key) -> bool"""
        return _stomp.FieldDict___contains__(self, *args)

    def key_iterator(self):
        """key_iterator(self) -> SwigPyIterator"""
        return _stomp.FieldDict_key_iterator(self)

    def value_iterator(self):
        """value_iterator(self) -> SwigPyIterator"""
        return _stomp.FieldDict_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(self, key_type key)
        __setitem__(self, key_type key, mapped_type x)
        """
        return _stomp.FieldDict___setitem__(self, *args)

    def asdict(self):
        """asdict(self) -> PyObject"""
        return _stomp.FieldDict_asdict(self)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> arg0) -> FieldDict
        __init__(self) -> FieldDict
        __init__(self, FieldDict arg0) -> FieldDict
        """
        this = _stomp.new_FieldDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(self) -> bool"""
        return _stomp.FieldDict_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.FieldDict_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.FieldDict_clear(self)

    def swap(self, *args):
        """swap(self, FieldDict v)"""
        return _stomp.FieldDict_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.FieldDict_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.FieldDict_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.FieldDict_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.FieldDict_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.FieldDict_rend(self)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _stomp.FieldDict_count(self, *args)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator position)
        erase(self, iterator first, iterator last)
        """
        return _stomp.FieldDict_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _stomp.FieldDict_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _stomp.FieldDict_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _stomp.FieldDict_upper_bound(self, *args)

    __swig_destroy__ = _stomp.delete_FieldDict
    __del__ = lambda self : None;
FieldDict_swigregister = _stomp.FieldDict_swigregister
FieldDict_swigregister(FieldDict)

class FieldColumnDict(_object):
    """Proxy of C++ std::map<(std::string,uint8_t)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FieldColumnDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FieldColumnDict, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.FieldColumnDict_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.FieldColumnDict___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.FieldColumnDict___bool__(self)

    def __len__(self):
        """__len__(self) -> std::map<(std::string,unsigned char)>::size_type"""
        return _stomp.FieldColumnDict___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """__getitem__(self, std::map<(std::string,unsigned char)>::key_type key) -> std::map<(std::string,unsigned char)>::mapped_type"""
        return _stomp.FieldColumnDict___getitem__(self, *args)

    def __delitem__(self, *args):
        """__delitem__(self, std::map<(std::string,unsigned char)>::key_type key)"""
        return _stomp.FieldColumnDict___delitem__(self, *args)

    def has_key(self, *args):
        """has_key(self, std::map<(std::string,unsigned char)>::key_type key) -> bool"""
        return _stomp.FieldColumnDict_has_key(self, *args)

    def keys(self):
        """keys(self) -> PyObject"""
        return _stomp.FieldColumnDict_keys(self)

    def values(self):
        """values(self) -> PyObject"""
        return _stomp.FieldColumnDict_values(self)

    def items(self):
        """items(self) -> PyObject"""
        return _stomp.FieldColumnDict_items(self)

    def __contains__(self, *args):
        """__contains__(self, std::map<(std::string,unsigned char)>::key_type key) -> bool"""
        return _stomp.FieldColumnDict___contains__(self, *args)

    def key_iterator(self):
        """key_iterator(self) -> SwigPyIterator"""
        return _stomp.FieldColumnDict_key_iterator(self)

    def value_iterator(self):
        """value_iterator(self) -> SwigPyIterator"""
        return _stomp.FieldColumnDict_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(self, std::map<(std::string,unsigned char)>::key_type key)
        __setitem__(self, std::map<(std::string,unsigned char)>::key_type key, 
            std::map<(std::string,unsigned char)>::mapped_type x)
        """
        return _stomp.FieldColumnDict___setitem__(self, *args)

    def asdict(self):
        """asdict(self) -> PyObject"""
        return _stomp.FieldColumnDict_asdict(self)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> arg0) -> FieldColumnDict
        __init__(self) -> FieldColumnDict
        __init__(self, FieldColumnDict arg0) -> FieldColumnDict
        """
        this = _stomp.new_FieldColumnDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(self) -> bool"""
        return _stomp.FieldColumnDict_empty(self)

    def size(self):
        """size(self) -> std::map<(std::string,unsigned char)>::size_type"""
        return _stomp.FieldColumnDict_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.FieldColumnDict_clear(self)

    def swap(self, *args):
        """swap(self, FieldColumnDict v)"""
        return _stomp.FieldColumnDict_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::map<(std::string,unsigned char)>::allocator_type"""
        return _stomp.FieldColumnDict_get_allocator(self)

    def begin(self):
        """begin(self) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_begin(self)

    def end(self):
        """end(self) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_end(self)

    def rbegin(self):
        """rbegin(self) -> std::map<(std::string,unsigned char)>::reverse_iterator"""
        return _stomp.FieldColumnDict_rbegin(self)

    def rend(self):
        """rend(self) -> std::map<(std::string,unsigned char)>::reverse_iterator"""
        return _stomp.FieldColumnDict_rend(self)

    def count(self, *args):
        """count(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::size_type"""
        return _stomp.FieldColumnDict_count(self, *args)

    def erase(self, *args):
        """
        erase(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::size_type
        erase(self, std::map<(std::string,unsigned char)>::iterator position)
        erase(self, std::map<(std::string,unsigned char)>::iterator first, 
            std::map<(std::string,unsigned char)>::iterator last)
        """
        return _stomp.FieldColumnDict_erase(self, *args)

    def find(self, *args):
        """find(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, std::map<(std::string,unsigned char)>::key_type x) -> std::map<(std::string,unsigned char)>::iterator"""
        return _stomp.FieldColumnDict_upper_bound(self, *args)

    __swig_destroy__ = _stomp.delete_FieldColumnDict
    __del__ = lambda self : None;
FieldColumnDict_swigregister = _stomp.FieldColumnDict_swigregister
FieldColumnDict_swigregister(FieldColumnDict)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.DoubleVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.DoubleVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.DoubleVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _stomp.DoubleVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _stomp.DoubleVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> DoubleVector"""
        return _stomp.DoubleVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, DoubleVector v = std::vector< double,std::allocator< double > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _stomp.DoubleVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _stomp.DoubleVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> DoubleVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _stomp.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, DoubleVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _stomp.DoubleVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _stomp.DoubleVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.DoubleVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _stomp.DoubleVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.DoubleVector_clear(self)

    def swap(self, *args):
        """swap(self, DoubleVector v)"""
        return _stomp.DoubleVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _stomp.DoubleVector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _stomp.DoubleVector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _stomp.DoubleVector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _stomp.DoubleVector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _stomp.DoubleVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.DoubleVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _stomp.DoubleVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, DoubleVector arg0) -> DoubleVector
        __init__(self, size_type size) -> DoubleVector
        __init__(self, size_type size, value_type value) -> DoubleVector
        """
        this = _stomp.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _stomp.DoubleVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _stomp.DoubleVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _stomp.DoubleVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _stomp.DoubleVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _stomp.DoubleVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _stomp.DoubleVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _stomp.DoubleVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _stomp.DoubleVector_capacity(self)

    __swig_destroy__ = _stomp.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _stomp.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class IndexVector(_object):
    """Proxy of C++ std::vector<(uint32_t)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _stomp.IndexVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _stomp.IndexVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _stomp.IndexVector___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(unsigned int)>::size_type"""
        return _stomp.IndexVector___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j) -> IndexVector"""
        return _stomp.IndexVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j, 
            IndexVector v = std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j)
        """
        return _stomp.IndexVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::difference_type j)"""
        return _stomp.IndexVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(unsigned int)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _stomp.IndexVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> IndexVector
        __getitem__(self, std::vector<(unsigned int)>::difference_type i) -> std::vector<(unsigned int)>::value_type
        """
        return _stomp.IndexVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, IndexVector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(unsigned int)>::difference_type i, std::vector<(unsigned int)>::value_type x)
        """
        return _stomp.IndexVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _stomp.IndexVector_empty(self)

    def size(self):
        """size(self) -> std::vector<(unsigned int)>::size_type"""
        return _stomp.IndexVector_size(self)

    def clear(self):
        """clear(self)"""
        return _stomp.IndexVector_clear(self)

    def swap(self, *args):
        """swap(self, IndexVector v)"""
        return _stomp.IndexVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(unsigned int)>::allocator_type"""
        return _stomp.IndexVector_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(unsigned int)>::iterator"""
        return _stomp.IndexVector_begin(self)

    def end(self):
        """end(self) -> std::vector<(unsigned int)>::iterator"""
        return _stomp.IndexVector_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(unsigned int)>::reverse_iterator"""
        return _stomp.IndexVector_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(unsigned int)>::reverse_iterator"""
        return _stomp.IndexVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _stomp.IndexVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(unsigned int)>::iterator pos) -> std::vector<(unsigned int)>::iterator
        erase(self, std::vector<(unsigned int)>::iterator first, std::vector<(unsigned int)>::iterator last) -> std::vector<(unsigned int)>::iterator
        """
        return _stomp.IndexVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> IndexVector
        __init__(self, IndexVector arg0) -> IndexVector
        __init__(self, std::vector<(unsigned int)>::size_type size) -> IndexVector
        __init__(self, std::vector<(unsigned int)>::size_type size, std::vector<(unsigned int)>::value_type value) -> IndexVector
        """
        this = _stomp.new_IndexVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector_push_back(self, *args)

    def front(self):
        """front(self) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector_front(self)

    def back(self):
        """back(self) -> std::vector<(unsigned int)>::value_type"""
        return _stomp.IndexVector_back(self)

    def assign(self, *args):
        """assign(self, std::vector<(unsigned int)>::size_type n, std::vector<(unsigned int)>::value_type x)"""
        return _stomp.IndexVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(unsigned int)>::size_type new_size)
        resize(self, std::vector<(unsigned int)>::size_type new_size, std::vector<(unsigned int)>::value_type x)
        """
        return _stomp.IndexVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(unsigned int)>::iterator pos, std::vector<(unsigned int)>::value_type x) -> std::vector<(unsigned int)>::iterator
        insert(self, std::vector<(unsigned int)>::iterator pos, std::vector<(unsigned int)>::size_type n, 
            std::vector<(unsigned int)>::value_type x)
        """
        return _stomp.IndexVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(unsigned int)>::size_type n)"""
        return _stomp.IndexVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> std::vector<(unsigned int)>::size_type"""
        return _stomp.IndexVector_capacity(self)

    __swig_destroy__ = _stomp.delete_IndexVector
    __del__ = lambda self : None;
IndexVector_swigregister = _stomp.IndexVector_swigregister
IndexVector_swigregister(IndexVector)

# This file is compatible with both classic and new-style classes.


def _iter_incr(*args):
  """
    _iter_incr(std::vector<(Stomp::AngularBin,std::allocator<(Stomp::AngularBin)>)>::const_iterator iter)
    _iter_incr(std::vector<(Stomp::HistogramBin,std::allocator<(Stomp::HistogramBin)>)>::const_iterator iter)
    """
  return _stomp._iter_incr(*args)

